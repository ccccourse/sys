### 8.3 呼叫慣例

呼叫慣例（Calling Conventions）是規定函數調用過程中，調用者（caller）與被調用者（callee）如何協作的規範。它定義了在函數調用時，如何傳遞參數、如何返回結果、如何管理堆疊，以及如何保存和恢復寄存器等。呼叫慣例是編譯器設計中一個關鍵的概念，特別是在低層次的程式設計中，它直接影響程式的執行效率和可移植性。

#### 1. 呼叫慣例的功能

呼叫慣例的主要功能包括：
- **參數傳遞**：定義如何將參數從調用者傳遞給被調用者。這可以通過堆疊、寄存器或其他方式進行。
- **返回值**：規定函數返回結果的方式。通常，返回值會放在某個特定的寄存器中，或者通過參數傳遞回調用者。
- **堆疊管理**：規定調用者和被調用者如何使用堆疊來保存局部變數、返回地址、保存的寄存器等。堆疊的清理通常會有一定的約定，可能由調用者或被調用者負責。
- **寄存器保存與恢復**：規定調用過程中哪些寄存器需要保存、哪些不需要保存。這樣可以確保函數返回後，寄存器的狀態能夠正確恢復。

#### 2. 呼叫慣例的類型

根據不同的操作系統和硬體架構，呼叫慣例有所不同。以下是一些常見的呼叫慣例：

- **C 語言呼叫慣例（C Calling Convention）**：
  C 語言使用的呼叫慣例通常比較簡單，最常見的方式是將參數按順序推入堆疊，並將返回值放在寄存器中（通常是 `eax` 寄存器）。堆疊由調用者清理，這意味著調用者負責在函數返回後清除參數佔用的堆疊空間。

- **stdcall**：
  `stdcall` 是一種常見的 Windows 操作系統上的呼叫慣例。在這種慣例中，參數按順序推入堆疊，並且堆疊由被調用者清理。這意味著在函數返回之前，被調用者負責清理堆疊。`stdcall` 通常用於 Windows API 函數。

- **fastcall**：
  `fastcall` 是一種試圖提高函數調用效率的呼叫慣例。該慣例的特點是儘量使用寄存器來傳遞參數，而不是依賴堆疊。通常，前兩個參數會通過寄存器傳遞，其餘的參數則通過堆疊傳遞。這樣可以減少堆疊操作的開銷，提高性能。

- **thiscall**：
  `thiscall` 是 C++ 中類方法的呼叫慣例，用於類成員函數的調用。與其他慣例不同，`thiscall` 會將 `this` 指針（指向當前對象的指針）放在寄存器中（通常是 `ecx`），並且參數則按順序通過堆疊傳遞。`thiscall` 的堆疊清理通常由被調用者負責。

- **cdecl**：
  `cdecl` 是 C 語言中常見的呼叫慣例，尤其是在 Unix 系統中。該慣例將參數按順序推入堆疊，並且由調用者負責清理堆疊。在 `cdecl` 中，返回值通常由寄存器返回，並且沒有像 `stdcall` 那樣由被調用者清理堆疊的要求。這使得 `cdecl` 比較靈活，允許可變數量的參數。

- **System V ABI**：
  在 UNIX 類系統（如 Linux）中，`System V ABI`（Application Binary Interface）是多數平台使用的呼叫慣例。在這種慣例下，前六個整數參數被傳遞給寄存器（`rdi`、`rsi`、`rdx`、`rcx`、`r8`、`r9`），其餘的參數則通過堆疊傳遞。浮點數參數也會被放入特定的寄存器中。堆疊的清理由調用者負責。

#### 3. 呼叫慣例的設計原則

設計呼叫慣例時需要考慮以下幾個重要的原則：
- **效率**：呼叫慣例應該盡可能減少參數傳遞過程中的開銷。例如，使用寄存器傳遞參數而不是堆疊可以提高性能。
- **可移植性**：不同的操作系統和硬體架構可能使用不同的呼叫慣例，因此呼叫慣例應該具有可移植性，以便能夠跨平台運行。
- **堆疊對齊**：為了提高內存存取效率和防止崩潰，呼叫慣例需要確保堆疊的對齊方式符合硬體要求。例如，大多數系統要求堆疊地址按 16 字節對齊。
- **返回地址保護**：呼叫慣例需要確保在函數調用過程中，返回地址不會被覆蓋或損壞。這通常是通過保存返回地址在堆疊中的位置來實現的。

#### 4. 呼叫慣例的挑戰

- **不同平台之間的兼容性**：不同的操作系統和硬體平台可能會有不同的呼叫慣例，這會對跨平台開發造成挑戰。許多編譯器和工具鏈（如 GCC、Clang）會處理這些差異，但開發者仍需要了解不同平台上使用的呼叫慣例。
- **優化和調試**：不當的呼叫慣例選擇可能會導致性能問題或調試困難。選擇合適的呼叫慣例對於高效的程序設計至關重要。

#### 小結

呼叫慣例是編譯器設計中的基礎性概念，它定義了函數調用過程中的各種規範，如參數傳遞、返回值、堆疊管理等。理解和選擇合適的呼叫慣例對於提升程序性能和可維護性至關重要。在實際的編譯器設計和程式開發中，開發者需要根據具體的操作系統和硬體架構來選擇最佳的呼叫慣例。