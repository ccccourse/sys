### 全域記憶體與共享記憶體

在 CUDA 程式設計中，記憶體是影響計算效能的關鍵因素之一。CUDA 提供了多種類型的記憶體，其中全域記憶體（Global Memory）和共享記憶體（Shared Memory）是兩種最常用的記憶體類型。了解這些記憶體的特性和適當的使用方式，有助於提升程式效能，減少內存瓶頸。

---

### **1. 全域記憶體（Global Memory）**

全域記憶體是 GPU 上的一種大型記憶體區域，它可以由所有的佇列（threads）訪問。這意味著在 CUDA 程式中，所有的佇列都能讀取或寫入全域記憶體中的數據。全域記憶體的特點如下：

#### **特點：**
- **容量大**：全域記憶體是 GPU 上容量最大的記憶體，通常為數 GB。
- **延遲高**：相對於其他記憶體類型，全域記憶體的訪問延遲較高，尤其是對於非對齊的存取。
- **無法共享**：每個佇列的全域記憶體訪問是獨立的，不能直接進行佇列間的數據共享，這需要透過其他機制（如共享記憶體或全局同步）來實現。
- **低帶寬**：全域記憶體的帶寬較低，會受到訪問模式的影響，若不注意訪問模式的設計，可能會造成帶寬瓶頸。

#### **使用情境：**
全域記憶體主要用來存儲大規模數據集，如矩陣、大型陣列等，並且在不需要頻繁更新的情況下使用它來存取資料。

#### **效能注意事項：**
- **合併存取（Coalesced Memory Access）**：為了最大化全域記憶體的效能，需要確保記憶體訪問是對齊的，並且盡量避免發生未合併存取（uncoalesced access）。如果記憶體訪問模式不符合合併要求，會顯著降低效能。
- **訪問模式**：如果多個佇列對全域記憶體進行隨機訪問，會導致大量的延遲。合理的訪問模式可以大幅提高帶寬利用率。

---

### **2. 共享記憶體（Shared Memory）**

共享記憶體是一種小型但速度極快的記憶體，位於每個 CUDA 區塊（Block）內部，並且只有該區塊的佇列能夠存取。共享記憶體具有以下特點：

#### **特點：**
- **容量小**：每個區塊的共享記憶體通常只有幾十 KB（依 GPU 架構而異），遠小於全域記憶體。
- **延遲低**：共享記憶體的訪問延遲非常低，並且在區塊內的佇列之間可以進行高速讀寫。
- **區塊內共享**：只有同一個區塊的佇列可以訪問共享記憶體。這使得區塊內部的佇列能夠進行有效的數據共享和協作計算。
- **限制性使用**：共享記憶體只能由同一區塊的佇列使用，無法跨區塊進行訪問。若需要跨區塊共享數據，可以使用全域記憶體或其他同步機制。

#### **使用情境：**
共享記憶體非常適合用來進行區塊內部的數據交換，特別是當同一區塊的佇列需要共享中間計算結果時。常見的使用場景包括：
- 計算中的局部變量共享，如矩陣乘法中的中間結果。
- 將從全域記憶體中讀取的數據載入共享記憶體，並在區塊內部進行高效的運算。

#### **效能注意事項：**
- **衝突（Bank Conflicts）**：共享記憶體分為多個內存行（banks），每個行可以同時處理一次訪問。如果多個佇列同時訪問相同內存行，會發生衝突，降低訪問效能。因此，在設計時需要儘量避免衝突。
- **內存對齊**：對於最佳效能，應確保共享記憶體的數據是按照對齊要求來存儲和訪問的。適當的內存對齊可以減少衝突，並提高帶寬利用率。

---

### **3. 全域記憶體與共享記憶體的比較**

| 特徵                  | 全域記憶體                               | 共享記憶體                               |
|---------------------|--------------------------------------|--------------------------------------|
| **容量**             | 大，數 GB                             | 小，每個區塊僅有幾十 KB                  |
| **訪問速度**          | 高延遲，較慢                           | 低延遲，快速                            |
| **可共享性**          | 可以被所有佇列訪問                     | 只能被同一區塊內的佇列共享               |
| **訪問模式**          | 合併存取可提高效能，但需要對齊            | 內部高效存取，需注意避免銀行衝突（Bank Conflicts） |
| **使用情境**          | 存儲大規模數據集，如矩陣、大型陣列等       | 共享計算過程中的局部數據，避免頻繁的全域記憶體存取 |
| **效能瓶頸**          | 訪問延遲高，帶寬較低，容易遭遇未合併存取     | 記憶體容量小，需避免銀行衝突，且無法跨區塊訪問 |

---

### **4. 範例：全域記憶體與共享記憶體的使用**

假設我們有一個矩陣乘法的例子，在這個例子中，我們將數據從全域記憶體載入共享記憶體中進行計算，然後將結果寫回全域記憶體。

```cpp
__global__ void matMulShared(float *A, float *B, float *C, int N) {
    __shared__ float sharedA[16][16];
    __shared__ float sharedB[16][16];

    int tx = threadIdx.x;
    int ty = threadIdx.y;
    int row = blockIdx.y * blockDim.y + ty;
    int col = blockIdx.x * blockDim.x + tx;

    float value = 0.0f;
    
    for (int i = 0; i < (N / 16); ++i) {
        // 將數據載入共享記憶體
        sharedA[ty][tx] = A[row * N + (i * 16 + tx)];
        sharedB[ty][tx] = B[(i * 16 + ty) * N + col];
        __syncthreads();  // 等待所有佇列完成數據載入

        // 計算局部結果
        for (int k = 0; k < 16; ++k) {
            value += sharedA[ty][k] * sharedB[k][tx];
        }
        __syncthreads();  // 等待所有佇列完成計算
    }

    if (row < N && col < N) {
        C[row * N + col] = value;
    }
}
```

在這個範例中，我們將矩陣的部分數據載入共享記憶體，進行局部的計算，然後再寫回全域記憶體。這樣可以減少全域記憶體的頻繁訪問，提高效能。

---

### **總結**

- **全域記憶體**適合用於存儲大規模數據，並且可以被所有佇列訪問，但由於其較高的訪問延遲和低帶寬，需要注意記憶體訪問模式的優化（如合併存取）。
- **共享記憶體**是區塊內部的高速記憶體，適合用來進行區塊內佇列之間的數據共享，具有極低的訪問延遲，能顯著提高計算效能。
- 為了最大化效能，需要根據問題的特性，合理地利用全域記憶體和共享記憶體，並設計最佳的訪問模式。