好的，我們開始撰寫 **第九章：並行性的重新檢視** 的完整內容。這份內容會包含之前我們討論過的細節，並且加以擴展和整理。

**第九章：並行性的重新檢視**

在 xv6 中，雖然大多數程式碼都使用了鎖來確保同步，但 xv6 仍然隱含著許多並行性的問題。並行 (Parallelism) 是多核心系統中不可或缺的特性。為了發揮多核心 CPU 的性能，程式碼應該能夠並行執行，同時避免競爭條件 (race condition) 和死鎖 (deadlock) 等問題。本章將探討 xv6 中和並行性相關的概念，包括鎖的模式、無鎖程式碼、並行性如何影響程式碼的設計，並且深入說明自旋鎖在 xv6 中如何被使用。

**9.1 鎖定模式**

xv6 的程式碼使用了各種方式來保護共享資源，其中使用鎖是最常見的方式。鎖的主要功能是透過 mutual exclusion 來保護共享資料，確保一次只有一個執行緒或 CPU 可以存取或修改資料。

*   **鎖的使用原則**

    1.  **保護共享資料：**  任何被多個執行緒同時存取的共享資料，都必須使用鎖來保護。
    2.  **保護不變性：** 鎖不僅僅保護資料本身，還要保護關於這個資料的所有不變性 (invariant)。
        *   不變性是確保程式碼執行邏輯正確的基礎。例如，鏈表永遠保持串聯、變數永遠在一定的範圍內等等。
    3.  **鎖的層級：** 可以透過在資料結構中使用額外的鎖來提供更細粒度的鎖機制，例如 xv6 的緩衝區快取，針對整體快取使用 `bcache.lock`，針對個別的快取區塊使用 `b->lock`。
       *   為了避免死鎖，取得多個鎖的程式碼必須符合事先定義好的鎖取得順序。

*   **為什麼使用鎖**
     使用鎖可以確保程式碼在並行環境下的正確性，可以確保：
     *  **原子性:**  將一個複雜的操作包裝起來，使其如同一個單一指令一樣的被執行。
     *  **一致性:** 確保資料在多個執行緒之間的存取是一致的。

*   **使用鎖可能造成的問題**
     * **性能瓶頸:** 過度使用鎖可能會降低程式的並行度，產生效能瓶頸。
     *  **死鎖：** 不當使用鎖，可能會產生死鎖，導致系統資源無法正常使用。
      *   **複雜性增加:** 鎖機制的使用增加了程式碼的複雜性。

*   **鎖的粒度 (Granularity)**

    在 xv6 中，鎖的粒度 (granularity) 是一個重要的考量因素。鎖的粒度是指鎖保護的資料量大小：
     *   **粗粒度的鎖 (coarse-grained lock)：**  保護較多的資料，例如整個檔案系統的鎖，優點是容易管理，缺點是當很多執行緒都嘗試存取不同的檔案時，都需要取得此鎖，容易造成競爭。
        *   `bcache.lock` 是一個例子，所有對緩衝區快取的操作，都需要取得此鎖。
     *  **細粒度的鎖 (fine-grained lock)：** 保護較少的資料，例如每個 inode 或快取區塊的鎖，優點是較高的並行度，但缺點是實作上較為複雜。
       *    `struct buf` 結構裡的 `lock` 就是一個例子，可以讓不同的區塊可以同時讀寫，但必須使用更多的鎖來管理。
      選擇適當的鎖粒度是一門學問，需要仔細衡量效能和複雜性之間的權衡。

**9.2 類鎖定模式 (Lock-like Patterns)**

除了顯式使用鎖，xv6 還使用一些「類鎖定」的模式來保護資料。這些模式雖然不是使用真正的鎖來保護資料，但可以達到類似的效果。

*   **引用計數**
     *   在 xv6 中，許多資料結構都使用了引用計數來追蹤資源的使用情況。例如：
         *   檔案描述符 (`struct file`): 使用 `ref` 來追蹤有多少行程正在使用此檔案。
         *  Inode (`struct inode`): 使用 `ref` 來追蹤有多少個指標指向此 inode。
        *   區塊緩衝區 (`struct buf`):  使用 `refcnt` 來追蹤此區塊是否正在被使用中。
       *  當資源的引用計數降為 `0` 時，表示資源已經沒有人使用，則可以釋放。

*   **旗標**
   *   有些資源會使用布林變數或整數值來追蹤狀態，例如：
       *  行程的狀態 `p->state`，透過此來表示目前的行程是否可以被排程執行。
       *  區塊的有效性 `b->valid`，表示目前快取中的區塊是否有效。
       *  行程是否被終止的旗標 `p->killed`。
       *   這些旗標通常會搭配鎖使用，確保多個執行緒能正確判斷目前資源的狀態。

    *   `started`:  位於 `main.c` 中，用於確保只有 CPU 0 會執行初始化，其他 CPU 則會在此等待。

*   **隱式鎖**
    * 藉由程式碼的邏輯結構來保證資源的安全性，而不使用鎖。
    *  例如 `allocproc` 必須在取得行程鎖才能操作行程的狀態，確保程式碼依序執行。

**9.3 無鎖程式碼 (No Locks at All)**

有些程式碼為了效能考量，選擇不使用鎖。這些程式碼通常會透過其他的方式來確保程式碼的執行正確性。例如：
   1. **原子操作**
    *   使用 `amoswap` 這類的 RISC-V 原子操作指令，來保證一些簡單操作的原子性。
    2.  **`volatile`**
    * 使用 `volatile` 關鍵字來禁止編譯器過度優化，確保讀取和寫入操作都會存取記憶體，而不是直接從快取或暫存器中讀取。
    3.  **資料依賴**
        *   若執行流程依賴於先前操作的結果，表示操作之間存在相依性，可以避免 re-ordering 的狀況。

*   **`started` 變數：**  在 `kernel/main.c` 中有一個全域變數 `started` ，使用 `volatile` 關鍵字，確保編譯器不會將其過度優化。
    *   `started` 用於確保除了 CPU 0 之外的核心，會在初始化的部分等待，直到 CPU 0 完成核心初始化。

*   **總結**
      xv6 透過使用鎖、使用特殊的旗標，以及程式設計上的邏輯，來確保程式碼在多核心系統下的正確性。

**9.4 並行性 (Parallelism)**

xv6 的設計目標並不是追求極致的並行效能，而是著重於程式碼的簡單和易懂，因此 xv6 並沒有使用許多複雜的機制來提升多核程式碼的效能。以下是一些 xv6 中與並行相關的機制：

* **多核心執行緒**
    * xv6 支援多個 CPU 同時運行核心程式碼。
     * 每個 CPU 都有一個 `struct cpu` 結構，其中包含 `context`, `noff`, 和目前執行的行程。
* **管道操作:** 管道讀寫操作可以並行執行，不同的行程透過管道可以傳送資料。
*  **描述符管理:**  每個檔案描述符有自己的鎖，方便多個行程同時讀寫不同的檔案。
* **緩衝區管理:** 每個快取區塊都有自己的鎖，讓不同的行程可以同時讀取不同的區塊。
*   **原子操作：**  使用 `amoswap` 來保證特定程式碼片段的原子性。
    *   這也是多核心實作鎖的基礎。

*   **xv6 的限制**

    xv6 在實作平行處理時仍然有一些限制。
     *  **使用簡單的自旋鎖：**  xv6 主要使用自旋鎖，如果鎖的競爭比較嚴重，則會導致 CPU 時間的浪費。
     *  **緩慢的資料複製：**  如果使用 `memcpy` 複製大量的資料，則會造成執行緒必須等待記憶體複製完成。
     *  **缺乏複雜排程：**  xv6 的排程器比較簡單，沒有優先權的概念，也無法針對不同的硬體進行最佳化的處理。

*   **總結**

    xv6 透過有限的並行性支援，讓系統可以多工的執行。xv6 的重點放在如何使用鎖來確保程式碼在多核環境中的正確性。

**9.5 練習**

(這裡可以補充一些練習題，讓讀者思考 xv6 中 concurrency 的問題，可以參考原書的內容加入練習題。)

*   **總結**

    本章深入探討了 xv6 的鎖機制和並行性相關的概念。說明了 xv6 如何使用鎖來避免競爭條件和死鎖，以及如何在多核心環境下實現並行執行。xv6 選擇了使用自旋鎖和睡眠鎖來滿足其正確性和同步上的需求。

    在下一章中，我們將探討 xv6 的系統呼叫實作。
