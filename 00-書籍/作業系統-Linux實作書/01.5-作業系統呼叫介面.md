
### 1.5 作業系統呼叫介面 - 以 Linux 為例

作業系統呼叫介面（System Call Interface）是使用者程式與作業系統內核（Kernel）之間進行交互的橋樑。作業系統提供了一組系統呼叫，讓使用者可以進行檔案操作、記憶體管理、進程控制等基本的系統操作，而這些操作無需直接操作底層硬體。透過這些系統呼叫，應用程式可以執行需要特權或需要存取作業系統資源的操作。

#### Linux 系統呼叫概述

Linux 是一個支持多種系統呼叫的作業系統，它提供了一組豐富的系統呼叫接口，讓應用程式可以進行各種管理和操作。這些系統呼叫涵蓋了進程管理、記憶體管理、檔案操作、網路通訊等多個範疇。

系統呼叫在 Linux 中是由函數庫（如 libc）提供的封裝，這些函數會最終調用內核的系統呼叫，完成底層的操作。

---

### 1.5.1 系統呼叫的類型

1. **進程管理（Process Management）**
   - 進程的創建、終止、同步等操作。
   - 主要系統呼叫：
     - `fork()`：創建一個子進程。
     - `exec()`：替換當前進程的映像。
     - `exit()`：終止當前進程。
     - `wait()`：等待子進程結束。
     - `getpid()`：獲取當前進程的 ID。

2. **檔案操作（File Operations）**
   - 檔案的創建、打開、讀寫、關閉等操作。
   - 主要系統呼叫：
     - `open()`：打開檔案。
     - `read()`：從檔案讀取數據。
     - `write()`：向檔案寫入數據。
     - `close()`：關閉檔案。
     - `lseek()`：改變檔案指標位置。
     - `unlink()`：刪除檔案。

3. **記憶體管理（Memory Management）**
   - 分配和釋放內存，以及映射檔案到記憶體中。
   - 主要系統呼叫：
     - `mmap()`：映射檔案或設備到內存。
     - `brk()`、`sbrk()`：改變進程的數據段大小（過時，但仍支援）。
     - `munmap()`：解除映射。

4. **裝置操作（Device Operations）**
   - 應用程式與硬體裝置進行交互，如 I/O 操作。
   - 主要系統呼叫：
     - `ioctl()`：控制設備屬性。
     - `read()`、`write()`：設備的讀寫操作。

5. **網路操作（Network Operations）**
   - 支援網路套接字通信，處理 TCP/IP 協議。
   - 主要系統呼叫：
     - `socket()`：創建一個套接字。
     - `bind()`：將套接字與端口綁定。
     - `connect()`：建立到遠端主機的連接。
     - `send()`、`recv()`：發送和接收數據。
     - `close()`：關閉套接字。

---

### 1.5.2 系統呼叫的實現過程

在 Linux 中，應用程式與內核之間的系統呼叫是通過“中斷（Interrupt）”來實現的。這個過程通常分為以下幾個步驟：

1. **用戶空間向內核發起請求**  
   當應用程式調用系統呼叫（例如 `fork()` 或 `open()`）時，會將相關的參數（如檔案名稱、緩衝區地址等）傳遞給內核。這是通過特殊的指令（例如 x86 的 `int 0x80`，或 x86-64 的 `syscall`）來觸發系統呼叫。

2. **上下文切換**  
   當中斷發生時，處於用戶空間的程式會被上下文切換至內核空間，執行內核的相應邏輯。

3. **內核處理**  
   內核根據系統呼叫號（每個系統呼叫都有唯一的號碼，如 `fork()` 是系統呼叫號 2）來識別所需執行的操作，然後完成相應的操作（如創建子進程或打開檔案等）。

4. **返回用戶空間**  
   系統呼叫執行完畢後，結果（如檔案描述符、錯誤碼等）會傳遞回用戶空間，並進行上下文切換回用戶程式。用戶程式可以繼續執行，並根據返回的結果作出後續處理。

---

### 1.5.3 Linux 系統呼叫範例：創建與終止進程

以下是使用 C 語言和 Linux 作業系統呼叫的簡單範例，演示了 `fork()` 系統呼叫的使用：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();  // 創建子進程

    if (pid < 0) {
        // 錯誤處理
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // 子進程執行的代碼
        printf("This is the child process. PID = %d\n", getpid());
    } else {
        // 父進程執行的代碼
        printf("This is the parent process. PID = %d, child PID = %d\n", getpid(), pid);
    }

    return 0;
}
```

這段程式碼展示了 `fork()` 系統呼叫的基本使用。當 `fork()` 成功執行後，它會在父進程和子進程中分別返回不同的值。父進程會得到子進程的 PID，而子進程則返回 0。

---

### 1.5.4 系統呼叫的封裝

在 Linux 中，大多數系統呼叫都是通過標準函數庫（如 libc）進行封裝的。這些函數提供了更高級別的抽象，簡化了開發者的操作。比如，`open()` 和 `read()` 系統呼叫在應用程式中會使用相應的 C 語言函數 `fopen()` 和 `fread()` 來封裝。

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "r");  // 封裝的 open 系統呼叫
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }

    char buffer[100];
    size_t bytesRead = fread(buffer, 1, sizeof(buffer), file);  // 封裝的 read 系統呼叫
    printf("Read %zu bytes: %s\n", bytesRead, buffer);

    fclose(file);  // 封裝的 close 系統呼叫
    return 0;
}
```

這段程式碼利用 `fopen()` 和 `fread()` 系統呼叫來實現檔案操作，實際上它們最終會調用底層的 `open()` 和 `read()` 系統呼叫來完成操作。

---

### 小結

作業系統呼叫介面是應用程式與作業系統內核之間的溝通橋樑，讓應用程式能夠以簡單而高效的方式使用底層系統資源。在 Linux 系統中，這些系統呼叫涵蓋了多個領域，如進程管理、檔案操作、記憶體管理、網路通信等，並且通過標準函數庫（如 libc）提供封裝，簡化了程式開發。