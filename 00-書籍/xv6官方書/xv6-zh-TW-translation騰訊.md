### xv6：一個簡單的類Unix教學作業系統

Russ Cox Frans Kaashoek Robert Morris

2024年8月31日

內容
--

*   1作業系統接口
*   1.1進程和內存
*   1.2 I/O and File descriptors
*   1.3管
*   1.4文件系統
*   1.5 Real world
*   1.6 Exercises
*   2 Operating system organization
*   2.1抽象物理資源
*   2.2 User mode, supervisor mode, and system calls
*   2.3 Kernel organization
*   2.4 Code: xv6 organization
*   2.5過程概述
*   2.6代碼：啟動xv6，第一個進程和系統調用
*   2.7安全模型
*   2.8 Real world
*   2.9 Exercises
*   3頁表格
*   3.1 Paging hardware
*   3.2 Kernel address space
*   3.3代碼：創建地址空間
*   3.4物理內存分配
*   3.5代碼：物理內存分配器
*   3.6 Process address space
*   3.7 Code: sbrk
*   3.8 Code: exec
*   3.9 Real world
*   3.10 Exercises
*   4陷阱和系統調用
*   4.1 RISC-V trap machinery
*   4.2來自用戶空間的陷阱
*   4.3 Code: Calling system calls
*   4.4代碼：系統調用參數
*   4.5來自內核空間的陷阱
*   4.6頁面錯誤異常
*   4.7 Real world
*   4.8 Exercises
*   5中斷和設備驅動程式
*   5.1 Code: Console input
*   5.2代碼：控制台輸出
*   5.3驅動程式中的並發
*   5.4 Timer interrupts
*   5.5 Real world
*   5.6 Exercises
*   6 Locking
*   6.1 Races
*   6.2 Code: Locks
*   6.3 Code: Using locks
*   6.4 Deadlock and lock ordering
*   6.5 Re-entrant locks
*   6.6 Locks and interrupt handlers
*   6.7指令和存儲器排序
*   6.8 Sleep locks
*   6.9 Real world
*   6.10 Exercises
*   7 Scheduling
*   7.1 Multiplexing
*   7.2代碼：上下文切換
*   7.3 Code: Scheduling
*   7.4 Code: mycpu and myproc
*   7.5 Sleep and wakeup
*   7.6 Code: Sleep and wakeup
*   7.7產品編號：Pipes
*   7.8代碼：等待，退出，然後殺死
*   7.9 Process Locking
*   7.10 Real world
*   7.11 Exercises
*   8文件系統
*   8.1概述
*   8.2 Buffer cache layer
*   8.3 Code: Buffer cache
*   8.4 Logging layer
*   8.5 Log design
*   8.6 Code: logging
*   8.7 Code: Block allocator
*   8.8 Inode layer
*   8.9 Code: Inodes
*   8.10 Code: Inode content
*   8.11編碼：目錄層
*   8.12 Code: Path names
*   8.13 File descriptor layer
*   8.14 Code: System calls
*   8.15 Real world
*   8.16 Exercises
*   第9章重新審視並發
*   9.1 Locking patterns
*   9.2 Lock-like patterns
*   9.3 No locks at all
*   9.4並行性
*   9.5 Exercises
*   10 Summary

前言和附件
=====

這是一個關於作業系統的課程的草稿。它通過學習一個名為xv 6的內核示例來解釋作業系統的主要概念。Xv 6是以Dennis里奇和Ken Thompson的Unix版本6（v6）為模型的\[17\]。Xv 6鬆散地遵循v6的結構和風格，但在ANSI C \[7\]中實現多核RISC-V \[15\]。本文應該沿著xv 6的原始碼一起閱讀，xv 6是一種受John Li- ons對UNIX第6版的評論啟發的方法\[11\];本文有指向原始碼的超連結：http：//github.com/mit-pdos/xv6-riscv。請參閱[https://pdos.csail.mit.edu/6](https://pdos.csail.mit.edu/6)。以獲得有關v6和xv 6的在線資源的其他指針，包括幾個使用xv 6的實驗作業。我們已經在6.828和6.1810中使用了這段文字，這兩門課程是麻省理工學院的作業系統課程。我們感謝所有直接或間接為xv 6做出貢獻的教師、助教和學生。 我們特別要感謝Adam Belay、Austin Clements和Nickolai Zeldovich。最後，我們要感謝那些給我們發郵件的人，他們在文中提出了錯誤或改進建議：Abutalib Aghayev，塞巴斯蒂安Boehm，brandb 97，Anton Burtsev，Raphael Car- valho，Tej Chajed，Brendan Davidson，Rasit Eskicioglu，Color Fuzzy，Wojciech Gac，Giuseppe，Tao Guo，Haibo Hao，Naoki Hayama，Chris亨德森，Robert Hilderman，Eden Hochbaum，Wolfgang Keller，Pawestern Kraszewski，亨利Laih，Jin Li，Austin Liew，[lyazj@github.com](mailto:lyazj@github.com)，Pavan Maddamsetti，Jacek Masiulaniec，Michael McConville，m3hm00d，miguelgvieira，Mark Morrissey，Mummed Mourad，Harry Pan，Harry Porter，Siyuan Qian，Zhefeng Qiao，Askar Safin，Salman Shah，Huang Sha，Vikram Shenoy，Adeodato Simó，Ruslan Savchenko，Pawel Szczurko，Warren Toomey，tyfkda，tzerbib，Vanush Vaswani，Xi Wang，and Zou Chang Wei，Sam Whitlock，Qiongsi Wu，LucyShawYang，[ykf1114@gmail.如果](mailto:ykf1114@gmail.com)您發現錯誤或有改進建議，請發送電子郵件至Frans Kaashoek和Robert Morris（kaashoek，[rtm@csail.mit.edu](mailto:rtm@csail.mit.edu)）。

第1章
===

作業系統接口
======

作業系統的工作是在多個程式之間共享計算機，並提供比硬體單獨支持的更有用的服務集。作業系統管理和抽象低級硬體，因此，例如，字處理程式不必關心正在使用哪種類型的磁碟硬體。作業系統在多個程式之間共享硬體，以便它們同時運行（或看起來運行）。最後，作業系統為程式交互提供了受控的方式，以便它們可以共享數據或一起工作。作業系統通過接口向用戶程式提供服務。設計一個好的界面是很困難的。一方面，我們希望接口簡單而狹窄，因為這樣更容易實現正確。另一方面，我們可能會試圖為應用程式提供許多複雜的功能。 解決這種矛盾的訣竅是設計依賴於幾種機制的界面，這些機制可以組合起來提供更大的通用性。本書使用一個單一的作業系統作為一個具體的例子來說明作業系統的概念。這個作業系統xv 6提供了Ken Thompson和Dennis里奇的Unix作業系統引入的基本接口，以及模仿Unix的內部設計。Unix提供了一個狹窄的接口，其機制聯合收割機結合得很好，提供了令人驚訝的通用性。這種界面非常成功，以至於現代作業系統-BSD，Linux，macOS，Solaris，甚至在較小程度上，Microsoft Windows-都有類似Unix的界面。理解xv 6是理解這些系統和其他許多系統的一個良好開端。如圖1.1所示，xv 6採用了akernel的傳統形式，這是一個特殊的程式，為正在運行的程式提供服務。 每個正在運行的程式稱為進程，它有包含指令、數據和堆棧的內存。指令實現程式的計算。數據是計算作用的變量。堆棧組織程式的過程調用。一台給定的計算機通常有許多進程，但只有一個內核。當一個進程需要調用一個內核服務時，它會調用系統調用，這是作業系統接口中的調用之一。系統調用進入內核;內核執行服務並返回。因此，進程在用戶空間和內核空間之間交替執行。 正如後面章節中詳細描述的那樣，內核使用CPU提供的硬體保護機制來確保在用戶空間中執行的每個進程只能訪問

（^1）這段文字通常是指執行計算的硬體元件，術語CPU是首字母縮略詞

Kernel


shell cat
user
space


kernel
space


system
call


Figure 1.1: A kernel and two user processes.


自己的記憶。內核使用實現這些保護所需的硬體特權來執行;用戶程式在沒有這些特權的情況下執行。當用戶程式調用系統調用時，硬體會提高特權級別，並開始執行內核中預先安排的函數。

內核提供的系統調用的集合就是用戶程式看到的接口。xv 6內核提供了Unix內核傳統上提供的服務和系統調用的一個子集。圖1.2列出了xv 6的所有系統調用。本章的其餘部分概述了xv 6的服務--進程、內存、文件描述符、管道和文件系統--並通過代碼片段和討論Unix的命令行用戶界面theshell如何使用它們來說明它們。shell對系統調用的使用說明了它們是如何精心設計的。shell是一個普通的程式，它從用戶那裡讀取命令並執行它們。shell是一個用戶程式，而不是內核的一部分，這一事實說明了系統調用接口的強大功能：shell沒有什麼特別之處。這也意味著shell很容易替換;因此，現代Unix系統有各種各樣的shell可供選擇，每種都有自己的用戶界面和腳本功能。 xv 6 shell是Unix Bourne shell本質的一個簡單實現。它的實現可以在（user/sh.c：1）中找到。

### 1.1進程和內存

xv 6進程由用戶空間內存（指令、數據和堆棧）和內核私有的每個進程狀態組成。Xv 6分時進程：它透明地在等待執行的進程之間切換可用的CPU。當一個進程沒有執行時，xv 6保存該進程的CPU寄存器，在下次運行該進程時恢復它們。內核將進程標識符或PID與每個進程相關聯。

一個進程可以使用fork系統調用創建一個新進程。fork給新進程一個調用進程內存的精確複本：它將調用進程的指令、數據和堆棧複製到新進程的內存中。在原始進程中，fork返回新進程的PID。在新進程中，fork返回零。原始流程和新流程通常稱為父子流程。

中央處理器其他文件（例如，RISC-V規範）也使用單詞處理器、核心和哈特來代替CPU。

System call Description
int fork() Create a process, return child’s PID.
int exit(int status) Terminate the current process; status reported to wait(). No return.
int wait(int *status) Wait for a child to exit; exit status in *status; returns child PID.
int kill(int pid) Terminate process PID. Returns 0, or -1 for error.
int getpid() Return the current process’s PID.
int sleep(int n) Pause for n clock ticks.
int exec(char *file, char *argv[]) Load a file and execute it with arguments; only returns if error.
char *sbrk(int n) Grow process’s memory by n zero bytes. Returns start of new memory.
int open(char *file, int flags) Open a file; flags indicate read/write; returns an fd (file descriptor).
int write(int fd, char *buf, int n) Write n bytes from buf to file descriptor fd; returns n.
int read(int fd, char *buf, int n) Read n bytes into buf; returns number read; or 0 if end of file.
int close(int fd) Release open file fd.
int dup(int fd) Return a new file descriptor referring to the same file as fd.
int pipe(int p[]) Create a pipe, put read/write file descriptors in p[0] and p[1].
int chdir(char *dir) Change the current directory.
int mkdir(char *dir) Create a new directory.
int mknod(char *file, int, int) Create a device file.
int fstat(int fd, struct stat *st) Place info about an open file into *st.
int link(char *file1, char *file2) Create another name (file2) for the file file1.
int unlink(char *file) Remove a file.


圖1.2：Xv 6系統調用。如果沒有另外說明，這些調用返回0表示沒有錯誤，返回-1表示有錯誤。

例如，考慮以下用C程式語言編寫的程式片段\[7\]：

int pid = fork();
if(pid > 0){
printf("parent: child=%d\n", pid);
pid = wait((int *) 0);
printf("child %d is done\n", pid);
} else if(pid == 0){
printf("child: exiting\n");
exit(0);
} else {
printf("fork error\n");
}


exitsystem調用使調用進程停止執行並釋放資源，如內存和打開的文件。Exit接受一個整數狀態參數，通常0表示成功，1表示失敗。wait系統調用返回當前進程的已退出（或已終止）子進程的PID，並將子進程的退出狀態複製到傳遞給wait的地址;如果

呼叫者的孩子已經退出，等待等待一個這樣做。如果調用者沒有子級，wait立即返回-1。如果父進程不關心子進程的退出狀態，它可以傳遞一個0地址來等待。在示例中，輸出行parent：child= child：exiting

可能會以任意順序（甚至混合）出現，這取決於是父進程還是子進程先到達它的sprintfcall。子進程退出後，父進程的swait返回，導致父進程列印

parent: child 1234 is done


雖然子進程最初與父進程具有相同的內存內容，但父進程和子進程是使用單獨的內存和單獨的寄存器執行的：更改其中一個變量不會影響另一個變量。例如，當wait的返回值存儲在父進程的topic中時，它不會改變子進程中的變量lep。孩子的pid值仍然為零。execsystem調用將調用進程的內存替換為從文件系統中存儲的文件加載的新內存映像。文件必須有一個特定的格式，它指定文件的哪個部分保存指令，哪個部分是數據，從哪個指令開始，等等。Xv 6使用ELF格式，第3章將詳細討論。通常這個文件是編譯程式原始碼的結果。當exec成功時，它不會返回到調用程式;相反，從文件加載的指令在ELF頭中聲明的入口點開始執行。 exec有兩個參數：包含可執行文件的文件名和一個字符串參數數組。 舉例來說：

char *argv[3];


argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");


這個片段將調用程式替換為一個帶有參數Eschocho hello的程式/bin/echorunning的實例。大多數程式忽略參數數組的第一個元素，這通常是程式的名稱。xv 6 shell使用上述調用來代表用戶運行程式。外殼的主要結構很簡單; Replain（user/sh.c：146）。主循環使用getcmd從用戶讀取一行輸入。然後調用fork，創建shell進程的複本。父調用wait，而子運行命令。例如，如果用戶在shell中鍵入「echo hello」，則runcmd將以「echo hello」作為參數調用。runcmd（user/sh.c：55）運行實際的命令。對於「echo hello」，它將調用lexec（user/sh.c：79）。如果exec成功，則子進程將執行來自echo的指令而不是runcmd。在某個時候，techow將調用exit，這將導致父進程從waitinmain（user/sh.c：146）返回。 您可能想知道為什麼forkandexecare沒有組合在一個調用中;我們稍後將看到shell在其I/O重定向的實現中利用了這種分離。 為了避免浪費

創建一個重複的進程，然後立即替換它（用exec），操作內核通過使用虛擬內存技術（如寫時複製）優化fork的實現（見4.6節）。Xv 6隱式地分配大部分用戶空間內存：forkallocates子進程的父進程的內存複本所需的內存，exec分配足夠的內存來保存可執行文件。一個在運行時需要更多內存的進程（可能是formalloc）可以調用sbrk（n）來將其數據內存增加nzero字節; sbrk返回新內存的位置。

### 1.2 I/O and File descriptors

一個小整數，表示進程可以讀取或寫入的內核管理對象。進程可以通過打開文件、目錄或設備，或者通過創建管道，或者通過複製現有的描述符來獲得文件描述符。為了簡單起見，我們通常將文件描述符引用的對象稱為「文件」;文件描述符接口抽象了文件，管道和設備之間的差異，使它們看起來都像字節流。我們將輸入和輸出稱為I/O。在內部，xv 6內核使用文件描述符作為每個進程表的索引，以便每個進程都有一個從零開始的文件描述符私有空間。按照慣例，進程從文件描述符0（標準輸入）讀取，將輸出寫入文件描述符1（標準輸出），並將錯誤消息寫入文件描述符2（標準錯誤）。正如我們將看到的，shell利用約定來實現I/O重定向和管道。 shell確保始終打開三個文件描述符（user/sh.c：152），這是控制台的默認文件描述符。讀寫系統調用從文件描述符命名的文件讀取字節和向文件寫入字節。callread（fd，buf，n）從文件bytes中讀取mostnbytes，將它們複製到buf中，並返回讀取的字節數。每個引用文件的文件描述符都有一個與之關聯的偏移量。read從當前文件偏移量讀取數據，然後按照讀取的字節數將該偏移量向前推進：一個previentread將返回第一個返回的字節之後的字節。當沒有更多的字節要讀取時，read返回零以指示文件的結束。callwrite（fd，buf，n）將從buf寫入nbytes到文件bytes，並返回寫入的字節數。只有在發生錯誤時才寫入較少的thannbytes。 與read類似，writewrites在當前文件偏移量處寫入數據，然後按照寫入的字節數推進該偏移量：每次write從前一次停止的位置開始。下面的程式片段（構成程式的本質）將數據從標準輸入複製到標準輸出。如果發生錯誤，它會向標準錯誤寫入一條消息。

char buf[512];
int n;


for(;;){
n = read(0, buf, sizeof buf);
if(n == 0)


break;
if(n < 0){
fprintf(2, "read error\n");
exit(1);
}
if(write(1, buf, n) != n){
fprintf(2, "write error\n");
exit(1);
}
}


在代碼片段中需要注意的重要一點是cat不知道它是從文件、控制台還是管道中閱讀。同樣，cat也不知道它是列印到控制台、文件還是其他什麼地方。文件描述符的使用以及文件描述符0是輸入而文件描述符1是輸出的約定允許cat的簡單實現。這個closesource調用釋放了一個文件描述符，使它可以被將來的reopen、pipe或dupsystem調用重用（見下文）。新分配的文件描述符總是當前進程中編號最低的未使用的描述符.文件描述符和fork相互作用，使I/O重定向易於實現。fork將父文件描述符表沿著其內存，以便子文件從與父文件完全相同的打開文件開始。系統callexec替換調用進程的內存，但保留其文件表。 此行為允許shell通過分叉、重新打開子文件中選定的文件描述符，然後調用exec來運行新程式來實現I/O重定向。下面是shell為commandcat <輸入運行的代碼的簡化版本。文本：

char *argv[2];


argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
close(0);
open("input.txt", O_RDONLY);
exec("cat", argv);
}


在子進程關閉文件描述符0之後，open保證使用該文件描述符作為新打開的輸入。txt：0將是最小的可用文件描述符。cat然後使用引用input.txt的文件描述符0（標準輸入）執行。父進程的文件描述符不會被這個序列改變，因為它只修改子進程的描述符。

xv 6 shell中的I/O重定向代碼正是以這種方式工作的（user/sh.c：83）。回想一下，在代碼中的這一點上，shell已經派生出了子shell，並且runtime將調用lexec來加載新程式。第二個參數toopen由一組標誌組成，以位表示，控制open的行為。可能的值在文件控制（fcntl）頭（kernel/fcntl.h：1-5）中定義：O\_RDONLY、O\_WRONLY、O\_RDWR、O\_CREATE和O\_TRUNK，它們不能打開以打開文件

用於閱讀，或用於寫，或同時用於閱讀和寫，如果文件不存在，則創建文件，並將文件截斷為零長度。

現在應該清楚為什麼forkandex是單獨的調用是有幫助的：在兩者之間，shell有機會重定向子shell的I/O，而不會干擾主shell的I/O設置。你可以想像一個假設的combinedforkexecsystem調用，但是用這樣的調用來做I/O重定向的選項看起來很笨拙。shell可以在調用forkexec之前修改自己的I/O設置（然後取消這些修改）;或者forkexec可以將I/O重定向指令作為參數;或者（最不吸引人的是）可以教每個程式（例如cat）執行自己的I/O重定向。

儘管fork複製了文件描述符表，但是每個底層文件偏移量在父文件和子文件之間共享。請考慮以下示例：

if(fork() == 0) {
write(1, "hello ", 6);
exit(0);
} else {
wait(0);
write(1, "world\n", 6);
}


在這個片段的末尾，附加到文件描述符1的文件將包含datahello world。在父進程中的寫入（由於等待，只有在子進程完成後才運行）從子進程停止的地方開始。此行為有助於從shell命令序列生成順序輸出，如（echo hello;echo world）>output.txt。

dup系統調用複製一個現有的文件描述符，返回一個引用同一個底層I/O對象的新文件描述符。兩個文件描述符共享一個偏移量，就像forkdo複製的文件描述符一樣。這是另一種將hello world寫入文件的方法：

fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);


如果兩個文件描述符是通過一系列fork和dup調用從同一個原始文件描述符派生的，則它們共享一個偏移量。否則，文件描述符不會共享偏移量，即使它們是同一文件的所有偏移量的結果。dupallows shell實現如下命令：ls existing-file non-existing-file > tmp 1 2>&1。2> &1告訴shell給這個命令一個文件描述符2，它是描述符1的複本。現有文件的名稱和不存在文件的錯誤消息都將顯示在filetmp 1中。xv 6 shell不支持錯誤文件描述符的I/O重定向，但現在您知道如何實現它了。

文件描述符是一個強大的抽象，因為它們隱藏了它們所連接的細節：一個進程寫文件描述符1可能是寫一個文件，一個設備，如控制台，或一個管道。

### 1.3管

Apipe是一個小的內核緩衝區，作為一對文件描述符暴露給進程，一個用於閱讀，一個用於寫入。將數據寫入到管道的一端使得該數據可用於從管道的另一端閱讀。管道為進程提供了一種通信方式。下面的示例代碼使用連接到管道讀端的標準輸入運行程式。

int p[2];
char *argv[2];


argv[0] = "wc";
argv[1] = 0;


pipe(p);
if(fork() == 0) {
close(0);
dup(p[0]);
close(p[0]);
close(p[1]);
exec("/bin/wc", argv);
} else {
close(p[0]);
write(p[1], "hello world\n", 12);
close(p[1]);
}


程式調用spipe，它創建一個新的管道並在arrayp中記錄讀和寫文件描述符。在fork之後，父級和子級都有引用管道的文件描述符。子調用scloseanddup使文件描述符為零，引用管道的讀端，關閉文件描述符inp，並調用sexec以運行wc。當wcreads從它的標準輸入，它從管道讀取。父級關閉管道的讀端，寫入管道，然後關閉寫端。如果沒有數據可用，則管道上的areadon等待數據寫入或所有引用寫入結束的文件描述符關閉;在後一種情況下，read將返回0，就像已經到達數據文件的結尾一樣。 讀阻塞直到新數據不可能到達的事實是子進程在執行wc之前關閉管道的寫端很重要的一個原因：如果wc的一個文件描述符引用了管道的寫端，wc將永遠看不到文件結束。xv 6 shell實現了諸如grep fork sh. c之類的管道|wc -lin的方式類似於上面的代碼（user/sh.c：101）。子進程創建一個管道來連接管道的左端和右端。然後，它為管道的左端調用forkandruntime，為右端調用forkandruntime，並等待兩者都完成。流水線的右端可以是本身包括管道的命令（例如，一|B| c），它本身派生出兩個新的子進程（一個forbandone forc）。因此，外殼可以創建進程樹。 樹葉

這個樹的中間節點是命令，而內部節點是等待左子節點和右子節點完成的進程。管道似乎並不比臨時文件更強大：管道echo hello world| WC

可以在沒有管道的情況下實現，

echo hello world >/tmp/xyz; wc </tmp/xyz


在這種情況下，管道至少有三個優於臨時文件的優點。首先，管道會自動清理自己;使用文件重定向，shell必須小心刪除/tmp/xyz。其次，管道可以傳遞任意長的數據流，而文件重定向需要磁碟上有足夠的可用空間來存儲所有數據。第三，管道允許流水線階段的並行執行，而文件方法要求第一個程式在第二個程式開始之前完成。

### 1.4文件系統

xv 6文件系統提供數據文件和目錄，數據文件包含未解釋的字節數組，目錄包含對數據文件和其他目錄的命名引用。這些目錄形成一個樹，從一個名為根的特殊目錄開始。類似於路徑的/a/B/crefers指向名為c的文件或目錄，該文件或目錄位於名為c的目錄中，位於根目錄/中名為c的目錄的旁邊。開始不以/開頭的路徑相對於調用進程的當前目錄進行計算，該目錄可以通過chdirsystem調用進行更改。這兩個代碼片段打開同一個文件（假設所有涉及的目錄都存在）：

chdir("/a");
chdir("b");
open("c", O_RDONLY);


open("/a/b/c", O_RDONLY);


第一個片段將進程的當前目錄更改為/a/B;第二個片段既不引用也不更改進程的當前目錄。有一些系統調用可以創建新的文件和目錄：mkdir創建一個新的目錄，用O\_CREATE標誌打開創建一個新的數據文件，mknod創建一個新的設備文件。這個例子說明了所有三個：

mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);


mknod創建引用設備的特殊文件。與設備文件相關聯的是主設備號和次設備號（兩個參數tomknod），它們唯一標識內核設備。當一個進程稍後打開一個設備文件時，內核將readandwritesystem調用轉移到內核設備實現，而不是將它們傳遞給文件系統。

文件名與文件本身不同;同一個底層文件（稱為aninode）可以有多個名稱（稱為links）。每個連結由目錄中的一個條目組成;該條目包含文件名和對inode的引用。一個inode保存了關於一個文件的元數據，包括它的類型（文件、目錄或設備）、長度、文件內容在磁碟上的位置以及指向文件的連結數量。fstat系統調用從文件描述符引用的inode中檢索信息。它填充astruct stat，定義為instat.h（kernel/stat.h）：

#define T_DIR 1 // Directory
#define T_FILE 2 // File
#define T_DEVICE 3 // Device


struct stat { int dev;//文件系統的磁碟設備uint ino; // Inode number short type; //文件類型short nlink; //指向文件的連結數uint 64 size; //文件大小（字節）}; Thinksystem調用創建另一個文件系統名稱，引用與現有文件相同的inode。這個片段創建了一個名為bothaandb的新文件。

open("a", O_CREATE|O_WRONLY);
link("a", "b");


閱讀或寫與閱讀或寫相同。每個inode由一個唯一的inode編號標識。在上面的代碼序列之後，可以通過檢查offstat的結果來確定a和b引用相同的底層內容：兩者都將返回相同的inode編號（ino），然後linkcount將被設置為2。unlinksystem調用從文件系統中刪除一個名稱。只有當文件的連結計數為零並且沒有文件描述符引用它時，文件的inode和保存其內容的磁碟空間才會被釋放。因此添加

unlink("a");


到最後一個代碼序列使inode和文件內容可訪問ASB。此外，委員會認為，

fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");


是一種習慣的方法，用於創建一個沒有名稱的臨時inode，當進程關閉或退出時，該inode將被清理。Unix提供了可從shell作為用戶級程式調用的文件實用程式，例如emkdir、ln和rm。這種設計允許任何人通過添加新的用戶級程式來擴展命令行界面。事後看來，這個計劃似乎是顯而易見的，但在Unix時代設計的其他系統經常將這些命令內置到shell中（並將shell內置到內核中）。一個例外是cd，它內置在shell中（user/sh.c：161）。cd必須更改shell本身的當前工作目錄。如果cd作為常規命令運行，則shell將

fork一個子進程，子進程將運行cd，cd將改變子進程的工作目錄。父母的（即，shell的工作目錄不會改變。

### 1.5 Real world

Unix將「標準」文件描述符、管道和方便的shell語法結合在一起，這是編寫通用可重用程式的一個重大進步。這個想法引發了一種「軟體工具」的文化，這是Unix強大和流行的主要原因，shell是第一個所謂的「腳本語言」。如今，Unix系統調用接口仍然存在於BSD、Linux和macOS等系統中。Unix系統調用接口已經通過可移植作業系統接口（POSIX）標準標準進行了標準化。Xv6不符合POSIX：它缺少許多系統調用（包括基本的系統調用，如lseek），並且它提供的許多系統調用與標準不同。我們對xv6的主要目標是簡單和清晰，同時提供一個簡單的類UNIX系統調用接口。有些人已經用一些系統調用和一個簡單的C庫擴展了xv6，以便運行基本的Unix程式。 然而，現代內核提供了比xv 6更多的系統調用和更多種類的內核服務。例如，它們支持網絡工作、窗口系統、用戶級線程、許多設備的驅動程式等。現代內核不斷快速發展，並提供了許多POSIX之外的特性。Unix通過一組文件名和文件描述符接口統一訪問多種類型的資源（文件、目錄和設備）。這個想法可以擴展到更多種類的資源;一個很好的例子是Plan 9 \[16\]，它將「資源即文件」的概念應用於網絡、圖形等。然而，大多數Unix衍生的作業系統並沒有遵循這一路線。文件系統和文件描述符是功能強大的抽象。即便如此，作業系統接口還有其他模型。Multics是Unix的前身，它以一種使文件存儲看起來像內存的方式抽象了文件存儲，從而產生了一種截然不同的界面風格。 Multics設計的複雜性直接影響了Unix的設計者，他們的目標是構建更簡單的東西。Xv 6沒有提供用戶或保護一個用戶不受另一個用戶影響的概念;在Unix術語中，所有xv 6進程都以root身份運行。本書探討了xv 6如何實現其類Unix接口，但其中的思想和概念不僅僅適用於Unix。任何作業系統都必須在底層硬體上多路復用進程，將進程彼此隔離，並提供受控的進程間通信機制。在學習了xv 6之後，您應該能夠了解其他更複雜的作業系統，並在這些系統中了解xv 6的基本概念。

### 1.6 Exercises

1. 編寫一個程式，使用UNIX系統調用在兩個進程之間通過一對管道（每個方向一個管道）「桌球」一個字節。測量程式的性能，以每秒的交換次數為單位.

第2章
===

Operating system organization
=============================

作業系統的一個關鍵需求是同時支持多個活動。例如，使用第1章中描述的系統調用接口，一個進程可以用fork啟動新的進程。作業系統必須在這些進程之間分時共享計算機資源。例如，即使進程數多於硬體CPU數，作業系統也必須確保所有進程都有機會執行。作業系統還必須安排進程之間的隔離。也就是說，如果一個進程有bug並出現故障，它不應該影響不依賴於這個有bug的進程的進程。然而，完全隔離太強了，因為進程應該可以有意地交互;管道就是一個例子。因此，作業系統必須滿足三個要求：多路復用、隔離和交互。

本章概述了如何組織作業系統來實現這三個要求。事實證明，有很多方法可以做到這一點，但本文重點關注的是以單片內核為中心的主流設計，這是許多Unix作業系統所使用的。本章還提供了xv6進程的概述，它是xv6中的隔離單元，以及xv6啟動時第一個進程的創建。

Xv 6運行在多核RISC-V微處理器上，它的許多低級功能（例如，它的進程實現）是RISC-V專用的。RISC-V是一個64位CPU，而Xv 6是用「LP 64」C編寫的，這意味著C程式語言中的長（L）和指針（P）是64位，而反指針是32位。本書假設讀者已經在某些架構上做過一些機器級編程，並將居間RISC-V特定的想法。用戶級伊薩\[2\]和特權架構\[3\]文檔是完整的規範。你也可以參考《The RISC-V Reader：An Open Architecture Atlas》\[15\]。

一台完整的計算機中的CPU被支持硬體所包圍，其中大部分是I/O接口。xv 6是為qemu的「-machine virt」選項模擬的支持硬體編寫的。這包括RAM、包含靴子代碼的ROM、與用戶鍵盤/屏幕的串行連接以及用於存儲的磁碟。

（^1）本文中的「多核」是指多個CPU共享內存但並行執行，每個CPU都有自己的一組寄存器。本文有時使用術語多處理器作為多核的同義詞，儘管多處理器也可以更具體地指具有幾個不同處理器晶片的計算機。

### 2.1抽象物理資源

當遇到一個作業系統時，人們可能會問的第一個問題是為什麼要有它？也就是說，可以將圖1.2中的系統調用實現為一個庫，應用程式與之連結。在這個計劃中，每個應用程式甚至可以根據自己的需要定製自己的庫。應用程式可以直接與硬體資源交互，並以應用程式的最佳方式使用這些資源（例如，以實現高或可預測的性能）。一些嵌入式設備或實時系統的作業系統就是以這種方式組織的。這種庫方法的缺點是，如果有多個應用程式正在運行，則這些應用程式必須行為良好。例如，每個應用程式必須定期放棄CPU，以便其他應用程式可以運行。如果所有的應用程式相互信任並且沒有錯誤，這種合作的分時方案可能是可以的。 對於應用程式來說，更典型的情況是彼此不信任，並且存在錯誤，因此人們通常希望比合作方案提供的隔離更強。為了實現強隔離，禁止應用程式直接訪問敏感的硬體資源，而是將資源抽象為服務是很有幫助的。例如，Unix應用程式只通過文件系統的open、read、write和closes調用與存儲交互，而不是直接對磁碟進行閱讀和寫。這為應用程式提供了方便的路徑名，並允許作業系統（作為接口的實現者）管理磁碟。即使隔離不是一個問題，有意交互的程式（或只是希望彼此保持距離）可能會發現文件系統是一個比直接使用磁碟更方便的抽象。 類似地，Unix在進程之間透明地切換硬體CPU，在必要時保存和恢復寄存器狀態，因此應用程式不必知道分時。這種透明性允許作業系統共享CPU，即使某些應用程式處於無限循環中。作為另一個例子，Unix進程使用exec來構建它們的內存映像，而不是直接與物理內存交互。這允許作業系統決定將進程放置在內存中的何處;如果內存緊張，作業系統甚至可以將進程的一些數據存儲在磁碟上。Unix進程之間的許多形式的交互都是通過文件描述符進行的。文件描述符不僅抽象出許多細節（例如，其中存儲管道或文件中的數據），它們也以簡化交互的方式定義。 例如，如果管道中的一個應用程式失敗，內核會為管道中的下一個進程生成文件結束信號。圖1.2中的系統調用接口經過精心設計，既方便了程式設計師，又可能實現強隔離。Unix接口不是抽象資源的唯一方法，但它已被證明是一種很好的方法。

### 2.2 User mode, supervisor mode, and system calls

強隔離要求在應用程式和作業系統之間有一個硬邊界。如果應用程式出錯，我們不希望作業系統失敗或其他應用程式失敗。

失敗相反，作業系統應該能夠清理失敗的應用程式並繼續運行其他應用程式。為了實現強隔離，作業系統必須安排應用程式不能修改（甚至讀取）作業系統的數據結構和指令，並且應用程式不能訪問其他進程的內存。CPU為強隔離提供硬體支持。例如，RISC-V有三種模式，CPU可以在其中執行指令：機器模式，管理模式和用戶模式。在機器模式下執行的指令具有完全特權; CPU在機器模式下啟動。機器模式主要用於在靴子過程中設置計算機。Xv 6在機器模式下執行幾行，然後切換到管理程式模式。在管理模式下，CPU可以執行特權指令：例如，啟用和禁用中斷，閱讀和寫入保存頁表地址的寄存器等。 如果用戶模式下的應用程式試圖執行特權指令，那麼CPU不會執行該指令，而是切換到管理程式模式，以便管理程式模式代碼可以終止應用程式，因為它做了一些不應該做的事情。第1章中的圖1.1說明了這種組織。應用程式只能執行用戶模式指令（例如，添加數字等）並且被稱為在用戶空間中運行，而在管理程式模式中的軟體也可以執行特權指令並且被稱為在內核空間中運行。運行在內核空間（或管理模式）的軟體稱為內核。希望調用內核函數的應用程式（例如，xv 6中的線程系統調用）必須轉換到內核;應用程式不能直接調用內核函數。CPU提供一個特殊的指令，將CPU從用戶模式切換到管理模式，並在內核指定的入口點進入內核。 （RISC-V為此提供了指令結構。）一旦CPU切換到管理程式模式，內核就可以驗證系統調用的參數（例如，檢查傳遞給系統調用的地址是否是應用程式存儲器的一部分），決定是否允許應用程式執行所請求的操作（例如，檢查應用程式是否被允許寫入指定的文件），然後拒絕或執行它。內核控制轉換到管理程式模式的入口點是很重要的;如果應用程式可以決定內核入口點，那麼惡意應用程式可以，例如，在跳過參數驗證的點進入內核。

### 2.3 Kernel organization

一個關鍵的設計問題是作業系統的哪一部分應該以管理模式運行。一種可能性是整個作業系統都駐留在內核中，這樣所有系統調用的實現都在管理模式下運行。這種組織被稱為單片內核。在這種組織中，整個作業系統由一個具有完全硬體權限的程式組成。這種組織很方便，因為作業系統設計者不必決定作業系統的哪些部分不需要完全的硬體特權。此外，作業系統的不同部分更容易協作。例如，作業系統可能具有可由文件系統和虛擬存儲器系統共享的緩衝區高速緩存。單一組織的一個缺點是，作業系統不同部分之間的交互通常是複雜的（正如我們將在本文的其餘部分看到的那樣），因此，

Microkernel


user shell File server
space


kernel
space


（^）發送消息圖2.1：作業系統開發人員很容易在帶有文件系統伺服器的微內核中犯錯誤。在單片內核中，錯誤是致命的，因為管理模式中的錯誤通常會導致內核失敗。如果內核失敗，計算機停止工作，因此所有應用程式也會失敗。計算機必須重新啟動才能再次啟動。為了降低內核出錯的風險，作業系統設計人員可以最大限度地減少在管理模式下運行的作業系統代碼量，並在用戶模式下執行大部分作業系統。這個內核組織稱為amicrokernel。圖2.1說明了這種微內核設計。在圖中，文件系統作為用戶級進程運行。作為進程運行的作業系統服務稱為伺服器。為了允許應用程式與文件伺服器進行交互，內核提供了一種進程間通信機制，將消息從一個用戶模式進程發送到另一個用戶模式進程。 例如，如果像shell這樣的應用程式想要讀取或寫入文件，它會向文件伺服器發送一條消息並等待響應。在微內核中，內核接口由一些低級功能組成，用於啟動應用程式，發送消息，訪問設備硬體等。這種組織結構使內核相對簡單，因為大多數作業系統駐留在用戶級伺服器中。在真實的世界中，單片內核和微內核都很流行。許多Unix內核都是單片的。例如，Linux具有單片內核，儘管一些OS功能作為用戶級伺服器運行（例如，窗口系統）。Linux為作業系統密集型應用程式提供了高性能，部分原因是內核的子系統可以緊密集成。Minix、L4和QNX等作業系統被組織為伺服器的微內核，並在嵌入式環境中得到了廣泛的部署。 L4的一個變體seL4足夠小，已經驗證了它的內存安全性和其他安全屬性\[8\]。在作業系統的開發者中，關於哪種組織更好有很多爭論，並且沒有結論性的證據。此外，它在很大程度上取決於「更好」的含義：更快的性能，更小的代碼大小，內核的可靠性，整個作業系統的可靠性（包括用戶級服務）等。一些作業系統有一個微內核，但出於性能原因，在內核空間運行一些用戶級服務。一些作業系統有單片內核，因為這就是它們的開始，並且很少有動力轉向純微內核組織，因為新功能可能比重寫現有作業系統以適應微內核設計更重要。 從本書的角度來看，微內核和單片作業系統共享許多關鍵思想。 它們實現系統調用，使用頁表，處理中斷，支持

File Description
bio.c Disk block cache for the file system.
console.c Connect to the user keyboard and screen.
entry.S Very first boot instructions.
exec.c exec() system call.
file.c File descriptor support.
fs.c File system.
kalloc.c Physical page allocator.
kernelvec.S Handle traps from kernel.
log.c File system logging and crash recovery.
main.c Control initialization of other modules during boot.
pipe.c Pipes.
plic.c RISC-V interrupt controller.
printf.c Formatted output to the console.
proc.c Processes and scheduling.
sleeplock.c Locks that yield the CPU.
spinlock.c Locks that don’t yield the CPU.
start.c Early machine-mode boot code.
string.c C string and byte-array library.
swtch.S Thread switching.
syscall.c Dispatch system calls to handling function.
sysfile.c File-related system calls.
sysproc.c Process-related system calls.
trampoline.S Assembly code to switch between user and kernel.
trap.c C code to handle and return from traps and interrupts.
uart.c Serial-port console device driver.
virtio_disk.c Disk device driver.
vm.c Manage page tables and address spaces.


Figure 2.2: Xv6 kernel source files.


進程，它們使用鎖進行並發控制，它們實現文件系統等。本書重點居間這些核心思想。Xv 6是作為一個單一內核實現的，就像大多數Unix作業系統一樣。因此，xv 6內核接口對應於作業系統接口，並且內核實現了完整的作業系統。由於xv 6不提供很多服務，所以它的內核比一些微內核要小，但是從概念上講xv 6是單片的。

### 2.4 Code: xv6 organization

xv 6內核原始碼位於kernel/子目錄中。按照模塊化的大致概念，原始碼被劃分為多個文件;圖2.2列出了這些文件。模塊間接口的定義見

0


user text
and data


user stack


heap


MAXVA
trampoline
trapframe


Figure 2.3: Layout of a process’s virtual address space


defs.h(kernel/defs.h).

### 2.5過程概述

xv 6中的隔離單元（和其他Unix作業系統一樣）是一個進程。進程抽象可以防止一個進程破壞或監視另一個進程的內存、CPU、文件描述符等。它還可以防止進程破壞內核本身，因此進程無法破壞內核的隔離機制。內核必須小心地實現進程抽象，因為有缺陷的或惡意的應用程式可能會欺騙內核或硬體做一些不好的事情（例如，規避隔離）。內核用來實現進程的機制包括用戶/管理模式標誌、地址空間和線程的時間分片。為了幫助強制隔離，進程抽象為程式提供了一種錯覺，即它有自己的私有機器。一個進程為一個程式提供了一個私有的內存系統或地址空間，其他進程不能讀或寫。 進程還為程式提供看起來像是它自己的CPU來執行程式的指令。Xv 6使用頁表（由硬體實現）為每個進程提供自己的地址空間。RISC-V頁表將虛擬地址（RISC-V指令操作的地址）轉換（或「映射」）為物理地址（CPU發送到主存的地址）。Xv 6為每個進程維護一個單獨的頁表，定義該進程的地址空間。如圖2.3所示，地址空間包括從虛擬地址零開始的進程用戶內存。首先是指令，然後是全局變量，然後是堆棧，最後是進程可以根據需要擴展的「堆」區域（對於malloc）。 有許多因素限制了進程地址空間的最大大小：RISC-V上的指針是64位寬;在頁表中查找虛擬地址時，硬體只使用低39位; xv 6隻使用這39位中的38位。 因此，最大地址為238 − 1 = 0x 3fffffffff，

isMAXVA（kernel/riscv.h：378）。在地址空間的頂部，xv 6放置atrampolinepage（4096位元組）和atrapframepage。Xv 6使用這兩個頁面來轉換到內核和返回;蹦床頁面包含轉換到內核和從內核轉換出來的代碼，陷阱框架是內核保存進程的用戶寄存器的地方，如第4章所述。

xv 6內核為每個進程維護許多狀態片段，並將其收集到astruct proc（kernel/proc.h：85）中。進程最重要的內核狀態部分是它的頁表、內核堆棧和運行狀態。我們將使用符號p->xxx來引用進程結構的元素;例如，p->pagetable是指向進程頁表的指針。

每個進程都有一個控制線程（簡稱線程），它保存執行進程所需的狀態。在任何給定的時間，線程可能正在CPU上執行，或掛起（不執行，但能夠在將來恢復執行）。為了在進程之間切換CPU，內核掛起當前在該CPU上運行的線程並保存其狀態，並恢復另一個進程先前掛起的線程的狀態。線程的大部分狀態（本地瓦里、函數調用返回地址）都存儲在線程的堆棧中。每個進程有兩個堆棧：用戶堆棧和內核堆棧（p->kstack）。當進程執行用戶指令時，只有其用戶堆棧在使用中，其內核堆棧為空。當進程進入內核時（用於系統調用或中斷），內核代碼在進程的內核堆棧上執行;當進程在內核中時，其用戶堆棧仍然包含保存的數據，但不被主動使用。 一個進程的線程在活躍地使用它的用戶堆棧和內核堆棧之間交替。內核堆棧是獨立的（並且受到保護，不受用戶代碼的影響），因此即使進程破壞了其用戶堆棧，內核也可以執行。

進程可以通過執行RISC-Vecallinstruction進行系統調用。此指令提高硬體特權級別，並將程式計數器更改為內核定義的入口點。入口點處的代碼切換到進程的內核堆棧，並執行實現系統調用的內核指令。當系統調用完成時，內核切換回用戶堆棧，並通過調用這些指令返回用戶空間，這降低了硬體特權級別，並在系統調用指令之後立即恢復執行用戶指令。進程的線程可以在內核中「阻塞」以等待I/O，並在I/O完成後從中斷的地方繼續。

p->state指示進程是否已分配、準備運行、當前正在CPU上運行、等待I/O或正在退出。

p->pagetable以RISC-V硬體期望的格式保存進程的頁表。Xv 6使分頁硬體在用戶空間中執行進程'sp->pagetable時使用該進程。進程的頁表還充當分配用於存儲進程內存的物理頁地址的記錄。

總而言之，一個進程捆綁了兩種設計思想：一個地址空間，給進程一個自己內存的錯覺;一個線程，給進程一個自己CPU的錯覺。在xv 6中，一個進程由一個地址空間和一個線程組成。在真實的作業系統中，一個進程可能有多個線程來利用多個CPU。

### 2.6代碼：啟動xv 6，第一個進程和系統調用

為了使xv 6更具體，我們將概述內核如何啟動和運行第一個進程。隨後的章節將更詳細地描述本概述中出現的機制。

當RISC-V計算機通電時，它會自動啟動並運行存儲在只讀存儲器中的靴子加載程式。靴子加載程式將xv 6內核加載到內存中。然後，在機器模式下，CPU從\_entry（kernel/entry.S：7）開始執行xv 6。RISC-V從禁用分頁硬體開始：虛擬地址直接映射到物理地址。

加載程式將xv 6內核加載到物理地址為0x 80000000的內存中。它將內核放置在0x 8000000而不是0x 0的原因是因為地址範圍0x 0：0x 80000000包含I/O設備。

入口處的指令建立了一個堆棧，以便xv 6可以運行C代碼。Xv 6在文件estart.c（kernel/start.c：11）中聲明了初始堆棧stack 0的空間。at\_entry的代碼用地址stack 0 +4096（堆棧頂部）加載堆棧指針寄存器p，因為RISC-V上的堆棧向下增長。現在內核有了一個堆棧，\_entry在start（kernel/start.c：15）調用C代碼。

函數start執行某些僅在計算機模式下允許的配置，然後切換到管理程式模式。要進入管理模式，RISC-V提供指令mret。此指令最常用於從以前的調用從管理程式模式返回到計算機模式。start不是從這樣的調用返回，而是將事情設置為：它在RegistermStatus中將先前的特權模式設置為Supervisor，它通過將Main的地址寫入RegistermEPC中來將返回地址設置為Main，通過將0寫入頁表RegisterSATP中來禁用Supervisor模式中的虛擬地址轉換，並將所有中斷和異常委託給管理程式模式。

在進入管理模式之前，start還要執行一項任務：它對時鐘晶片進行編程，以生成定時器中斷。完成了這些內務處理後，start通過調用mret「返回」到超級監視器模式。這會導致程式計數器變為ain（kernel/main.c：11），即先前存儲在mepc中的地址。

在main（kernel/main.c：11）調用多個設備和子系統之後，它通過調用userinit（kernel/proc.c：233）創建第一個進程。第一個進程執行一個用RISC-V彙編編寫的小程式，該程式在xv6.initcode. S（user/initcode.S：3）中進行第一次系統調用，將執行系統調用的編號EXEC\_EXEC（kernel/syscall.h：8）加載到registera 7中，然後調用ecall重新進入內核。

內核使用registera 7insyscall（kernel/syscall.c：132）中的數字來調用所需的系統調用。系統調用表（kernel/syscall.c：107）將syslog\_exec映射到內核調用的函數sys\_exec。正如我們在第1章中看到的，exec用一個新程式（在本例中是/init）替換當前進程的內存和寄存器。

一旦內核完成exec，它將返回到/initprocess中的用戶空間。init（user/init.c：15）在需要時創建一個新的控制台設備文件，然後將其作為文件描述符0、1和2打開。然後它在控制台上啟動一個shell。系統啟動了。

### 2.7安全模型

您可能想知道作業系統如何處理錯誤或惡意代碼。因為處理惡意軟體比處理意外的bug要困難得多，所以將主要精力放在提供針對惡意軟體的安全性上是合理的。下面是作業系統設計中典型安全假設和目標的高級視圖。作業系統必須假定進程的用戶級代碼將盡最大努力破壞內核或其他進程。用戶代碼可能會嘗試解引用其允許的地址空間之外的指針;它可能會嘗試執行任何RISC-V指令，即使是那些不打算用於用戶代碼的指令;它可能會嘗試讀取和寫入任何RISC-V控制寄存器;它可能會嘗試直接訪問設備硬體;它可能會將聰明的值傳遞給系統調用，試圖欺騙內核崩潰或做一些愚蠢的事情。 內核的目標是限制每個用戶進程，使其只能讀/寫/執行自己的用戶內存，使用32個通用RISC-V寄存器，並以系統調用允許的方式影響內核和其他進程。內核必須阻止任何其他操作。這通常是內核設計中的絕對要求。對內核自身代碼的期望是完全不同的。內核代碼被認為是由善意和細心的程式設計師編寫的。內核代碼應該是無bug的，當然也不包含任何惡意代碼。這個假設會影響我們分析內核代碼的方式。例如，存在許多內部內核函數（例如，自旋鎖），如果內核代碼不正確地使用它們，將導致嚴重的問題。在檢查任何特定的內核代碼時，我們都希望說服自己它的行為是正確的。 但是，我們假設內核代碼通常都是正確編寫的，並且遵循有關使用內核自己的函數和數據結構的所有規則。在硬體層面，RISC-V CPU、RAM、磁碟等都被假定為按照文檔中所宣傳的那樣運行，沒有硬體錯誤。當然，在真實的生活中，事情並不那麼簡單。 很難防止聰明的用戶代碼通過消耗受內核保護的資源而使系統無法使用（或導致系統死機）

*   磁碟空間、CPU時間、進程表插槽等。通常不可能編寫無錯誤的內核代碼或設計無錯誤的硬體;如果惡意用戶代碼的編寫者知道內核或硬體錯誤，他們就會利用它們。即使在成熟的、廣泛使用的內核中，例如Linux，人們也不斷地發現新的漏洞\[1\]。在內核中設計保護措施來防止它有錯誤的可能性是值得的：斷言，類型檢查，堆棧保護頁等。最後，用戶和內核代碼之間的區別有時是模糊的：某些特權用戶級進程可以提供基本服務並有效地成為作業系統的一部分，在某些作業系統中，特權用戶代碼可以將新代碼插入內核（如Linux的Linux內核模塊）。

### 2.8 Real world

大多數作業系統都採用了進程的概念，而且大多數進程看起來都與xv6的類似。然而，現代作業系統支持一個進程內的多個線程，以允許單個進程利用多個CPU。在一個進程中支持多線程涉及到很多xv6所沒有的機制，通常包括接口更改（例如，Linux的克隆，

fork的變體），以控制進程線程共享的方面。

### 2.9 Exercises

1. 向xv6添加一個系統調用，返回可用的空閒內存量。

第3章
===

頁表
==

頁表是最流行的機制，作業系統通過它為每個進程提供自己的私有地址空間和內存。頁表決定了內存地址的含義，以及物理內存的哪些部分可以被訪問.它們允許xv 6隔離不同進程的地址空間，並將它們多路復用到單個物理內存中。頁表是一種流行的設計，因為它們提供了一種間接性，允許作業系統執行許多技巧。Xv 6執行了一些技巧：在幾個地址空間中映射相同的內存（一個蹦床頁面），並用一個未映射的頁面保護內核和用戶堆棧。本章的其餘部分將解釋RISC-V硬體提供的頁表以及xv 6如何使用它們。

### 3.1 Paging hardware

提醒一下，RISC-V指令（用戶和內核）操作虛擬地址。機器的RAM或物理內存是用物理地址索引的。RISC-V頁表硬體通過將每個虛擬地址映射到物理地址來連接這兩種地址。Xv 6在Sv 39 RISC-V上運行，這意味著只使用64位虛擬地址的底部39位;不使用頂部25位。在此Sv 39配置中，RISC-V頁表在邏輯上是227（134，217，728）個頁表條目（PTE）的陣列。每個PTE包含一個44位物理頁號（PPN）和一些標誌。分頁硬體通過使用39位中的前27位來索引到頁表中以找到PTE，並產生56位物理地址來轉換虛擬地址，該物理地址的前44位來自PTE中的PPN，而其後12位是從原始虛擬地址複製的。圖3.圖3.1顯示了這個過程，並將頁表的邏輯視圖作為一個簡單的PTE數組（參見圖3.2以獲得更完整的內容）。頁表使作業系統能夠以4096（212）字節的對齊塊的粒度控制虛擬到物理地址的轉換。這樣的一個塊稱為apage。在Sv 39 RISC-V中，虛擬地址的前25位不用於轉換。物理地址也有增長的空間：在PTE格式中，物理頁號還有空間再增長10位。RISC-V的設計者根據技術預測選擇了這些數字。 239位元組相當於512 GB，對於運行的應用程式來說應該有足夠的地址空間

Virtual address


Physical Address


12
Offset


12


PPN Flags


0


1


10


Page table


27
EXT


（^44）2^27 44索引25 64 56圖3.1：RISC-V虛擬和物理地址，以及簡化的邏輯頁表RISC-V計算機256是足夠的物理內存空間，在不久的將來，以適應許多I/O設備和RAM晶片。如果需要更多，RISC-V設計人員已經定義了具有48位虛擬地址的Sv 48 \[3\]。如圖3.2所示，RISC-V CPU通過三個步驟將虛擬地址轉換為物理地址。頁表以三級樹的形式存儲在物理內存中。樹的根是包含512個PTE的4096位元組的頁表頁，這些PTE包含樹的下一級中的頁表頁的物理地址。這些頁面中的每一個都包含樹中最後一級的512個PTE。分頁硬體使用27位中的前9位來選擇根頁表頁面中的PTE，中間9位用於選擇樹的下一級頁表頁面中的PTE，底部9位用於選擇最終的PTE。 (In Sv 48 RISC-V頁表有四個級別，虛擬地址的第39位到第47位索引到頂層。如果轉換地址所需的三個PTE中的任何一個不存在，分頁硬體就會引發頁面錯誤異常，讓內核來處理異常（參見第4章）。圖3.2的三級結構允許記錄PTE的存儲器高效的方式，COM-與圖3.1的單級設計。在大範圍的虛擬地址沒有映射的常見情況下，三級結構可以省略整個頁目錄。例如，如果一個應用程式只使用從地址0開始的幾個頁面，那麼頂級頁面目錄的條目1到511是無效的，並且內核不必為511中間頁面目錄分配頁面。此外，內核也不必為這511箇中間頁目錄的底層頁目錄分配頁。 因此，在這個例子中，三層設計為中間頁面目錄節省了511頁，為底層頁面目錄節省了511 × 512頁。雖然CPU在硬體中遍歷三級結構作為執行加載或存儲指令的一部分，但三級的潛在缺點是CPU必須從存儲器加載三個PTE以執行加載/存儲指令中的虛擬地址到物理地址的轉換。為了避免從物理內存加載PTE的成本，RISC-V CPU將頁表條目緩存在翻譯後備緩衝區（TLB）中。

Physical Page Number


6
A


543
U


2
W


1
V


63 8910 07


V
R
W
X
U
AD


*   Valid
*   可讀
*   Writable
*   Executable
*   User
*   Accessed
*   髒（0在頁面目錄中）

Virtual address Physical Address
9 12
L1 L0 Offset


12
PPN Offset


PPN Flags


0


1


10


Page Directory


satp


L2


PPN Flags


0


1


44 10


Page Directory


PPN Flags


0


1


511


10


Page Directory


9 9
EXT


9


511
511


44


44


44


D GU X R


A - Accessed
-G - Global


RSW


Reserved for supervisor software


53
Reserved


Figure 3.2: RISC-V address translation details.


每個PTE包含告訴分頁硬體允許如何使用相關聯的虛擬地址的標誌位。PTE\_V指示PTE是否存在：如果沒有設置，則對頁面的引用導致異常（即，不允許）。PTE\_R控制是否允許指令讀取頁面。PTE\_W控制是否允許指令寫入頁面。PTE\_X控制CPU是否可以將頁面內容解釋為指令並執行它們。PTE\_U控制是否允許用戶模式下的指令訪問頁面;如果未設置PTE\_U，則PTE只能在管理程式模式下使用。圖3.2顯示了它是如何工作的。標誌和所有其他與頁面硬體相關的結構在（kernel/riscv.h）中定義

要告訴CPU使用頁表，內核必須將根頁表頁的物理地址寫入satpregister。一個CPU將使用它自己的地址指向的頁錶轉換所有由後續指令產生的地址。每個CPU都有自己的地址空間，因此不同的CPU可以運行不同的進程，每個進程都有自己的頁表描述的私有地址空間。

從內核的角度來看，頁表是存儲在內存中的數據，內核使用代碼創建和修改頁表，就像您看到的任何樹形數據結構一樣。

關於本書中使用的術語的一些注釋。物理內存是指RAM中的存儲單元。物理內存的一個字節有一個地址，稱為物理地址。解引用地址的指令（如加載、存儲、跳轉和函數調用）只使用虛擬地址，分頁硬體將其轉換為物理地址，然後發送到RAM硬體以讀取或寫入存儲。地址空間是在給定頁表中有效的虛擬地址的集合;

每個xv 6進程都有一個單獨的用戶地址空間，xv 6內核也有自己的地址空間。用戶內存指的是進程的用戶地址空間加上頁表允許進程訪問的物理內存。虛擬內存指的是與管理頁表和使用頁表來實現隔離等目標相關的思想和技術。

0


Trampoline


Unused


Unused


Kstack 0 Unused


Guard page


Kstack 1


Guard page


0x1000
0


R-X


Virtual Addresses


CLINT


Kernel text


boot ROM


2^56-1 Physical Addresses


Unused
and other I/O devices


0x02000000


0x0C000000 PLIC

UART0


VIRTIO disk 0x10000000

0x10001000

KERNBASE
(0x80000000)


PHYSTOP
(0x88000000)


MAXVA


Kernel data


R-X


RW-


Physical memory (RAM)


VIRTIO disk
UART0


PLIC


RW-
RW-


RW-


Free memory RW-


---


---
RW-
RW-


圖3.3：左邊是xv 6的內核地址空間。RWX指的是PTE的讀、寫和執行權限。右側是xv 6期望看到的RISC-V物理地址空間。

### 3.2 Kernel address space

Xv 6為每個進程維護一個頁表，描述每個進程的用戶地址空間，另外還有一個頁表描述內核的地址空間。內核配置其地址空間的布局，使其能夠以可預測的速度訪問物理內存和各種硬體資源

虛擬地址圖3.3顯示了此布局如何將內核虛擬地址映射到物理地址。文件（kernel/memlayout.h）聲明了xv 6內核內存布局的常量。QEMU模擬一台包含RAM（物理內存）的計算機，從物理地址0x 80000000開始，至少持續到0x 88000000，xv 6稱之為PHYSTOP。QEMU模擬還包括I/O設備，如磁碟接口。QEMU將設備接口作為內存映射控制寄存器暴露給軟體，這些寄存器位於物理地址空間中的0x 80000000以下。內核可以通過閱讀/寫這些特殊的物理地址與設備交互;這樣的讀和寫與設備硬體而不是RAM通信。第4章解釋xv 6如何與設備交互。內核使用「直接映射」獲取RAM和內存映射的設備寄存器;也就是說，將資源映射到等於物理地址的虛擬地址。 例如，內核本身在虛擬地址空間和物理內存中都位於KERNBASE = 0x 80000000。直接映射簡化了讀寫物理內存的內核代碼。例如，當fork為子進程分配用戶內存時，分配器返回該內存的物理地址; fork在將父進程的用戶內存複製到子進程時，直接將該地址用作虛擬地址。 有幾個內核虛擬地址不是直接映射的：

*   蹦床頁面。它被映射到虛擬地址空間的頂部;用戶頁表具有相同的映射。第4章討論了蹦床頁面的作用，但我們在這裡看到了一個有趣的頁表用例;一個物理頁面（保存蹦床代碼）在內核的虛擬地址空間中映射兩次：一次在虛擬地址空間的頂部，一次是直接映射。
*   內核堆棧頁面。每個進程都有自己的內核堆棧，堆棧被映射到高處，這樣xv6就可以在堆棧之下留下一個未映射的保護頁。保護頁的PTE無效（即，PTE\_維斯未設置），因此，如果內核溢出內核堆棧，則可能會導致異常，內核將死機。如果沒有保護頁，溢出的堆棧將覆蓋其他內核內存，導致錯誤的操作。恐慌性崩潰更可取。雖然內核通過高內存映射使用其堆棧，但內核也可以通過直接映射地址訪問堆棧。另一種設計可能只有直接映射，並使用直接映射地址處的堆棧。然而，在這種安排中，提供保護頁將涉及取消映射虛擬地址，否則這些虛擬地址將引用物理存儲器，這將難以使用。內核使用權限PTE\_R和PTE\_X映射蹦床和內核文本的頁面。 內核從這些頁面讀取並執行指令。內核用權限PTE\_RandPTE\_W映射其他頁，這樣它就可以讀寫這些頁中的內存。防護頁的映射無效。

### 3.3代碼：創建地址空間

大多數用於操作地址空間和頁表的xv 6代碼都駐留在invm.c（ker- nel/vm.c：1）中。中央數據結構是pagetable\_t，它實際上是指向RISC-V的指針

根頁表頁; apagetable\_t可以是內核頁表，也可以是每進程頁表之一。中心函數walk（查找虛擬地址的PTE）和mappages（安裝新映射的PTE）。以kvm開始的函數操作內核頁表;以uvm開始的函數操作用戶頁表;其他函數用於. copyout和copyincopy數據到和從作為系統調用參數提供的用戶虛擬地址;它們是invm. c，因為它們需要顯式地轉換這些地址以找到相應的物理內存。

在靴子序列的早期，maincallskvminit（kernel/vm.c：54）使用kvmmake（kernel/vm.c：20）創建內核的頁表。這個調用發生在xv 6在RISC-V上啟用分頁之前，所以地址直接引用物理內存。kvmmakefirst分配一個物理內存頁來保存根頁表頁。然後它調用skvmmap來安裝內核需要的翻譯。這些轉換包括內核的指令和數據、物理內存到PHYSTOP以及實際上是設備的內存範圍。proc\_mapstacks（kernel/proc.c：33）為每個進程分配一個內核堆棧。它調用skvmap將每個堆棧映射到KSTACK生成的虛擬地址，這為無效的堆棧保護頁留下了空間。

kvmmap（kernel/vm.c：132）調用smappages（kernel/vm.c：144），它將映射安裝到頁表中，用於虛擬地址範圍到相應的物理地址範圍。它以頁間隔為範圍中的每個虛擬地址單獨執行此操作。對於每個要映射的虛擬地址，mappagescallswalk查找該地址的PTE地址。然後，它會重新定義PTE以保存相關的物理頁號、所需的權限（PTE\_W、PTE\_X和/或PTE\_R），以及PTE\_V以將PTE標記為有效（kernel/vm.c：165）。

walk（kernel/vm.c：86）在查找PTE以獲得虛擬地址時模仿RISC-V分頁硬體（參見圖3.2）。walk每次將頁表降一級，使用每級的9位虛擬地址索引相關的頁目錄頁。在每一級，它找到下一級頁面目錄頁面的PTE，或者最終頁面的PTE（kernel/vm.c：92）。如果第一級或第二級頁目錄頁中的PTE無效，則尚未分配所需的目錄頁;如果設置了allocargument，則walk分配新的頁表頁並將其物理地址放入PTE中。它返回樹中最低層（kernel/vm.c：102）中PTE的地址。

上面的代碼依賴於直接映射到內核虛擬地址空間的物理內存。例如，aswalkdescends頁表的級別，它從PTE（kernel/vm.c：94）中提取下一級頁表的（物理）地址，然後使用該地址作為虛擬地址來獲取下一級的PTE（kernel/vm.c：92）。

maincallskvminithart（kernel/vm.c：62）安裝內核頁表。它將根頁表頁的物理地址寫入registersatp。在此之後，CPU將使用內核頁表翻譯地址。由於內核使用直接映射，因此下一條指令的虛擬地址將映射到正確的物理內存地址。

每個RISC-V CPU都將頁表條目緩存在翻譯後備緩衝區（TLB）中，當xv 6更改頁表時，它必須告訴CPU使相應的緩存TLB條目無效。如果沒有，那麼在稍後的某個時候TLB可能會使用舊的緩存映射，指向一個物理頁面，該頁面在此期間已被分配給另一個進程，因此，一個進程可能會在其他進程的內存上塗鴉。RISC-V具有

刷新當前CPU的TLB的命令fence. vma。xv 6在重載了satregister之後執行fence.vmain kvminithart，並且在返回用戶空間之前切換到用戶頁表的trampoline代碼中執行（kernel/trampoline.S：89）。在更改satp之前，還需要發出fence. vmabee，以便等待所有未完成的加載和存儲完成。此等待可確保之前對頁表的更新已完成，並確保之前的加載和存儲使用舊頁表，而不是新頁表。為了避免刷新整個TLB，RISC-V CPU可能支持地址空間標識符（ASID）\[3\]。然後內核可以只刷新特定地址空間的TLB條目。Xv 6不使用此功能。

### 3.4物理內存分配

內核必須在運行時為頁表、用戶內存、內核堆棧和管道緩衝區分配和釋放物理內存。Xv 6使用內核末尾和PHYSTOP之間的物理內存進行運行時分配。它一次分配和釋放整個4096位元組的頁面。它通過在頁面本身中遍歷一個鍊表來跟蹤哪些頁面是空閒的。分配包括從鍊表中刪除頁面;釋放包括將釋放的頁面添加到列表中。

### 3.5代碼：物理內存分配器

分配器駐留在inkalloc.c（kernel/kalloc.c：1）中。分配器的數據結構是可供分配的物理內存頁的自由列表。每個空閒頁面的列表元素都是一個結構體run（kernel/kalloc.c：17）。分配器從哪裡獲得存儲數據結構的內存？它將每個空閒頁面的運行結構存儲在空閒頁面本身中，因為那裡沒有存儲任何其他東西。空閒列表由一個自旋鎖保護（kernel/kalloc.c：21-24）。列表和鎖被包裝在一個結構中，以明確鎖保護結構中的欄位。現在，忽略鎖和對獲取和釋放的調用;第6章將詳細居間鎖定。函數maincallkit初始化分配器（kernel/kalloc.c：27）。kinkit使空閒列表包含內核結束和PHYSTOP之間的每一頁。Xv 6應該通過解析硬體提供的配置信息來確定有多少物理內存可用。 相反，xv 6假設機器有128 MB的RAM。kinit調用freerange通過每頁調用tokfree將內存添加到空閒列表中。PTE只能引用在4096位元組邊界上對齊的物理地址（是4096的倍數），因此要重新設置範圍，請使用PGROUNDUP來確保它只釋放對齊的物理地址。分配器一開始沒有內存;這些調用tokfree給它一些內存來管理。分配器有時將地址視為整數以便對它們執行算術（例如，在刷新範圍內遍歷所有頁面），並且有時使用地址作為讀寫存儲器的指針（例如，操作存儲在每個頁面中的底層結構）;地址的這種雙重使用是分配器代碼充滿C類型轉換的主要原因。

函數kfree（kernel/kalloc.c：47）首先將內存中被釋放的每個字節設置為值1。這將導致在釋放內存後使用內存的代碼（使用「懸掛引用」）讀取垃圾而不是舊的有效內容;希望這將導致此類代碼更快地中斷。然後，kfree將頁面預掛到空閒列表：它將指針指向struct run，記錄空閒列表的舊開始在r->next中，並將空閒列表設置為等於或。kallocremoves並返回空閒列表中的第一個元素。

### 3.6 Process address space

每個進程都有自己的頁表，當xv 6在進程之間切換時，它也會更改頁表。圖3.4比圖2.3更詳細地顯示了進程的地址空間。一個進程的用戶內存從虛擬地址0開始，可以增長到MAXVA（kernel/riscv.h：375），允許一個進程在原則上尋址256 MB的內存。進程的地址空間由包含程式文本的頁（xv 6將其映射為權限PTE\_R、PTE\_X和PTE\_U）、包含程式預初始化數據的頁、堆棧頁和堆頁組成。Xv 6使用權限PTE\_R、PTE\_W和PTE\_U映射數據、堆棧和堆。在用戶地址空間中使用權限是強化用戶進程的常用技術。 如果用PTE\_W映射文本，那麼進程可能會意外地修改自己的程式;例如，編程錯誤可能會導致程式寫入空指針，修改地址0處的指令，然後繼續運行，可能會造成更多的破壞。為了立即檢測到這樣的錯誤，xv 6映射沒有PTE\_W的文本;如果一個程式意外地試圖存儲到地址0，硬體將拒絕執行存儲並引發頁面錯誤（見4.6節）。然後內核終止進程，並列印出一條信息性消息，以便開發人員可以跟蹤問題。類似地，通過映射沒有PTE\_X的數據，用戶程式不會意外地跳轉到程式數據中的地址並在該地址開始執行。在真實的世界中，通過仔細設置權限來加強進程也有助於防禦安全攻擊。對手可以將精心構造的輸入饋送到程式（例如，一個Web伺服器），它觸發程式中的一個bug，希望將該bug轉化為漏洞利用\[14\]。仔細設置權限和其他技術（如隨機化用戶地址空間布局）使此類攻擊更加困難。堆棧是一個頁面，並顯示由exec創建的初始內容。包含命令行參數的字符串以及指向這些參數的指針數組位於堆棧的最頂部。下面是允許程式在main啟動的值，就像函數main（argc，argv）剛剛被調用一樣。為了檢測用戶堆棧溢出分配的堆棧內存，xv6通過清除PTE\_U標誌在堆棧的正下方放置一個不可訪問的保護頁。如果用戶堆棧溢出，並且進程試圖使用堆棧下面的地址，則硬體將生成頁面錯誤異常，因為在用戶模式下運行的程式無法訪問保護頁面。 實際作業系統可能會在溢出時自動為用戶堆棧分配更多內存。當一個進程向xv 6請求更多的用戶內存時，xv 6會增加該進程的堆。 Xv 6首次使用

Figure 3.4: A process’s user address space, with its initial stack.


Kallocto分配物理頁面。然後，它將PTE添加到指向新物理頁的進程頁表中。Xv 6在這些PTE中設置PTE\_W、PTE\_R、PTE\_U和PTE\_V標誌。大多數進程不會使用整個用戶地址空間; xv 6會在未使用的PTE中釋放PTE\_Vclear。

我們在這裡看到一些使用頁表的好例子。首先，不同進程的頁表將用戶地址轉換為不同的物理內存頁，以便每個進程都擁有私有用戶內存。其次，每個進程都將其內存視為具有從零開始的連續虛擬地址，而進程的物理內存可以是不連續的。第三，內核在用戶地址空間的頂部（沒有PTE\_U）映射一個帶有蹦床代碼的頁面，因此在所有地址空間中顯示一個物理內存頁面，但只能由內核使用。

### 3.7 Code: sbrk

sbr是系統調用進程來收縮或增長其內存。系統調用由函數growproc（kernel/proc.c：260）實現。growproc調用suvmallocoruvmdealloc，取決於是正還是負。uvmalloc（kernel/vm.c：233）使用kalloc分配物理內存，將分配的內存歸零，並使用mappages將PTE添加到用戶頁表。uvmdealloccallsuvmunmap（kernel/vm.c：178），它使用walk來查找PTE，使用kfree來釋放它們所引用的物理內存。Xv 6使用進程的頁表不僅告訴硬體如何映射用戶虛擬地址，

而且還作為哪些物理存儲器頁面被分配給該進程的唯一記錄。這就是為什麼釋放用戶內存（inuvmunmap）需要檢查用戶頁表的原因。

### 3.8 Code: exec

exec是一個系統調用，它用從文件（稱為二進位或可執行文件）讀取的數據替換進程的用戶地址空間。二進位文件通常是編譯器和連結器的輸出，並保存機器指令和程式數據。exec（kernel/exec.c：23）使用namei（kernel/exec.c：36）打開命名的二進位路徑，這將在第8章中解釋。然後，它讀取ELF標頭。Xv 6二進位文件被格式化為廣泛使用的ELF格式，在（kernel/elf.h）中定義。一個ELF二進位文件由一個ELF頭文件struct elfhdr（kernel/elf.h：6）和一系列程式段頭文件struct proghdr（kernel/elf.h：25）組成。每個vhdr都描述了應用程式中必須加載到內存中的一個部分; xv 6程式有兩個程式段頭：一個用於指令，一個用於數據。第一步是快速檢查文件是否可能包含ELF二進位文件。ELF二進位文件以四字節的「幻數「0x 7 F、'E'、'L'、'F'或ELF\_MAGIC（kernel/elf.h：3）開始。 如果ELF頭具有正確的幻數，則執行假定二進位文件是格式良好的。exec使用proc\_pagetable（kernel/exec.c：49）分配一個沒有用戶映射的新頁表，使用uvmalloc（kernel/exec.c：65）為每個ELF段分配內存，並使用loadseg（kernel/exec.c：10）將每個段加載到內存中。loadseg使用walkaddr查找所分配內存的物理地址，在該地址處寫入ELF段的每個頁，並準備從文件中讀取。 使用exec創建的第一個用戶程式/init的程式段頭看起來像這樣：

objdump -p user/\_init
======================

user/\_init: file format elf64-little

程式標題：0x70000003 off 0x000000000000006bb0 vaddr 0x0000000000000 paddr 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 LOAD off 0x00000000000001000 vaddr 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 x LOAD off 0x0000000000002000 vaddr 0x00000000000001000 paddr 0x0000000000001000 align 2 \*\* 12 filesz 0x00000000000000010 memsz 0x00000000000000030 flags rw-STACK off 0x000000000000000 vaddr 0x00000000000000 paddr 0x00000000000000 align 2 \*\* 4 filesz 0x000000000000000 memsz 0x000000000000000000 flags rw-

我們看到文本段應該從文件中偏移量為0x1000的內容加載到內存中的虛擬地址0x0（沒有寫權限）。我們還看到，數據應該在地址0x1000處加載，該地址位於頁面邊界，並且沒有可執行權限。

一個程式段頭的filesz可能小於thememsz，這表明它們之間的差距應該用零填充（對於C全局變量），而不是從文件中讀取。對於/init，datafilesz為0x 10位元組，memsz為0x 30位元組，因此susvmalloc分配足夠的物理內存來容納0x 30位元組，但僅從文件/init中讀取0x 10位元組。現在執行分配和重新配置用戶堆棧。它只分配一個堆棧頁。exec每次將參數字符串複製到堆棧頂部，並在inustack中記錄指向它們的指針。它將一個空指針放置在將要傳遞給main的argvlist的末尾。argc和argv的值通過系統調用返迴路徑傳遞給main：argc通過系統調用返回值傳遞，返回值為0，argv通過進程的陷阱框架的a 1條目傳遞。execplace一個不可訪問的頁面就在堆棧頁面的下面，這樣試圖使用多個頁面的程式就會出錯。 這種不可訪問的頁面也允許sexec處理太大的參數;在這種情況下，用於將參數複製到堆棧的pypyout（kernel/vm.c：359）函數將注意到目標頁面不可訪問，並將返回-1。在準備新的內存映像的過程中，如果exec檢測到一個錯誤，比如一個無效的程式段，它會跳轉到labelbad，釋放新的映像，並返回-1。exec必須等待釋放舊的映像，直到它確定系統調用將成功：如果舊的映像已經消失，系統調用不能返回-1給它。唯一的錯誤情況是在創建映像的過程中不可避免地發生。映像完成後，執行可以提交到新的頁表（kernel/exec.c：125）並釋放舊的頁表（kernel/exec.c：129）。執行從ELF文件加載字節到內存中指定的地址ELF文件。用戶或進程可以將他們想要的任何地址放入ELF文件中。 這樣做是有風險的，因為ELF文件中的地址可能會意外地或故意地引用內核。粗心的內核的後果可能從崩潰到惡意破壞內核的隔離機制（即，安全漏洞）。Xv 6執行了一些檢查來避免這些風險。例如，eif（ph.vaddr + ph.memsz < ph.vaddr）檢查總和是否溢出64位整數。危險在於，用戶可以用指向用戶選擇的地址的aph. vaddr和足夠大的ph. memsz來構造ELF二進位文件，使得總和溢出到0x 1000，這看起來像是一個有效值。在舊版本的xv 6中，用戶地址空間也包含內核（但在用戶模式下不可讀/可寫），用戶可以選擇與內核內存對應的地址，從而將數據從ELF二進位文件複製到內核中。 在xv 6的RISC-V版本中，這不會發生，因為內核有自己獨立的頁表; loadseg加載到進程的頁表中，而不是內核的頁表中。內核開發人員很容易忽略一個關鍵的檢查，而現實世界的內核有很長的歷史，缺少檢查，用戶程式可以利用這些檢查來獲取內核特權。xv 6很可能沒有完成驗證提供給內核的用戶級數據的完整工作，惡意用戶程式可能能夠利用這一點來規避xv 6的隔離。

### 3.9 Real world

像大多數作業系統一樣，xv 6使用分頁硬體進行內存保護和映射。大多數作業系統通過結合分頁，比xv 6更複雜地使用分頁

和頁面錯誤異常，我們將在第4章討論。Xv 6通過內核使用虛擬地址和物理地址之間的直接映射來簡化，並假設在地址0x 80000000處有物理RAM，內核希望在那裡加載。這在QEMU上是可行的，但是在真實的硬體上這是一個壞主意;真實的硬體將RAM和設備放置在不可預測的物理地址上，因此（例如）在xv 6期望能夠存儲內核的0x 80000000處可能沒有RAM。更嚴肅的內核設計利用頁表將任意硬體物理內存布局轉換為可預測的內核虛擬地址布局。RISC-V支持物理地址級別的保護，但xv 6不使用該功能。在有大量內存的機器上，使用RISC-V對「超級頁面」的支持可能是有意義的。當物理內存很小時，小頁面是有意義的，以允許以精細的粒度分配和頁出到磁碟。 例如，如果一個程式只使用8兆字節的內存，那麼給它一個4兆字節的物理內存超級頁是浪費的。較大的頁在具有大量RAM的機器上是有意義的，並且可以減少頁表操作的開銷。xv 6內核缺少類似於Unix的分配器，它可以為小對象提供內存，這阻止了內核使用需要動態分配的複雜數據結構。一個更精細的內核可能會分配許多不同大小的小塊，而不是（像xv 6中那樣）僅僅分配4096位元組的塊;一個真實的內核分配器需要處理小的分配和大的分配。內存分配是一個長期的熱門話題，基本問題是有效地使用有限的內存和為未知的未來請求做準備\[9\]。如今，人們更關心速度而不是空間效率。

### 3.10 Exercises

1. 解析RISC-V的設備樹以查找計算機擁有的物理內存量。
2. 編寫一個用戶程式，通過調用sbrk（1）將其地址空間增加一個字節。運行程式，並在調用tosbrk之前和之後調查程式的頁表。內核分配了多少空間？新內存的PTE包含什麼？
3. 修改xv 6以在內核中使用超級頁面。
4. 傳統上，exec的Unix實現包括對shell腳本的特殊處理。如果要執行的文件以文本#！開頭，則第一行被認為是要運行以解釋該文件的程式。例如，如果調用exec來運行myprog arg 1，而myprog的第一行是#！/ interp，則執行程式使用命令行/interp myprog arg 1運行/interp。在xv 6中實現對這個約定的支持。
5. 為內核實現地址空間布局隨機化。

第4章
===

陷阱和系統調用
=======

有三種事件會導致CPU將指令的正常執行放在一邊，並強制將控制轉移到處理該事件的特殊代碼。一種情況是系統調用，當用戶程式執行指令要求內核為它做些什麼時;另一種情況是異常：指令（用戶或內核）做了一些非法的事情，如除以零或使用無效的虛擬地址。第三種情況是設備中斷，當設備發出信號表示需要注意時，例如當磁碟硬體完成讀或寫請求時。

本書對這些情況使用了一個通用術語。通常，在陷阱發生時正在執行的任何代碼稍後都需要恢復，並且不需要知道發生了什麼特殊的事情。也就是說，我們通常希望陷阱是透明的;這對於設備中斷尤其重要，因為被中斷的代碼通常不希望這樣。通常的順序是陷阱強制將控制轉移到內核中;內核保存寄存器和其他狀態，以便可以恢復執行;內核執行適當的處理程式代碼（例如，系統調用實現或設備驅動程式）;內核恢復所保存的狀態並從陷阱返回;並且原始代碼從它停止的地方恢復。

Xv 6處理內核中的所有陷阱;陷阱不會傳遞給用戶代碼。在內核中處理陷阱對於系統調用來說是很自然的。這對中斷來說是有意義的，因為隔離要求只有內核才能使用設備，而且內核是一種方便的機制，可以在多個進程之間共享設備。這對異常也是有意義的，因為xv 6通過殺死違規程式來響應來自用戶空間的所有異常。

Xv 6陷阱處理分為四個階段：RISC-V CPU執行的硬體操作、為內核C代碼準備的一些彙編指令、決定如何處理陷阱的C函數以及系統調用或設備驅動程式服務例程。雖然這三種陷阱類型之間的共性表明內核可以用一個代碼路徑處理所有陷阱，但事實證明，對於兩種不同的情況（來自用戶空間的陷阱和來自內核空間的陷阱），使用單獨的代碼是很方便的。處理陷阱的內核代碼（彙編程式或C）通常被稱為處理程式;第一個處理程式指令通常是用彙編程式（而不是C）編寫的，有時被稱為向量。

### 4.1 RISC-V trap machinery

每個RISC-V CPU都有一組控制寄存器，內核寫入這些寄存器來告訴CPU如何處理陷阱，內核可以讀取這些寄存器來找出發生的陷阱。RISC-V文檔包含完整的故事\[3\]。riscv.h（kernel/riscv.h：1）包含xv 6使用的定義。以下是最重要的寄存器概述：

*   stvec：內核在這裡寫入陷阱處理程式的地址; RISC-V跳轉到地址instvec來處理陷阱。
*   sepc：當陷阱發生時，RISC-V將程式計數器保存在這裡（因為pc隨後被值instvec覆蓋）。ret（從陷阱返回）指令將sepc複製到pc。內核可以寫sepc來控制它的去向。
*   原因：RISC-V在這裡放了一個數字，描述了陷阱的原因。
*   sscratch：陷阱處理程式代碼使用sscratch來幫助它在保存用戶註冊表之前避免這些用戶註冊表。
*   sstatus：SIE位insstatus控制是否啟用設備中斷。如果內核清除SIE，RISC-V將延遲設備中斷，直到內核設置SIE。SPP位指示陷阱是來自用戶模式還是管理程式模式，並控制返回到哪種模式。

上述寄存器與在管理程式模式下處理的陷阱有關，在用戶模式下無法讀取或寫入。多核晶片上的每個CPU都有自己的一組寄存器，並且在任何給定時間都可能有多個CPU處理陷阱。當需要強制陷阱時，RISC-V硬體對所有陷阱類型執行以下操作：

1. 如果陷阱是一個設備中斷，並且狀態SIE位被清除，則不要執行以下任何操作。
2. 通過清除SIE位insstatus禁用中斷。
3. Copy thepctosepc.
4. 在SPP位insstatus中保存當前模式（用戶或管理員）。
5. Setscauseto reflect the trap’s cause.
6. Set the mode to supervisor.
7. Copystvecto thepc.
8. Start executing at the newpc.

注意，CPU不會切換到內核頁表，不會切換到內核中的堆棧，也不會保存pc以外的任何寄存器。內核軟體必須執行這些任務。CPU在陷阱期間做最少工作的一個原因是為軟體提供靈活性;例如，某些作業系統在某些情況下省略頁表開關以提高陷阱性能。值得思考的是，是否可以省略上面列出的任何步驟，也許是為了尋找更快的陷阱。雖然在某些情況下，一個更簡單的序列可以工作，但通常省略許多步驟是危險的。例如，假設CPU沒有切換程式計數器。然後，來自用戶空間的陷阱可以切換到管理程式模式，同時仍然運行用戶指令。這些用戶指令可能會破壞用戶/內核隔離，例如，通過修改satpregister來指向允許訪問所有物理內存的頁表。 因此，CPU必須切換到內核指定的指令地址namelystvec。

### 4.2來自用戶空間的陷阱

Xv 6處理陷阱的方式不同，這取決於陷阱是在內核中執行還是在用戶代碼中執行。下面是來自用戶代碼的陷阱的故事;第4.5節描述了來自內核代碼的陷阱。如果用戶程式執行系統調用（ecall指令），或者做了非法的事情，或者設備中斷，則在用戶空間中執行時可能會發生陷阱。陷阱從用戶空間的高級路徑是uservec（kernel/trampoline.S：22），然後是usertrap（kernel/trap.c：37）;當返回時，是usertapret（kernel/trap.c：90），然後是userret（kernel/trampoline.S：101）。xv 6陷阱處理設計的一個主要限制是RISC-V硬體在強制陷阱時不會切換頁表。這意味著stvec中的陷阱處理程式地址必須在用戶頁表中有一個有效的映射，因為當陷阱處理代碼開始執行時，用戶頁表是有效的頁表。 此外，xv 6的陷阱處理代碼需要切換到內核頁表;為了能夠在切換後繼續執行，內核頁表還必須有指向bystvec的處理程式的映射。Xv 6使用atrampolinepage滿足這些要求。trampoline頁面包含suservec，stvec指向的xv 6陷阱處理代碼。蹦床頁面被映射到每個進程的頁表中的addressTRAMPOLINE，它位於虛擬地址空間的頂部，因此它將位於程式自己使用的內存之上。蹦床頁也映射到內核頁表中的地址TRAMPOLINE。見圖2.3和圖3.3。因為蹦床頁面映射在用戶頁面表中，所以陷阱可以在管理模式下開始執行。因為蹦床頁面映射到內核地址空間中的同一地址，所以陷阱處理程式可以在切換到內核頁面表後繼續執行。 uservecrap處理程式的代碼是intrampoline.S（kernel/trampoline.S：22）。當uservec啟動時，所有32個寄存器都包含被中斷的用戶代碼所擁有的值。這32個值需要保存在內存中的某個地方，以便內核稍後可以在返回用戶空間之前恢復它們。存儲到內存需要使用寄存器來保存地址，但此時沒有通用寄存器可用！幸運的是，RISC-V以哈希寄存器的形式提供了幫助。 在uservecsavesa 0 in的開始處的csrwin結構

擦。現在用戶有一個寄存器（a0）可以使用。

uservec的下一個任務是保存32個用戶寄存器。內核為每個進程分配一頁內存給atrapframestructure，它有足夠的空間保存32個用戶寄存器（kernel/proc.h：43）。因為asp仍然引用用戶頁表，所以uservec需要在用戶地址空間中映射陷阱框架。Xv 6將每個進程的陷阱框架映射到該進程的用戶頁表中的虛擬地址TRAPFRAM; TRAPFRAM就在TRAMPOLINE之下。進程'sp->trapframe也指向trapframe，但指向的是它的物理地址，因此內核可以通過內核頁表使用它。

因此，uservec將addressTRAPFRAME加載到0，並將所有用戶寄存器保存在那裡，包括從scratch讀回的用戶的sa 0。

trapframe包含當前進程的內核堆棧地址、當前CPU的hartid、usertrap函數的地址和內核頁表的地址。uservec檢索這些值，將switchesatp切換到內核頁表，然後跳轉到trap。

usertrap的工作是確定陷阱的原因，處理它，並返回（kernel/- trap.c：37）。它首先改變了stvec，使內核中的陷阱將由內核vec而不是用戶vec處理。它保存了epcregister（保存的用戶程式計數器），因為usertrap可能會調用ield切換到另一個進程的內核線程，而該進程可能會返回到用戶空間，在該進程中它將修改sepc。如果陷阱是一個系統調用，usertrapcallssyscall來處理它;如果是一個設備中斷，則調用devintr;否則它是一個異常，內核會殺死出錯的進程。系統調用路徑將保存的用戶程式計數器加4，因為在系統調用的情況下，RISC-V將程式指針指向指令，但用戶代碼需要在後續指令處恢復執行。在退出時，usertrap檢查進程是否已被終止或應該放棄CPU（如果此陷阱是定時器中斷）。

返回用戶空間的第一步是調用tousertrapret（kernel/trap.c：90）。此函數設置RISC-V控制寄存器，為將來從用戶空間捕獲做好準備：設置stvectouservice並準備用戶依賴的捕獲幀欄位。usertrapret將sepc設置為先前保存的用戶程式計數器。最後，usertrapret在映射到用戶頁表和內核頁表的蹦床頁上調用suserret;原因是userret中的as-sort代碼會切換頁表。

usertrapret的調用touserret傳遞一個指針到進程的用戶頁表ina 0（kernel/trampoline.S：101）. userretswitchessatp到進程的用戶頁表。回想一下，用戶頁表映射蹦床頁和TRAPFRAME，但不映射內核中的其他內容。用戶和內核頁表中相同虛擬地址處的蹦床頁映射允許userret在更改satp後繼續執行。從這一點開始，唯一的datauserret可以使用的是寄存器內容和陷阱幀的內容。userret將TRAPFRAME地址加載到a0，通過aa 0從陷阱幀恢復保存的用戶寄存器，恢復保存的用戶a0，然後執行ssret返回到用戶空間。

### 4.3 Code: Calling system calls

第2章以initcode. S調用exec系統調用（user/initcode.S：11）結束。讓我們看看用戶調用是如何到達內核中的執行系統調用的實現的。初始化代碼。將參數替換為寄存器a0和a1，並將系統調用號替換為a7。系統調用號與syscallsarray中的條目匹配，syscallsarray是一個函數指針表（kernel/syscall.c：107）。該構造會進入內核並導致uservec、usertrap和syscall執行，正如我們上面看到的。syscall（kernel/syscall.c：132）從陷阱幀中的saveda 7中檢索系統調用號，並使用它來索引syscalls。對於第一個系統調用，a7包含了SYS\_exec（ker- nel/syscall.h：8），導致了對系統調用實現函數sys\_exec的調用。當sys\_exec返回時，syscall將其返回值記錄在p->trapframe->a0中。這將導致原始的用戶空間調用toexec（）返回該值，因為RISC-V上的C調用約定將返回值放置在0中。 系統調用通常返回負數表示錯誤，返回零或正數表示成功。如果系統調用號無效，則syscall列印錯誤並返回-1。

### 4.4代碼：系統調用參數

內核中的系統調用實現需要找到用戶代碼傳遞的參數。由於用戶代碼調用系統調用包裝函數，因此參數最初位於RISC-V C調用約定放置它們的位置：寄存器中。內核陷阱代碼將用戶寄存器保存到當前進程的陷阱框架中，內核代碼可以在其中找到它們。然後，內核函數argint、argaddr和argf從陷阱幀中以整數、指針或文件描述符的形式獲取系統調用參數。它們都調用graw來檢索相應的保存的用戶註冊表（kernel/syscall.c：34）。一些系統調用將指針作為參數傳遞，內核必須使用這些指針來讀取或寫入用戶內存。例如，execsystem調用向內核傳遞一個指針數組，這些指針指向用戶空間中的字符串參數。這些指標提出了兩個挑戰。 首先，用戶程式可能存在錯誤或惡意，並且可能向內核傳遞無效指針或旨在欺騙內核訪問內核內存而不是用戶內存的指針。其次，xv 6內核頁表映射與用戶頁表映射不同，因此內核不能使用普通指令從用戶提供的地址加載或存儲。內核實現的函數可以安全地將數據傳輸到用戶提供的地址或從用戶提供的地址傳輸數據。fetchstris是一個例子（kernel/syscall.c：25）。文件系統調用（如asexecusefetchstr）從用戶空間檢索字符串文件名參數。copyinstr（kernel/vm.c：415）從虛擬地址rcvain用戶頁表複製到最多x字節。由於pagetable不是當前頁表，copyinstr使用walkaddr（它調用swalk）查找srcvainpagetable，得到物理地址pa 0。 內核的頁表將所有物理RAM映射到與RAM的物理地址相等的虛擬地址。這允許scopython直接將字符串字節從pa 0複製到dst。walkaddr（kernel/vm.c：109）檢查用戶提供的虛擬地址是否是進程的

用戶地址空間，所以程式不能欺騙內核閱讀其他內存。一個類似的函數copyout將數據從內核複製到用戶提供的地址。

### 4.5來自內核空間的陷阱

Xv 6處理來自內核代碼的陷阱的方式與處理來自用戶代碼的陷阱的方式不同。當進入內核時，usertrappointsstvec到彙編代碼atkernelvec（kernel/kernelvec.S：12）。由於kernelvec只在xv 6已經在內核中的情況下執行，因此kernelvec可以依賴於設置為內核頁表的sat，以及指向有效內核堆棧的堆棧指針。kernelvec將所有32個寄存器推到堆棧上，稍後將從堆棧中恢復它們，以便中斷的內核代碼可以恢復而不受干擾。kernelvec將寄存器保存在中斷的內核線程的堆棧上，這是有意義的，因為寄存器值屬於該線程。如果陷阱導致切換到另一個線程，這一點尤其重要-在這種情況下，陷阱實際上將從新線程的堆棧返回，將中斷線程的保存寄存器安全地留在其堆棧上。kernelvec在保存寄存器後跳轉tokerneltrap（kernel/trap.c：135）。kerneltrap是為兩種類型的陷阱準備的：設備中斷和異常。它調用sdevintr（kernel/- trap.c：185）來檢查和處理前者。如果陷阱不是設備中斷，那麼它一定是一個異常，如果它發生在xv 6內核中，那麼這總是一個致命錯誤;內核調用spanic並停止執行。如果由於定時器中斷而調用了kerneltrap，並且進程的內核線程正在運行（而不是調度程式線程），則kerneltrap會調用它來給其他線程一個運行的機會。在某個時候，其中一個線程將屈服，讓我們的線程和它的線程再次假設。第7章解釋了屈服所發生的事情。當kerneltrap的工作完成時，它需要返回到被陷阱中斷的任何代碼。因為ayield可能已經擾亂了sepc和前一個模式insstatus，所以kerneltrap在啟動時保存它們。它現在恢復這些控制寄存器並返回到kernelvec（kernel/kernelvec.S：38）。kernelvec從堆棧中彈出保存的寄存器並執行executesret，後者複製sepctop並恢復中斷的內核代碼。如果由於定時器中斷而調用了dyield，那麼有必要考慮一下陷阱返回是如何發生的。當CPU從用戶空間進入內核時，Xv 6設置CPU的stvectokernelve;您可以在usertrap（kernel/trap.c：29）中看到這一點。當內核開始執行時，會有一個時間窗口，但是stvecis仍然設置為touservec，在這個時間窗口期間，沒有設備中斷發生是至關重要的。幸運的是，RISC-V總是在開始捕獲陷阱時禁用中斷，並且用戶陷阱在設置stvec之後才再次啟用它們。

### 4.6頁面錯誤異常

Xv 6對異常的響應是相當無聊的：如果異常發生在用戶空間，內核會殺死出錯的進程。如果在內核中發生異常，內核就會死機。真實的操作

系統通常會以更有趣的方式做出反應。

例如，許多內核使用頁面錯誤來實現寫時複製（COW）分叉。為了解釋寫時複製fork，考慮xv 6的fork，在第3章中描述。fork使子對象的初始內存內容與父對象的相同。Xv 6實現了fork withuvmcopy（kernel/vm.c：313），它為子進程分配物理內存，並將父進程的內存複製到其中。如果子進程和父進程可以共享父進程的物理內存，那麼效率會更高。然而，這種直接的實現是行不通的，因為它會導致父節點和子節點通過對共享堆棧和堆的寫入來中斷彼此的執行。

通過適當地使用頁表權限和頁錯誤，父級和子級可以安全地共享物理內存。如果使用的虛擬地址在頁表中沒有映射，或者有一個PTE\_Vflag被清除的映射，或者有一個其許可位（PTE\_R，PTE\_W，PTE\_X，PTE\_U）禁止正在嘗試的操作的映射，則CPU會引發頁故障異常。RISC-V區分了三種頁面錯誤：加載頁面錯誤（由加載指令引起），存儲頁面錯誤（由存儲指令引起）和指令頁面錯誤（由讀取要執行的指令引起）。causeregister表示頁面錯誤的類型，stvalregister包含無法轉換的地址。

COW fork中的基本計劃是讓父進程和子進程最初共享所有物理頁面，但每個進程都以只讀方式映射它們（清除PTE\_W標誌）。父級和子級可以從共享物理內存中讀取數據。如果其中一個寫了給定的頁面，RISC-V CPU會引發頁面錯誤異常。內核的陷阱處理程式通過分配一個新的物理內存頁面並將錯誤地址映射到的物理頁面複製到其中來做出響應。內核會更改出錯進程頁表中的相關PTE，使其指向複本並允許寫入和讀取，然後在導致出錯的指令處恢復出錯進程。由於PTE現在允許寫入，因此重新執行的指令將無故障地執行。寫時複製需要簿記來幫助決定何時可以釋放物理頁面，因為每個頁面可以被不同數量的頁面表引用，這取決於fork，頁面錯誤，exec和exit的歷史。 這種簿記允許一個重要的優化：如果一個進程發生存儲頁面錯誤，並且物理頁面只從該進程的頁面表中引用，則不需要複製。

寫時複製使fork更快，因為fork不需要複製內存。一些內存將不得不在寫入時複製，但通常情況下，大部分內存永遠不必複製。一個常見的例子是fork後接exec：fork後可能會寫一些頁面，但是子進程的exec會釋放從父進程繼承的大部分內存。寫時複製功能消除了複製內存的需要。此外，COW fork是透明的：不需要對應用程式進行任何修改即可受益。

除了COW fork之外，頁表和頁錯誤的組合還提供了許多有趣的可能性。另一個被廣泛使用的特性是所謂的惰性分配，它有兩個部分。首先，當應用程式通過調用sbrk請求更多內存時，內核會注意到大小的增加，但不會分配物理內存，也不會為新的虛擬地址範圍創建PTE。第二，當這些新地址中的一個出現頁面錯誤時，內核分配一個物理內存頁面，並將其映射到頁面表中。像COW fork一樣，內核可以對應用程式透明地實現延遲分配。

由於應用程式經常要求比實際需要更多的內存，因此延遲分配是一種優勢：內核根本不需要為應用程式從不使用的頁面做任何工作。此外，如果應用程式要求大量增加地址空間，那麼沒有惰性分配的sbrk是昂貴的：如果應用程式要求1GB的內存，內核必須分配262，144個4096位元組的頁面並將其歸零。延遲分配允許將此成本分攤到時間上。另一方面，惰性分配會導致頁面錯誤的額外開銷，這涉及到用戶/內核轉換。作業系統可以通過為每個頁面錯誤分配一批連續的頁面而不是一個頁面，並通過專門針對這種頁面錯誤的內核進入/退出代碼來減少這種成本。

另一個廣泛使用的利用頁面錯誤的特性是按需分頁。在exec中，xv 6在啟動應用程式之前將應用程式的所有文本和數據加載到內存中。由於應用程式可能很大，從磁碟閱讀需要時間，因此用戶可能會注意到這種啟動成本。為了減少啟動時間，現代內核最初不會將可執行文件加載到內存中，而只是創建所有PTE標記為無效的用戶頁表。內核啟動程式運行;每次程式第一次使用頁面時，都會發生頁面錯誤，作為響應，內核從磁碟讀取頁面內容並將其映射到用戶地址空間。與COW fork和lazy allocation一樣，內核可以對應用程式透明地實現此功能。

在計算機上運行的程式可能需要比計算機RAM更多的內存。為了妥善科普，作業系統可能會實現分頁到磁碟。其思想是在RAM中只存儲一小部分用戶頁面，其餘的存儲在磁碟的分頁區域中。內核將與存儲在分頁區域（因此不在RAM中）的內存相對應的PTE標記為無效。如果一個應用程式試圖使用其中一個已經分頁到磁碟的頁面，應用程式將引發頁面錯誤，並且頁面必須被分頁：內核陷阱處理程式將分配一個物理RAM頁面，將頁面從磁碟讀取到RAM，並修改相關的PTE以指向RAM。

如果需要調入一個頁面，但沒有可用的物理RAM，會發生什麼情況？在這種情況下，內核必須首先釋放物理頁面，方法是將其調出，將其重新分配到磁碟上的分頁區域，並將引用該物理頁面的PTE標記為無效。回收的代價很高，所以分頁在不頻繁的情況下性能最好：如果應用程式只使用其內存頁面的一個子集，並且子集的並集適合RAM。這個屬性通常被稱為具有良好的引用局部性。與許多虛擬內存技術一樣，內核通常以一種對應用程式透明的方式實現對磁碟的分頁。

不管硬體提供了多少RAM，計算機通常在很少或沒有空閒物理內存的情況下運行。例如，雲提供商在一台機器上多路復用許多客戶，以經濟高效地使用他們的硬體。作為另一示例，用戶在少量物理存儲器中在智慧型電話上運行許多應用。在這樣的設置中，分配頁面可能需要首先驅逐現有頁面。因此，當可用物理內存稀缺時，分配是昂貴的。

當空閒內存稀缺且程式僅使用分配內存的一小部分時，延遲分配和按需分頁特別有利。這些技術還可以避免在分配或加載頁面但從未使用或在可以使用之前被驅逐時浪費的工作。

聯合收割機結合分頁和缺頁異常的其他功能包括自動擴展堆棧和內存映射文件，內存映射文件是程式使用themap系統調用映射到其地址空間的文件，以便程式可以使用load and store讀取和寫入它們

指令

### 4.7 Real world

蹦床和陷阱可能看起來過於複雜。一個驅動力是RISC- V在強制陷阱時故意儘可能少地做，以允許非常快速的陷阱處理的可能性，這被證明是重要的。因此，內核陷阱處理程式的前幾條指令必須在用戶環境中執行：用戶頁表和用戶寄存器內容。陷阱處理程式最初不知道一些有用的信息，比如正在運行的進程的標識或內核頁表的地址。一個解決方案是可能的，因為RISC-V提供了受保護的地方，內核可以在進入用戶空間之前將信息隱藏在這些地方：內存寄存器，以及指向內核內存但由於缺少PTE\_U而受到保護的用戶頁表條目。Xv 6的trampoline和trapframe利用了這些RISC-V特性。

如果內核內存被映射到每個進程的用戶頁表（使用PTE\_Uclear），那麼就不需要特殊的蹦床頁。這也將消除從用戶空間捕獲到內核時對頁表切換的需要。這反過來將允許內核中的系統調用實現利用當前進程的用戶內存被映射，允許內核代碼直接解引用用戶指針。許多作業系統都使用這些想法來提高效率。Xv6避免了它們，以減少由於無意中使用用戶指針而導致內核中出現安全漏洞的可能性，並減少確保用戶和內核虛擬地址不重疊所需的複雜性。生產作業系統實現了寫時複製分叉、惰性分配、請求分頁、分頁到磁碟、內存映射文件等。 此外，生產作業系統嘗試在物理內存的所有區域中存儲有用的內容，通常將文件內容緩存在進程不使用的內存中。生產作業系統還為應用程式提供系統調用來管理它們的地址空間，並通過themmap、munmap和sigactionsystem調用來實現它們自己的頁面錯誤處理，以及提供將內存固定到RAM（鎖定）的調用和通知內核應用程式計劃如何使用其內存（建議）的調用。

### 4.8 Exercises

1. 函數copyin和copyinstrwalk軟體中的用戶頁表。設置內核頁表，使內核映射用戶程式，copyin和copywriter可以使用emcpy將系統調用參數複製到內核空間，依靠硬體執行頁表遍歷。
2. 實現惰性內存分配。
3. 執行COW叉。
4. 有沒有一種方法可以消除每個用戶地址空間中的特殊TRAPFRAMEpage映射？例如，是否可以修改uservec以將32個用戶寄存器簡單地推到內核堆棧上，或者將它們存儲在proc結構中？
5. 可以修改xv6來消除特殊的TRAMPOLINEPage映射嗎？
6. Implementmmap.

第5章
===

中斷和設備驅動程式
=========

Adriver是作業系統中管理特定設備的代碼：它配置設備硬體，告訴設備執行操作，處理由此產生的中斷，並與可能等待設備I/O的進程交互。驅動程式代碼可能很複雜，因為驅動程式與它管理的設備同時執行。此外，驅動程式必須了解設備的硬體接口，這些接口可能很複雜，而且文檔記錄得很差。需要作業系統注意的設備通常可以配置為生成中斷，這是一種類型的陷阱。內核陷阱處理代碼識別設備何時引發中斷並調用驅動程式的中斷處理程式;在xv 6中，這種分派發生在devintr（kernel/trap.c：185）中。許多設備驅動程式在兩個上下文中執行代碼：上半部分在進程的內核線程中運行，下半部分在中斷時執行。 上半部分是通過系統調用來調用的，比如讀和寫，它們希望設備執行I/O。該代碼可以要求硬體開始操作（例如，請求磁碟讀取一個塊）;然後代碼等待操作完成。最後，設備完成操作並引發中斷。驅動程式的中斷處理程式，作為下半部分，找出什麼操作已經完成，如果合適的話喚醒一個等待的進程，並告訴硬體開始任何等待的下一個操作。

### 5.1 Code: Console input

控制台驅動程式（kernel/console.c）是驅動程式結構的簡單說明。控制台驅動程式通過連接到RISC-V的UART串行埠硬體接受人類輸入的字符。控制台驅動程式每次累積一行輸入，處理特殊輸入字符，如退格鍵和control-u。用戶進程（如shell）使用threadsystem調用從控制台獲取輸入行。當您在QEMU中向xv 6鍵入輸入時，您的腳本將通過QEMU的模擬腳本硬體傳遞到xv 6。驅動程式與之對話的CPU硬體是QEMU仿真的16550晶片\[13\]。在真實的計算機上，16550將管理連接到終端或其他計算機的RS232串行鏈路。當運行QEMU時，它連接到您的鍵盤和顯示器。在軟體看來，可編程邏輯器件的硬體是一組內存映射的控制寄存器。的

存在一些RISC-V硬體連接到RAM設備的物理地址，因此加載和存儲與設備硬體而不是RAM交互。內存映射地址從0x 10000000或UART 0（kernel/memlayout.h：21）開始。有幾個可編程控制寄存器，每個都是一個字節的寬度。它們相對於UART 0的偏移量在（kernel/uart.c：22）中定義。例如，LSR寄存器包含指示輸入字符是否等待軟體讀取的位。這些字符（如果有）可從RHR寄存器中閱讀。每次讀取一個字符時，EEPROM硬體將其從等待字符的內部FIFO中刪除，並在FIFO為空時清除LSR中的「就緒」位。UART的發送硬體在很大程度上獨立於接收硬體;如果軟體向THR寫入一個字節，UART將發送該字節。Xv 6的maincallsconsoleinit（kernel/console.c：182）初始化Linux硬體。 這段代碼配置了當UART接收到每個字節的輸入時生成一個接收中斷，並在每次UART完成發送一個字節的輸出時生成一個transsmit complete中斷（kernel/uart.c：53）。xv 6 shell通過init.c（user/init.c：19）打開的文件描述符從控制台讀取。對threadsystem調用的調用通過內核到達consoleread（kernel/con- sole.c：80）。consoleread等待輸入到達（通過中斷）並在cons.buf中緩衝，將輸入複製到用戶空間，並（在一整行到達後）返回到用戶進程。如果用戶還沒有輸入一整行，任何閱讀進程將在sleep調用（kernel/con- sole.c：96）中等待（第7章解釋sleep的細節）。當用戶輸入一個字符時，CPU硬體要求RISC-V產生一個中斷，這將激活xv 6的陷阱處理程式。陷阱處理程式調用sdevintr（kernel/trap.c：185），它查看RISC-Vscauseregister，以發現中斷來自外部設備。然後，它要求一個名為PLIC的硬體單元\[3\]告訴它哪個設備中斷了（kernel/trap. c：193）。如果這是一個錯誤，devintrcallsuartintr。uartintr（kernel/uart. c：177）從CPU硬體讀取任何等待的輸入字符，並將它們交給consoleintr（kernel/console.c：136）;它不等待字符，因為未來的輸入將引發新的中斷。consoleintrs的工作是累積輸入字符，直到一整行到達。consoleintrs專門處理退格鍵和其他一些字符。當一個新行到達時，consoleinr喚醒一個等待的consoleread（如果有的話）。一旦被喚醒，consoleread將觀察cons.buf中的一整行，將其複製到用戶空間，並返回（通過系統調用機制）到用戶空間。

### 5.2代碼：控制台輸出

對連接到控制台的文件描述符的writesystem調用最終到達atuartputc（kernel/uart.c：87）。設備驅動程式維護一個輸出緩衝區（uart\_tx\_buf），這樣寫進程就不必等待UART完成發送;相反，uartputcappend每個字符到緩衝區，callsuartstart啟動設備傳輸（如果還沒有），然後返回。chuartputc等待的唯一情況是緩衝區已經滿了。每次發送完一個字節，它都會產生一個中斷。uartintrcallsuartstart，

其檢查設備是否確實已經完成發送，並將下一個緩衝輸出字符交給設備。因此，如果進程將多個字節寫入控制台，通常第一個字節將由uartputc的調用touartstart發送，其餘緩衝字節將由uartstart調用發送，來自muartintras傳輸完整中斷到達。需要注意的一個通用模式是通過緩衝和中斷將設備活動與進程活動解耦。即使沒有進程等待讀取輸入，控制台驅動程式也可以處理輸入;隨後的讀取將看到輸入。類似地，進程可以發送輸出而不必等待設備。這種解耦可以通過允許進程與設備I/O同時執行來提高性能，並且當設備很慢（如使用UART）或需要立即注意（如使用回顯鍵入的字符）時特別重要。這個想法有時被稱為I/O並發性。

### 5.3驅動程式中的並發

你可能已經注意到了獲取控制台讀取和inconsoleintr的調用。這些調用獲取一個鎖，該鎖保護控制台驅動程式的數據結構免受並發訪問。這裡有三種並發危險：不同CPU上的兩個進程可能同時調用consoleread;硬體可能要求CPU在已經執行insidecoleread時傳遞控制台（實際上是中斷）中斷;硬體可能在不同CPU上傳遞控制台中斷，而consoleread正在執行。第6章解釋了如何使用鎖來確保這些危險不會導致錯誤的結果。另一種並發性需要注意的方式是，一個進程可能正在等待來自設備的輸入，但是當另一個進程（或者根本沒有進程）正在運行時，輸入的中斷信號可能會到達。因此，不允許中斷處理程式考慮它們中斷的進程或代碼。 例如，中斷處理程式不能安全地調用當前進程的頁表的copyout。緩存處理器通常做相對少的工作（例如，只需將輸入數據複製到緩衝區），並喚醒上半部分代碼來完成其餘工作。

### 5.4 Timer interrupts

Xv 6使用定時器中斷來保持當前時間的概念，並在計算限制的進程之間切換。定時器中斷來自每個RISC-V CPU的時鐘硬體。Xv 6對每個CPU的時鐘硬體進行編程，以周期性地中斷CPU。代碼instart.c（kernel/start.c：53）設置一些控制位，允許管理程式模式訪問定時器控制寄存器，然後請求第一個定時器中斷。時間控制寄存器包含硬體以穩定速率遞增的計數;這是當前時間的概念。stimecmpregister包含CPU將引發定時器中斷的時間;將stimecmp設置為timeplusx的當前值將在未來安排x個時間單位的中斷。Forqemu的RISC-V仿真，1000000時間單位大約是十分之一秒。定時器中斷通過其他設備中斷到達。定時器中斷到達時，cause的低位設置為5;devintrintrap. c檢測到

這種情況下，調用sclockintr（kernel/trap.c：164）。後者的函數incrementsticks允許內核跟蹤時間的流逝.增量僅在一個CPU上發生，以避免在有多個CPU的情況下時間過得更快。clockintr喚醒在休眠系統調用中等待的任何進程，並通過寫入stimecmp來調度下一個計時器中斷。

devintrends返回2用於定時器中斷，以指示它們應該調用的tokerneltraporusertrap，以便CPU可以在可運行的進程之間多路復用。

內核代碼可能會被一個定時器中斷，該中斷會通過yield強制上下文切換，這也是為什麼usertrap中的早期代碼在啟用中斷之前要小心保存assepc等狀態的部分原因。這些上下文切換也意味著編寫內核代碼時必須知道它可能會在沒有警告的情況下從一個CPU移動到另一個CPU。

### 5.5 Real world

像許多作業系統一樣，xv 6在內核中執行時允許中斷甚至上下文切換（viayield）。這樣做的原因是為了在長時間運行的複雜系統調用期間保持快速響應時間。然而，如上所述，在內核中允許中斷是一些複雜性的來源;因此，一些作業系統只在執行用戶代碼時才允許中斷。在一台典型的計算機上完全支持所有設備是一項艱巨的工作，因為有很多設備，這些設備有很多功能，設備和驅動程式之間的協議可能很複雜，而且記錄得很差。在許多作業系統中，驅動程式比核心內核占更多的代碼。

UART驅動程式通過閱讀UART控制寄存器，每次檢索一個字節的數據;這種模式稱為編程I/O，因為軟體驅動數據移動。編程的I/O很簡單，但速度太慢，無法用於高數據速率。需要高速移動大量數據的設備通常使用直接內存訪問（DMA）。DMA設備硬體直接將傳入數據寫入RAM，並從RAM讀取傳出數據。現代磁碟和網絡設備使用DMA。DMA設備的驅動程式將在RAM中準備數據，然後使用對控制寄存器的單次寫入來告訴設備處理準備好的數據。

當設備在不可預測的時間需要注意時，中斷是有意義的，而且不是太頻繁。但是中斷有很高的CPU開銷。因此，高速設備，如網絡和磁碟控制器，使用技巧，減少中斷的需要。一個技巧是為整批傳入或傳出請求引發單箇中斷。另一個技巧是讓驅動程式完全禁用中斷，並定期檢查設備，看看它是否需要注意。這種技術稱為輪詢。如果設備以高速率執行操作，則輪詢是有意義的，但如果設備大部分時間處於空閒狀態，則會浪費CPU時間。一些驅動程式根據當前設備負載在輪詢和中斷之間動態切換。

MySQL驅動程式首先將傳入的數據複製到內核中的緩衝區，然後複製到用戶空間。這在低數據速率下是有意義的，但對於快速生成或使用數據的設備來說，這種雙重拷貝會顯著降低性能。一些作業系統能夠直接在用戶空間緩衝區和設備硬體之間移動數據，通常使用DMA。

如第1章所述，控制台對應用程式來說是一個常規文件，應用程式使用threadandwritesystem調用讀取輸入和寫入輸出。應用可能想要控制不能通過標準文件系統調用表達的設備的方面（例如，在控制台驅動程式中啟用/禁用行緩衝）。Unix作業系統支持這種情況下的ioctl系統調用。計算機的某些用途要求系統必須在有限的時間內作出響應。例如，在安全關鍵系統中，錯過最後期限可能導致災難。Xv 6不適合硬實時設置。用於硬實時的作業系統往往是與應用程式連結的庫，其連結方式允許進行分析以確定最壞情況下的響應時間。 Xv6也不適合軟實時應用程式，偶爾錯過一個截止日期是可以接受的，因為xv6的調度程式過於簡單，它的內核代碼路徑中斷被禁用了很長一段時間。

### 5.6 Exercises

1. 修改yuart.c以完全不使用中斷。您可能需要修改console.cas well。
2. 為乙太網卡添加驅動程式。

第6章
===

Locking
=======

大多數內核，包括xv 6，都是交錯執行多個活動的。交錯的一個來源是多處理器硬體：具有多個獨立執行的CPU的計算機，例如xv 6的RISC-V。這些多個CPU共享物理RAM，並且xv 6利用共享來維護所有CPU讀取和寫入的數據結構。這種共享增加了一個CPU閱讀數據結構而另一個CPU正在更新它的可能性，甚至多個CPU同時更新相同的數據;如果沒有仔細設計，這種並行訪問可能會產生錯誤的結果或損壞的數據結構。即使在單處理器上，內核也可以在多個線程之間切換CPU，從而導致它們的執行是交錯的。最後，如果中斷發生在錯誤的時間，則修改與某些可中斷代碼相同的數據的設備中斷處理程式可能會損壞數據。 並發這個詞指的是多個指令流由於多處理器並行、線程切換或中斷而交錯的情況。

內核充滿了並發訪問的數據。例如，兩個CPU可以同時調用kalloc，從而同時從空閒列表的頭部彈出。內核設計者喜歡允許大量的並發，因為它可以通過並行性提高性能，並提高響應能力。然而，結果是內核設計者必須說服自己儘管有這樣的並發性也是正確的。有很多方法可以得到正確的代碼，有些方法比其他方法更容易推理。在並發情況下，針對正確性的策略，以及支持它們的抽象，被稱為並發控制技術.

Xv 6使用了許多並發控制技術，這取決於具體情況;可能還有更多。本章重點居間一種廣泛使用的技術：鎖。鎖提供互斥，確保一次只有一個CPU可以持有鎖。如果程式設計師將鎖與每個共享數據項關聯，並且代碼在使用項時始終持有關聯的鎖，則該項將一次僅由一個CPU使用。在這種情況下，我們說鎖保護數據項。儘管鎖是一種易於理解的並發控制機制，但鎖的缺點是它們可能會限制性能，因為它們會串行化並發操作。

本章的其餘部分將解釋為什麼xv 6需要鎖，xv 6如何實現它們，以及如何使用它們。

CPU CPU

l->next = list l->next = list


list


Memory

BUS


Figure 6.1: Simplified SMP architecture


### 6.1 Races

作為我們為什麼需要鎖的一個例子，考慮兩個進程，它們的子進程在兩個不同的CPU上調用wait。wait釋放子進程的內存。因此，在每個CPU上，內核將調用kfree來釋放子內存頁。內核分配器維護一個連結列表：kalloc（）（ker- nel/kalloc.c：69）從空閒頁面列表中彈出一個內存頁面，並且kfree（）（kernel/kalloc.c：47）將一個頁面推送到空閒列表中。為了獲得最佳性能，我們可能希望兩個父進程的kfrees並行執行，而不必等待另一個進程，但考慮到xv 6的skfree實現，這是不正確的。

圖6.1更詳細地說明了該設置：空閒頁面的鍊表位於兩個CPU共享的內存中，CPU使用加載和存儲指令來操作該列表。(In實際上，處理器有高速緩存，但從概念上講，多處理器系統的行為就像有一個單一的共享內存。如果沒有並發請求，你可以實現一個列表推送操作，如下所示：

1 struct element {
2 int data;
3 struct element *next;
4 };
5
6 struct element *list = 0;
7
8 void
9 push(int data)
10 {
11 struct element *l;
12
13 l = malloc(sizeof *l);
14 l->data = data;
15 l->next = list;
16 list = l;


Memory


CPU 1


CPU2
15


l->next


16


list


15 16


l->next list


Time


Figure 6.2: Example race


17 }


如果單獨執行，此實現是正確的。但是，如果多個複本並發執行，則代碼不正確。如果兩個CPU同時執行push，則兩個CPU都可能在執行第16行之前執行第15行，如圖6.1所示，這會導致錯誤的結果，如圖6.2所示。然後會有兩個list元素，其中nextset被設置為之前的list值。當這兩個賦值語句出現在第16行時，第二個賦值語句將覆蓋第一個賦值語句;第一個賦值語句中的元素將丟失。第16行丟失的更新就是arace的一個例子。競爭是一種同時訪問內存位置的情況，並且至少有一次訪問是寫入。競爭通常是bug的標誌，要麼是丟失更新（如果訪問是寫），要麼是讀取未完全更新的數據結構。 競爭的結果取決於編譯器生成的機器碼、所涉及的兩個CPU的時序以及它們的內存操作如何由內存系統排序，這可能使競爭引起的錯誤難以再現和調試。例如，在調試push時添加print語句可能會改變執行的時間，從而消除爭用。避免爭用的常用方法是使用鎖。鎖確保了互斥，這樣每次只有一個CPU可以執行push的敏感行;這使得上面的場景不可能發生。 上述代碼的正確鎖定版本只添加了幾行（以黃色突出顯示）：

6 struct element *list = 0;
7 struct lock listlock;
8
9 void
10 push(int data)
11 {
12 struct element *l;
13 l = malloc(sizeof *l);
14 l->data = data;


15
16 acquire(&listlock);
17 l->next = list;
18 list = l;
19 release(&listlock);
20 }


在獲取和釋放之間的指令序列通常被稱為關鍵段。鎖通常被稱為protectinglist。

當我們說鎖保護數據時，我們實際上是指鎖保護應用於數據的一些不變量的集合。不變量是跨操作維護的數據結構的屬性。通常，操作的正確行為取決於操作開始時不變量是否為真。該操作可能會暫時違反不變量，但必須在完成之前重新建立它們。例如，在鍊表的情況下，不變式是list指向列表中的第一個元素，每個元素的下一個欄位指向下一個元素。push的實現暫時違反了這個不變量：在第17行，l指向下一個list元素，但list不指向atlyet（在第18行重新建立）。我們上面研究的競爭之所以發生，是因為第二個CPU執行了依賴於列表不變量的代碼，而列表不變量（暫時）被違反了。 正確使用鎖可以確保每次只有一個CPU可以對臨界區中的數據結構進行操作，因此當數據結構的不變量不成立時，沒有CPU會執行數據結構操作。

您可以將鎖看作是串行化並發臨界區，以便它們每次運行一個，從而保留不變量（假設臨界區在隔離狀態下是正確的）。您也可以將由同一個鎖保護的臨界區視為彼此之間的原子，這樣每個臨界區只能看到來自早期臨界區的完整更改集，而不會看到部分完成的更新。

雖然鎖對正確性很有用，但它本身會限制性能。例如，如果兩個進程同時調用kfree，鎖將序列化兩個關鍵部分，因此在不同的CPU上運行它們沒有任何好處。如果多個進程同時想要相同的鎖，或者鎖遇到爭用，我們就說它們發生衝突。內核設計中的一個主要挑戰是在追求並行性的同時避免鎖爭用。Xv6幾乎不這樣做，但是複雜的內核專門組織數據結構和算法來避免鎖爭用。在列表示例中，內核可以為每個CPU維護單獨的空閒列表，並且僅在當前CPU的列表為空並且必須從另一個CPU竊取內存時才觸及另一個CPU的空閒列表。其他用例可能需要更複雜的設計。

鎖的位置對性能也很重要。例如，在push中將acquireearlier移動到第13行之前是正確的。但這可能會降低性能，因為這樣對malloc的調用就會被序列化。下面的「使用鎖」一節提供了在何處插入、獲取和釋放調用的一些指導。

### 6.2 Code: Locks

Xv 6有兩種類型的鎖：自旋鎖和睡眠鎖。我們從自旋鎖開始。Xv 6將自旋鎖表示為astruct自旋鎖（kernel/spinlock.h：2）。結構中的重要欄位是locked，這個字在鎖可用時為零，在持有鎖時為非零。從邏輯上講，xv 6應該通過執行以下代碼來獲取鎖：

21 void
22 acquire(struct spinlock *lk) // does not work!
23 {
24 for(;;) {
25 if(lk->locked == 0) {
26 lk->locked = 1;
27 break;
28 }
29 }
30 }


不幸的是，這種實現不能保證多處理器上的互斥。可能發生的情況是，兩個CPU同時到達第25行，看到lk->locked為零，然後都通過執行第26行來獲取鎖。此時，兩個不同的CPU持有鎖，這違反了互斥屬性。我們需要的是一種方法，使第25和26行執行解剖（即，不可分割的）步驟。

由於鎖被廣泛使用，多核處理器通常提供實現第25和26行的原子版本的指令。在RISC-V上，此指令是amoswap r，a。amos將讀取內存地址a處的值，將register的內容寫入該地址，並將其讀取的值放入tor。也就是說，它交換寄存器的內容和內存地址。它原子地執行這個序列，使用特殊的硬體來防止任何其他CPU在讀和寫之間使用內存地址。

Xv 6的acquire（kernel/spinlock.c：22）使用可移植的C庫調用\_\_sync\_lock\_test\_and\_set，它歸結為amosap指令;返回值是lk->locked的舊（交換）內容。acquire函數將交換包包裝在一個循環中，重試（旋轉）直到它獲得鎖。每次疊代交換一個intolk->locked並檢查前一個值;如果前一個值為零，那麼我們已經獲得了鎖，並且交換將setlk->locked設置為1。如果前一個值是1，那麼其他CPU持有鎖，並且我們原子地交換了一個intolk->locked並沒有改變它的值。

一旦獲取了鎖，就獲取記錄獲取鎖的CPU，以便進行調試。Thelk->cpufield受鎖保護，只能在持有鎖時進行更改。

函數release（kernel/spinlock.c：47）與獲取相反：它清除clk->cpu欄位，然後釋放鎖。從概念上講，該版本只需要分配零tolk->locked。C標準允許編譯器用多個存儲指令實現賦值，因此C賦值對於並發代碼來說可能是非原子的。相反，release使用C庫函數\_\_sync\_lock\_release來執行原子賦值。這個函數也可以歸結為RISC-Vamoswap指令。

### 6.3 Code: Using locks

Xv 6在許多地方使用鎖來避免競爭。如上所述，kalloc（kernel/kalloc.c：69）和kfree（kernel/kalloc.c：47）形成了一個很好的例子。嘗試練習1和練習2，看看如果這些函數忽略鎖會發生什麼。您可能會發現很難觸發不正確的行為，這表明很難可靠地測試代碼是否沒有鎖定錯誤和競爭。Xv 6很可能有尚未發現的種族。使用鎖的一個困難部分是決定使用多少鎖以及每個鎖應該保護哪些數據和不變量。有幾個基本原則。首先，任何時候一個CPU可以寫一個變量，而另一個CPU可以讀或寫它，都應該使用鎖來防止兩個操作重疊。其次，記住鎖保護不變量：如果一個不變量涉及多個內存位置，通常所有這些位置都需要由一個鎖保護，以確保不變量得到維護。 上面的規則說明了什麼時候鎖是必要的，但沒有說明什麼時候鎖是不必要的，而且對於效率來說，不要鎖定太多是很重要的，因為鎖會降低並行性。如果並行性並不重要，那麼可以只安排一個線程，而不用擔心鎖。一個簡單的內核可以在多處理器上做到這一點，它有一個鎖，必須在進入內核時獲取，並在退出內核時釋放（儘管阻塞系統調用，如管道讀取或等待會造成問題）。許多單處理器作業系統已經使用這種方法轉換為在多處理器上運行，有時稱為「大內核鎖」，但這種方法犧牲了並行性：一次只能在內核中執行一個CPU。如果內核執行任何繁重的計算，那麼使用更大的更細粒度的鎖集合會更有效，這樣內核就可以同時在多個CPU上執行。作為粗粒度鎖定的一個例子，xv6的skalloc。調用器具有由單個鎖保護的單個空閒列表。如果不同CPU上的多個進程試圖同時分配頁面，則每個進程都必須通過在獲取中旋轉來等待輪到自己。旋轉浪費CPU時間，因為它不是有用的工作。如果鎖的爭用浪費了大量的CPU時間，也許可以通過改變分配器的設計來提高性能，使其具有多個空閒列表，每個列表都有自己的鎖，從而允許真正的並行分配。作為細粒度鎖定的一個例子，xv6為每個文件都有一個單獨的鎖，因此操作不同文件的進程通常可以繼續進行，而無需等待彼此的鎖。如果希望允許進程同時寫入同一文件的不同區域，則可以使文件鎖定方案更加細粒度。最終，鎖粒度決策需要由性能度量和複雜性考慮驅動。 在隨後的章節解釋xv6的每一部分時，他們將提到xv6使用鎖來處理並發的例子。作為預覽，圖6.3列出了xv6中的所有鎖。

### 6.4 Deadlock and lock ordering

如果通過內核的代碼路徑必須同時持有多個鎖，那麼所有代碼路徑都以相同的順序獲取這些鎖是很重要的。如果他們不這樣做，就有可能陷入僵局。假設xv6中的兩個代碼路徑需要鎖A和B，但是代碼路徑1按照順序A獲取鎖，

Lock Description
bcache.lock Protects allocation of block buffer cache entries
cons.lock Serializes access to console hardware, avoids intermixed output
ftable.lock Serializes allocation of a struct file in file table
itable.lock Protects allocation of in-memory inode entries
vdisk_lock Serializes access to disk hardware and queue of DMA descriptors
kmem.lock Serializes allocation of memory
log.lock Serializes operations on the transaction log
pipe’s pi->lock Serializes operations on each pipe
pid_lock Serializes increments of next_pid
proc’s p->lock Serializes changes to process’s state
wait_lock Helps wait avoid lost wakeups
tickslock Serializes operations on the ticks counter
inode’s ip->lock Serializes operations on each inode and its content
buf’s b->lock Serializes operations on each block buffer


Figure 6.3: Locks in xv6


B，而另一條路徑以B然後A的順序獲取它們。假設線程T1執行代碼路徑1並獲得鎖A，線程T2執行代碼路徑2並獲得鎖B。接下來，T1將嘗試獲取鎖B，T2將嘗試獲取鎖A。這兩個獲取都將無限期地阻塞，因為在這兩種情況下，另一個線程持有所需的鎖，並且在其獲取返回之前不會釋放它。若要避免此類死鎖，所有代碼路徑必須以相同的順序獲取鎖。對全局鎖獲取順序的需求意味著鎖實際上是每個函數規範的一部分：調用者必須以一種方式調用函數，以使鎖以商定的順序被獲取。

Xv 6有許多長度為2的鎖序鏈，由於sleep的工作方式（參見第7章），這些鎖序鏈涉及每個進程的鎖（每個結構體proc中的鎖）。例如，consoleintr（kernel/console.c：136）是處理鍵入字符的中斷例程。當出現一個新行時，任何等待控制台輸入的進程都應該被喚醒。為此，consoleintr在調用wakeup時保持cons. lock，這將獲取等待進程的鎖以將其喚醒。因此，全局避免死鎖的鎖順序包括必須在任何進程鎖之前獲得cons.lock的規則。文件系統代碼包含了xv 6最長的鎖鏈。例如，創建一個文件需要同時持有目錄上的鎖、新文件的inode上的鎖、磁碟塊緩衝區上的鎖、磁碟驅動程式的svdisk\_lock和調用進程的sp->lock。為了避免死鎖，文件系統代碼總是按照前一句中提到的順序獲取鎖。

遵守一個避免全球僵局的秩序可能會令人驚訝地困難。有時鎖順序與邏輯程式結構衝突，例如，也許代碼模塊M1調用模塊M2，但鎖順序要求在M1中的鎖之前獲取M2中的鎖。有時鎖的標識事先並不知道，可能是因為必須持有一個鎖才能發現下一個要獲取的鎖的標識。這種情況出現在文件系統中，因為它在路徑名中查找連續的組件，並且在forwaitandexitas代碼中搜索表

尋找子進程。最後，死鎖的危險通常是對如何細粒度地實現鎖定方案的限制，因為更多的鎖通常意味著更多的死鎖機會。避免死鎖的需要通常是內核實現中的一個主要因素。

### 6.5 Re-entrant locks

通過使用可重入鎖（也稱為遞歸鎖），似乎可以避免某些死鎖和鎖排序問題。這個想法是，如果鎖由一個進程持有，並且如果該進程試圖再次獲取鎖，那麼內核可以允許這樣做（因為該進程已經擁有鎖），而不是像xv6內核那樣調用panic。然而，事實證明，可重入鎖使並發性變得更加困難：可重入鎖打破了鎖導致臨界區相對於其他臨界區是原子的直覺。考慮下面的函數fandg和一個假設函數h：

struct spinlock lock;
int data = 0; // protected by lock


f() {
acquire(&lock);
if(data == 0){
call_once();
h();
data = 1;
}
release(&lock);
}


g() {
aquire(&lock);
if(data == 0){
call_once();
data = 1;
}
release(&lock);
}


public void run（）{ }看一下這個代碼片段，直覺告訴我們call\_once只會被調用一次：要麼被byf調用，要麼被byg調用，但不會同時被兩者調用。但是如果允許重入鎖，並且碰巧調用了g，則call\_once將被調用兩次。如果不允許重入鎖，那麼調用會導致死鎖，這也不是什麼好事。但是，假設callcall\_once是一個嚴重的錯誤，那麼最好是死鎖。的

內核開發人員將觀察到死鎖（內核死機），並可以修復代碼以避免它，而調用call\_oncetwice可能會導致難以跟蹤的錯誤。出於這個原因，xv6使用更容易理解的不可重入鎖。然而，只要程式設計師牢記鎖定規則，這兩種方法都可以工作。如果xv6要使用可重入鎖，則必須修改acquire以注意鎖當前由調用線程持有。我們還必須以類似的風格topush\_off向結構體spinlock添加嵌套獲取的計數，這將在下面討論。

### 6.6 Locks and interrupt handlers

一些xv 6自旋鎖保護線程和中斷處理程式都使用的數據。例如，時鐘定時器中斷處理程式可能在內核線程讀取sticksinsys\_sleep（kernel/sysproc.c：61）的同時增加ticks（kernel/trap.c：164）。locktickslock序列化這兩個訪問。自旋鎖和中斷的相互作用會帶來潛在的危險。假設ys\_sleepholds tickslock，並且它的CPU被定時器中斷中斷。clockintr將嘗試獲取tickslock，查看它是否被保持，並等待它被釋放。在這種情況下，tickslock將永遠不會被釋放：只有sys\_sleep可以釋放它，但是sys\_sleep將不會繼續運行，直到clockintr返回。因此CPU將死鎖，任何需要鎖的代碼也將凍結。為了避免這種情況，如果中斷處理程式使用了自旋鎖，CPU必須在啟用中斷的情況下保持該鎖。Xv 6更保守：當CPU獲得任何鎖時，Xv 6總是禁用該CPU上的中斷。 中斷仍然可能發生在其他CPU上，因此中斷的獲取可以等待線程釋放自旋鎖;只是不在同一CPU上。當CPU沒有自旋鎖時，Xv 6重新啟用中斷;它必須做一些簿記來科普嵌套的臨界區。獲取調用spush\_off（kernel/spinlock.c：89）和釋放調用spop\_off（kernel/spinlock.c：100）來跟蹤當前CPU上的鎖的嵌套級別。當該計數器達到零時，pop\_off恢復最外層臨界區開始時的中斷使能狀態。intr\_offandintr\_on函數執行RISC-V指令，分別禁用和啟用中斷。在設置lk->locked（kernel/spin-lock.c：28）之前嚴格獲取調用push\_off是很重要的。如果兩者顛倒，則在啟用中斷的情況下鎖被持有時會有一個短暫的窗口，並且不幸的定時中斷會使系統死鎖。 同樣，只有在釋放鎖之後才釋放pop\_off也很重要（kernel/spinlock.c：66）。

### 6.7指令和存儲器排序

我們很自然地會認為程式是按照原始碼語句出現的順序執行的。對於單線程代碼來說，這是一個合理的心理模型，但當多線程通過共享內存進行交互時，這是不正確的\[2，4\]。一個原因是編譯器發出的加載和存儲指令的順序與原始碼所暗示的順序不同，並且可能完全忽略它們（例如通過將數據緩存在寄存器中）。另一個原因是CPU可能會亂序執行指令

以提高性能。例如，CPU可以注意到在指令A和B的串行序列中彼此不依賴。CPU可以首先啟動指令B，因為它的輸入在A的輸入之前準備好，或者為了重疊A和B的執行。舉一個可能出錯的例子，在下面的代碼forpush中，如果編譯器或CPU將對應於第4行的存儲移動到第6行之後的一個點，那將是一場災難：

1 l = malloc(sizeof *l);
2 l->data = data;
3 acquire(&listlock);
4 l->next = list;
5 list = l;
6 release(&listlock);


如果發生這種重新排序，則會有一個窗口，在此期間另一個CPU可以獲取鎖並觀察updatedlist，但會看到未初始化的list->next。好消息是，編譯器和CPU通過遵循一組稱為存儲器模型的規則來幫助並發程式設計師，並通過提供一些原語來幫助程式設計師控制重新排序。為了告訴硬體和編譯器不要重新排序，xv 6在獲取（kernel/spinlock.c：22）和釋放（kernel/spinlock.c：47）中都使用了\_\_sync\_synchronize（）。sync\_synchronize（）是一個內存屏障：它告訴編譯器和CPU不要重新排序跨越屏障的加載或存儲。xv 6的獲取和釋放中的障礙在幾乎所有重要的情況下都強制執行順序，因為xv 6在訪問共享數據時使用鎖。第9章討論了一些例外情況。

### 6.8 Sleep locks

有時xv 6需要長時間持有鎖。例如，文件系統（第8章）在磁碟上閱讀和寫文件內容時保持文件鎖定，這些磁碟操作可能需要幾十毫秒。如果另一個進程想要獲取旋轉鎖，那麼持有如此長時間的旋轉鎖將導致浪費，因為獲取進程在旋轉時會長時間浪費CPU。自旋鎖的另一個缺點是，一個進程不能在保留自旋鎖的同時讓出CPU;我們希望這樣做，以便其他進程可以在有鎖的進程等待磁碟時使用CPU。在持有自旋鎖的同時產生是非法的，因為如果第二個線程試圖獲取自旋鎖，它可能會導致死鎖;由於獲取不會產生CPU，第二個線程的自旋可能會阻止第一個線程運行並釋放鎖。在持有鎖的同時屈服也會違反在持有自旋鎖的同時中斷必須關閉的要求。 因此，我們想要一種鎖，它在等待獲取時產生CPU，並在持有鎖時允許產生（和中斷）。Xv 6以sleep-locks的形式提供了這樣的鎖。acquiressource（kernel/sleeplock.c：22）在等待的時候產生CPU，使用的技術將在第7章中解釋。在高級別上，一個sleep-lock有一個被自旋鎖保護的鎖定欄位，而獲取線程對sleep的調用原子地產生CPU並釋放自旋鎖。其結果是，其他線程可以執行，而acquiresleep等待。

由於休眠鎖使中斷處於啟用狀態，因此不能在中斷處理程式中使用。因為獲取休眠可能會占用CPU，所以不能在自旋鎖臨界區中使用休眠鎖（儘管自旋鎖可以在休眠鎖臨界區中使用）。自旋鎖最適合於短的關鍵部分，因為等待它們會浪費CPU時間;睡眠鎖適用於長時間操作。

### 6.9 Real world

儘管對並發原語和並行性進行了多年的研究，但使用鎖進行編程仍然具有挑戰性。通常最好在高級結構（如同步隊列）中隱藏鎖，儘管xv6沒有這樣做。如果您使用鎖編程，那麼明智的做法是使用一個試圖識別種族的工具，因為很容易錯過需要鎖的不變式。大多數作業系統支持POSIX線程（Pthreads），它允許用戶進程在不同的CPU上同時運行多個線程。Pthreads支持用戶級別的鎖，屏障等。Pthreads還允許程式設計師選擇性地指定鎖應該是可重入的。在用戶級支持Pthreads需要作業系統的支持。例如，如果一個pthread在系統調用中阻塞，同一進程的另一個pthread應該能夠在該CPU上運行。作為另一個示例，如果pthread改變其進程的地址空間（例如，映射或取消映射內存），內核必須安排運行同一進程的線程的其他CPU更新它們的硬體頁表，以反映地址空間的變化。不使用原子指令也可以實現鎖\[10\]，但代價很高，而且大多數作業系統都使用原子指令。如果多個CPU試圖同時獲取同一個鎖，那麼鎖的開銷會很大。如果一個CPU在其本地高速緩存中高速緩存有鎖，並且另一個CPU必須獲取該鎖，則更新持有該鎖的該高速緩存行的原子指令必須將該行從一個CPU的高速緩存移動到另一個CPU的高速緩存，並且可能使該該高速緩存行的任何其他複本無效。從另一個CPU的緩存中獲取緩存行的開銷可能比從本地緩存中獲取緩存行的開銷高出幾個數量級。為了避免與鎖相關的開銷，許多作業系統使用無鎖數據結構和算法\[6，12\]。 例如，可以實現一個類似於本章開頭的鍊表，它在列表搜索期間不需要鎖，只需要一個原子指令就可以在列表中插入一個項。然而，無鎖編程比編程鎖更複雜;例如，必須考慮指令和內存的重新排序。使用鎖編程已經很困難了，所以xv 6避免了無鎖編程的額外複雜性。

### 6.10 Exercises

1. 注釋掉對acquireandreleaseinkalloc（kernel/kalloc.c：69）的調用。這似乎會導致調用skalloc的內核代碼出現問題;您希望看到什麼症狀？當您運行xv 6時，您會看到這些症狀嗎？跑步的時候呢

usertests? If you don’t see a problem, why not? See if you can provoke a problem by
inserting dummy loops into the critical section ofkalloc.


1. 假設您注釋掉了kfree中的鎖定（在恢復鎖定inkalloc之後）。現在可能會出什麼問題？缺鎖比在卡洛克里更有害嗎？
2. 如果兩個CPU同時調用kallocat，其中一個將不得不等待另一個，這對性能不利。Modifykalloc.cto具有更多的並行性，因此不同CPU對kalloc的同時調用可以繼續進行，而無需彼此等待。
3. 用POSIX線程寫一個並行程式，這是大多數作業系統支持的。例如，實現一個並行哈希表，並測量puts/gets的數量是否隨CPU數量的增加而增加。
4. 在xv 6中實現Pthreads的子集。也就是說，實現一個用戶級線程庫，使用戶進程可以有多個線程，並安排這些線程可以在不同的CPU上並行運行。提出一種正確處理線程進行阻塞系統調用並更改其共享地址空間的設計。

第7章
===

Scheduling
==========

任何作業系統運行的進程數都可能超過計算機的CPU數，因此需要一個計劃來在進程之間分時使用CPU。理想情況下，共享對用戶流程是透明的。一種常見的方法是通過將進程多路復用到硬體CPU上，使每個進程都有自己的虛擬CPU。本章將解釋xv 6是如何實現這種多路復用的。

### 7.1 Multiplexing

Xv 6通過在兩種情況下將每個CPU從一個進程切換到另一個進程來進行多路復用。首先，xv 6的sleepandwakeup機制在進程進行阻塞的系統調用（必須等待事件）時切換，通常是在read、wait或sleep中。其次，xv 6定期強制交換機科普長時間計算而不阻塞的進程。前者是自願開關;後者被稱為非自願開關。這種多路復用造成了一種錯覺，即每個進程都有自己的CPU。

實現多路復用帶來了一些挑戰。首先，如何從一個過程切換到另一個過程？其基本思想是保存和恢復CPU寄存器，儘管無法用C語言表達這一事實使其變得棘手。第二，如何以一種對用戶進程透明的方式強制切換？Xv6使用標準技術，其中硬體定時器的中斷驅動上下文切換。第三，所有的CPU都在同一組進程之間切換，因此需要一個鎖定計劃來避免競爭。第四，進程的內存和其他資源必須在進程退出時釋放，但進程本身不能完成所有這些，因為（例如）它不能在仍在使用自己的內核堆棧時釋放它自己的內核堆棧。第五，多核機器的每個CPU必須記住它正在執行的進程，以便系統調用影響正確進程的內核狀態。最後，sleepandwakeup允許進程放棄CPU，等待被另一個進程或中斷喚醒。 需要注意避免導致喚醒通知丟失的比賽。

Kernel


shell cat


user
space


kernel
space kstack
shell


kstack
cat


kstack
scheduler


save
swtch swtch restore


圖7.1：從一個用戶進程切換到另一個用戶進程。在本例中，xv6使用一個CPU（因此只有一個調度器線程）運行。

### 7.2代碼：上下文切換

圖7.1概括了從一個用戶進程切換到另一個用戶進程的步驟：從用戶空間到舊進程的內核線程的陷阱（系統調用或中斷），到當前CPU的調度器線程的上下文切換，到新進程的內核線程的上下文切換，以及到用戶級進程的陷阱返回。Xv6有單獨的線程（保存的寄存器和堆棧）來執行調度程式，因為調度程式在任何進程的內核堆棧上執行都是不安全的：其他CPU可能會喚醒進程並運行它，並且在兩個不同的CPU上使用相同的堆棧將是一場災難。每個CPU都有一個單獨的調度程式線程，以科普多個CPU正在運行一個想要放棄CPU的進程的情況。在本節中，我們將研究在內核線程和調度器線程之間切換的機制。

從一個線程切換到另一個線程涉及保存舊線程的CPU寄存器，並恢復新線程的先前保存的寄存器;堆棧指針和程式計數器被保存和恢復的事實意味著CPU將切換堆棧並切換它正在執行的代碼。

函數swtch保存和恢復內核線程切換的寄存器。swtch並不直接知道線程;它只是保存和恢復RISC-V寄存器集，稱為context。當進程需要放棄CPU時，進程的內核線程會調用swtch來保存自己的上下文並恢復調度程式的上下文。每個上下文都包含在結構上下文（kernel/proc.h：2）中，而結構上下文本身包含在進程的結構proc或CPU的結構cpu中。swtch有兩個參數：struct context_oldandstruct context_ new。它將當前寄存器保存為old，從new加載寄存器，然後返回。

讓我們跟隨一個進程進入調度程式。我們在第4章中看到，中斷結束時的一種可能性是usertrapcallsyield.yieldin turn callssched，它調用swtch將當前上下文保存在p->context中，並切換到先前保存在cpu->context中的調度程式上下文（kernel/proc.c：506）。swtch（kernel/swtch.S：3）只保存被調用方保存的寄存器; C編譯器在調用方中生成代碼，將調用方保存的寄存器保存在堆棧上。它不保存程式計數器。相反，swtchsaves theraregister，

它保存了swtch被調用的返回地址。Nowswtch從新的上下文中恢復寄存器，該上下文保存由前一個swtch保存的寄存器值。當swtch返回時，它返回到restoredragregister所指向的指令，即新線程先前調用swtch的指令。此外，它返回新線程的堆棧，因為這是restoredsp指向的地方。在我們的示例中，sched調用swtch切換到cpu->context，即每個CPU的調度程式上下文。該上下文是在過去的某個時間點保存的，當時，伺服器調用swtch（ker- nel/proc.c：466）切換到現在放棄CPU的進程。當我們跟蹤的wtch返回時，它返回的不是sched而是scheduler，堆棧指針在當前CPU的scheduler堆棧中。

### 7.3 Code: Scheduling

上一節居間了swtch的底層細節;現在讓我們以swtch為例，研究如何通過調度程式從一個進程的內核線程切換到另一個進程。調度程式以每個CPU一個特殊線程的形式存在，每個線程運行調度程式功能。這個函數負責選擇接下來運行哪個進程。想要放棄CPU的進程必須獲取自己的進程鎖p->lock，釋放它持有的任何其他鎖，更新自己的狀態（p->state），然後調用sched。你可以在yield（kernel/proc.c：512）中看到這個序列，sleepandexit. sched仔細檢查了其中的一些需求（kernel/proc.c：496-501），然後檢查了一個暗示：由於鎖被持有，中斷應該被禁用。最後，schedcallsswtch將當前上下文保存在p->context中，並切換到調度程式上下文incpu->context.swtch在調度程式堆棧上返回，就好像調度程式的sswtch已返回一樣（kernel/proc.c：466）。 調度程式繼續它的for循環，找到一個要運行的進程，切換到它，然後重複這個循環。我們剛剛看到xv 6 holddsp->lockacross調用了toswitch：switch的調用者必須已經持有鎖，並且鎖的控制權傳遞給了被切換到的代碼。這種安排是不尋常的：Xv 6的上下文切換必須打破這個慣例，因為ep->lock保護進程的state和context欄位上的不變量，這些不變量在執行inswitch時不是true。例如，如果p->lock在swtch期間沒有被保持，則在yield將其狀態設置為RUNNABLE之後，另一個CPU可能決定運行該進程，但beforewtch導致它停止使用自己的內核堆棧。結果是兩個CPU在同一個堆棧上運行，這將導致混亂。 Onceyield已開始修改正在運行的進程的狀態以使其RUNNABLE，p->lock必須保持被保持，直到不變量被恢復：最早的正確釋放點是afterscheduler（在其自己的堆棧上運行）clearsc->proc。類似地，一旦線程管理器開始將一個RUNNABLE進程轉換為RUNNING，鎖就不能被釋放，直到該進程的內核線程完全運行（在watch之後，例如在yield中）。內核線程放棄CPU的唯一地方是insched，它總是切換到scheduler中的同一位置，而scheduler（幾乎）總是切換到以前調用sched的某個內核線程。因此，如果要列印出xv 6切換線程的行號，則會觀察到以下簡單模式：（kernel/proc.c：466），（kernel/proc.c：466）。c：506），

（kernel/proc.c：466）、（kernel/proc.c：506）等。有意通過線程切換來相互轉移控制的過程有時被稱為抗壞血酸程式;在本例中，sched和schedler是彼此的協同例程。

有一種情況下，調度程式對swtch的調用不會以insched結束。allocproc將新進程的contextragregister設置為forkret（kernel/proc.c：524），以便其第一個swtch「返回」到該函數的開頭。forkret存在以釋放p->lock;否則，由於新進程需要返回到用戶空間，就像從fork返回一樣，因此它可以改為從usertrapret開始。

scheduler（kernel/proc.c：445）運行一個循環：找到一個要運行的進程，運行它直到它退出，重複。調度程式在進程表上循環查找可運行的進程，即hasp->state == RUNNABLE的進程。一旦找到一個進程，它會設置每個CPU的當前進程變量c->proc，將該進程標記為RUNNING，然後調用swt ch開始運行它（kernel/proc.c：461-466）。

### 7.4 Code: mycpu and myproc

Xv 6通常需要一個指向當前進程的指針。在單處理器上，可以有一個指向currentproc的全局變量。這在多核機器上不起作用，因為每個CPU執行不同的進程。解決這個問題的方法是利用每個CPU都有自己的寄存器集這一事實。

當一個給定的CPU在內核中執行時，xv 6確保CPU的stpregister總是保存CPU的hartid。RISC-V給它的CPU編號，給每個CPU一個唯一的hartid.mycpu（ker- nel/proc.c：74）用來索引一個cpu結構數組，並返回當前CPU的那個。一個結構體cpu（kernel/proc.h：22）保存一個指針，指向當前在該CPU上運行的進程的proc結構（如果有的話），為CPU的調度器線程保存的寄存器，以及管理中斷禁用所需的嵌套自旋鎖的計數。

確保CPU的stphold保存CPU的hartid有點複雜，因為用戶代碼可以自由修改tp. start在CPU的靴子序列的早期設置tpregister，同時仍然處於機器模式（kernel/start.c：45）。usertrapret保存trampoline頁面，以防用戶代碼修改它。最後，當從用戶空間進入內核時，uservec恢復該savedtp（kernel/trampo- line.S：78）。編譯器保證永遠不會修改內核代碼。如果xv 6可以在需要的時候向RISC-V硬體詢問當前的hartid，那會更方便，但是RISC-V只允許在機器模式下這樣做，而不是在管理模式下。cpuid和mycpu的返回值是脆弱的：如果計時器中斷並導致線程退出，然後在另一個CPU上繼續執行，則先前返回的值將不再正確。為了避免這個問題，xv 6要求調用者禁用中斷，並且只有在他們使用完confignedstruct cpu之後才啟用它們。函數myproc（kernel/proc.c：83）返回當前CPU上運行的進程的結構體proc指針。mypoc禁用中斷，調用mypcpu，從結構體cpu中取出當前進程指針（c->poc），然後啟用中斷。即使啟用了中斷，myprock的返回值也可以安全使用：如果一個計時器中斷將調用進程移動到另一個CPU，它的結構體proc指針將保持不變。

### 7.5 Sleep and wakeup

Scheduling and locks help conceal the actions of one thread from another, but we also need ab-
stractions that help threads intentionally interact. For example, the reader of a pipe in xv6 may need
to wait for a writing process to produce data; a parent’s call towaitmay need to wait for a child
to exit; and a process reading the disk needs to wait for the disk hardware to finish the read. The
xv6 kernel uses a mechanism called sleep and wakeup in these situations (and many others). Sleep
allows a kernel thread to wait for a specific event; another thread can call wakeup to indicate that
threads waiting for a specified event should resume. Sleep and wakeup are often calledsequence
coordinationorconditional synchronizationmechanisms.
Sleep and wakeup provide a relatively low-level synchronization interface. To motivate the
way they work in xv6, we’ll use them to build a higher-level synchronization mechanism called
asemaphore[5] that coordinates producers and consumers (xv6 does not use semaphores). A
semaphore maintains a count and provides two operations. The “V” operation (for the producer)
increments the count. The “P” operation (for the consumer) waits until the count is non-zero,
and then decrements it and returns. If there were only one producer thread and one consumer
thread, and they executed on different CPUs, and the compiler didn’t optimize too aggressively,
this implementation would be correct:


100 struct semaphore { 101 struct spinlock lock; 102 int count; 103 }; 104 105 void 106 V(struct semaphore \*s) 107 { 108 acquire(&s->lock); 109 s->count += 1; 110 release(&s->lock); 111 } 112 113 void 114 P(struct semaphore \*s) 115 { 116 while(s->count == 0) 117 ; 118 acquire(&s->lock); 119 s->count -= 1; 120 release(&s->lock); 121 }

The implementation above is expensive. If the producer acts rarely, the consumer will spend
most of its time spinning in thewhileloop hoping for a non-zero count. The consumer’s CPU
could probably find more productive work thanbusy waitingby repeatedlypollings->count.


Avoiding busy waiting requires a way for the consumer to yield the CPU and resume only afterV
increments the count.
Here’s a step in that direction, though as we will see it is not enough. Let’s imagine a pair of
calls,sleepandwakeup, that work as follows.sleep(chan)waits for an event designated by
the value ofchan, called thewait channel.sleepputs the calling process to sleep, releasing the
CPU for other work.wakeup(chan)wakes all processes that are in calls tosleepwith the same
chan(if any), causing theirsleepcalls to return. If no processes are waiting onchan,wakeup
does nothing. We can change the semaphore implementation to usesleepandwakeup(changes
highlighted in yellow):


200 void 201 V(struct semaphore \*s) 202 { 203 acquire(&s->lock); 204 s->count += 1; 205 wakeup(s); 206 release(&s->lock); 207 } 208 209 void 210 P(struct semaphore \*s) 211 { 212 while(s->count == 0) 213 sleep(s); 214 acquire(&s->lock); 215 s->count -= 1; 216 release(&s->lock); 217 }

Pnow gives up the CPU instead of spinning, which is nice. However, it turns out not to be
straightforward to designsleepandwakeupwith this interface without suffering from what is
known as thelost wake-upproblem. Suppose thatPfinds thats->count == 0on line 212. While
Pis between lines 212 and 213,Vruns on another CPU: it changess->countto be nonzero and
callswakeup, which finds no processes sleeping and thus does nothing. NowPcontinues executing
at line 213: it callssleepand goes to sleep. This causes a problem:Pis asleep waiting for aVcall
that has already happened. Unless we get lucky and the producer callsVagain, the consumer will
wait forever even though the count is non-zero.
The root of this problem is that the invariant thatPsleeps only whens->count == 0is violated
byVrunning at just the wrong moment. An incorrect way to protect the invariant would be to move
the lock acquisition (highlighted in yellow below) inPso that its check of the count and its call to
sleepare atomic:


300 void 301 V(struct semaphore \*s) 302 { 303 acquire(&s->lock);

304 s->count += 1; 305 wakeup（s）; 306 release（&s->lock）; 307 } 308 309 void 310 P（struct信號量 \*s）311 { 312 acquire（&s->lock）; 313 while（s->count == 0）314 sleep（s）; 315 s->count -= 1; 316 release（&s->lock）; 317 }

One might hope that this version ofPwould avoid the lost wakeup because the lock preventsV
from executing between lines 313 and 314. It does that, but it also deadlocks:Pholds the lock
while it sleeps, soVwill block forever waiting for the lock.
We’ll fix the preceding scheme by changingsleep’s interface: the caller must pass thecon-
dition locktosleepso it can release the lock after the calling process is marked as asleep and
waiting on the sleep channel. The lock will force a concurrentVto wait untilPhas finished putting
itself to sleep, so that thewakeupwill find the sleeping consumer and wake it up. Once the con-
sumer is awake againsleepreacquires the lock before returning. Our new correct sleep/wakeup
scheme is usable as follows (change highlighted in yellow):


401 V（struct信號量 \*s）402 { 403獲取（&s->lock）; 404 s->count += 1; 405喚醒; 406釋放（&s->lock）; 407 } 408 409 void 410 P（結構信號量 \*s）411 { 412獲取（&s->lock）; 413 while（s->count == 0）414休眠（s，&s->lock）; 415 s->count -= 1; 416釋放（&s->lock）; 417 }

The fact thatPholdss->lockpreventsVfrom trying to wake it up betweenP’s check of
s->countand its call tosleep. However,sleepmust releases->lockand put the consuming


從喚醒的角度來看，進程以原子的方式睡眠，以避免丟失喚醒。

### 7.6 Code: Sleep and wakeup

Xv 6的sleep（kernel/proc.c：548）和wakeup（kernel/proc.c：579）提供了上面最後一個例子中使用的接口。其基本思想是讓休眠標記當前進程為SLEEPING，然後調用sched來釋放CPU;喚醒上傳在給定等待通道上休眠的進程，並將其標記為RUNNABLE。sleep和wakeup的呼叫者可以使用任何相互方便的號碼作為通道。Xv 6經常使用等待中涉及的內核數據結構的地址。sleep獲取sp->lock（kernel/proc.c：559），然後才釋放lk。正如我們將看到的，sleep始終保持這些鎖中的一個或另一個的事實是阻止並發喚醒（必須獲取並保持兩者）的原因。現在sleep的值是p->lock，它可以通過記錄sleep通道，將進程狀態更改為SLEEPING，然後調用sched（kernel/proc.c：563-566）來將進程置於睡眠狀態。稍後我們將清楚為什麼在進程標記為SLEEPING之後才釋放p->lock（由調度程式）是至關重要的。 在某些時候，進程將獲取條件鎖，設置休眠者正在等待的條件，並調用wakeup（chan）。在保持條件鎖^1的情況下調用wakeup是很重要的。wakeuplops在進程表上（kernel/proc.c：579）。它獲取它檢查的每個進程的p->lock。當wakeup發現一個狀態為SLEEPING的進程有一個匹配的更改時，它會將該進程的狀態更改為RUNNABLE。下一次時間調度程式運行時，它將看到流程已準備好運行。為什麼sleep和wakeup的鎖定規則確保一個將要休眠的進程不會錯過並發喚醒？進入睡眠狀態的進程在檢查條件之前，會保持條件鎖或其自己的p-%3鎖，或者同時保持這兩個鎖，直到它被標記為SLEEPING。調用wakeupders的進程都鎖定在wakeup的循環中。 因此，喚醒器要麼在消費線程檢查條件之前使條件為真;要麼喚醒器的swakeup在睡眠線程被標記為SLEEPING之後嚴格檢查睡眠線程。Thenwakeup會看到休眠進程並將其喚醒（除非有其他東西先將其喚醒）。有時多個進程在同一個通道上休眠;例如，多個進程從管道中閱讀。一聲叫醒就會把他們都叫醒。其中一個將首先運行並獲取sleep調用時使用的鎖，並（在管道的情況下）讀取任何等待的數據。其他進程將發現，儘管被喚醒，但沒有數據可讀取。從他們的角度來看，醒來是「虛假的」，他們必須再次睡覺。出於這個原因，sleep總是在檢查條件的循環中調用。 如果sleep/wakeup的兩次使用意外地選擇了同一個通道，則不會造成任何損害：它們將看到虛假的喚醒，但如上所述的循環將容忍此問題。sleep/wakeup的魅力在於它是輕量級的（不需要創建特殊的數據結構來充當sleep通道），並提供了一層間接性（調用者不需要知道他們正在與哪個特定進程交互）。

（^1）嚴格地說，如果wake up僅僅跟隨在acquire之後就足夠了（也就是說，可以在therelease之後調用wake up）。

### 7.7產品編號：Pipes

使用leepandwakeup來同步生產者和消費者的一個更複雜的例子是xv 6的管道實現。我們在第1章中看到了管道的接口：寫入管道一端的字節被複製到內核緩衝區，然後可以從管道的另一端讀取。後面的章節將研究圍繞管道的文件描述符支持，但現在讓我們看看pipewrite和piperead的實現。每個管道都由一個struct pipe表示，其中包含一個lock和一個adatabuffer。欄位nread和nwrite計算從緩衝區讀取和寫入緩衝區的字節總數。緩衝區迴繞：buf \[PIPESIZE-1\]之後寫入的下一個字節是buf \[0\]。計數不換行。這個約定讓實現區分滿緩衝區（nwrite == nread+PIPESIZE）和空緩衝區（nwrite == nread），但它意味著索引到緩衝區必須使用buf \[nread % PIPESIZE\]而不是justbuf\[nread\]（nwrite也是如此）。 讓我們假設topiperead和pipewrite的調用同時發生在兩個不同的CPU上。pipewrite（kernel/pipe.c：77）首先獲取管道的鎖，該鎖保護計數、數據及其相關的不變量。piperead（kernel/pipe.c：106）然後嘗試獲取鎖，但不能。它在獲取時旋轉（kernel/spinlock.c：22），等待鎖。當piperead等待時，pipewriter在正在寫入的字節上循環（addr\[0.. n-1\]），依次將每個對象添加到管道中（kernel/pipe.c：95）。在這個循環中，可能會發生緩衝區被填滿的情況（kernel/pipe.c：88）。在這種情況下，pipewritecallswakeup提醒任何休眠的讀取器緩衝區中有數據等待，然後在&pi->nwrite上休眠以等待讀取器從緩衝區中取出一些字節。sleepreleases管道的鎖作為將pipewrite的進程置於休眠狀態的一部分。piperead現在獲取管道的鎖並進入其臨界區：它發現pi->nread！= pi->nwrite（內核/管道。c：113）（pipewrite進入睡眠狀態，因為epi->nwrite == pi->nread

*   PIPESIZE（kernel/pipe.c：88）），因此它福爾斯for循環，將數據複製出管道（kernel/pipe.c：120），並將snread增加複製的字節數。那麼多字節現在可用於寫入，sopipereadcallswakeup（kernel/pipe.c：127）在返回之前喚醒任何睡眠的寫入器。wakeup查找在&pi->nwrite上睡眠的進程，該進程正在運行pipewrite，但在緩衝區填滿時停止。它將該進程標記為RUNNABLE。管道代碼為讀取器和寫入器使用單獨的睡眠通道（pi->nreadandpi->nwrite）;這可能使系統在有許多讀取器和寫入器等待同一管道的情況下更有效。管道代碼在一個檢查睡眠條件的循環中睡眠;如果有多個讀取器或寫入器，除了第一個喚醒的進程之外，所有進程都會看到條件仍然為false，並再次睡眠。

### 7.8代碼：等待，退出，然後殺死

sleepandwakeup可以用於多種等待。一個有趣的例子，在第一章中居間過，是孩子的性別和父母的等待之間的相互作用。在孩子死亡的時候，父母可能已經在睡覺等待，或者可能正在做其他事情;在後一種情況下，隨後的等待呼叫必須觀察孩子的死亡，也許在它呼叫之後很久

退出. xv 6記錄子進程的終止直到wait觀察到它的方法是，將調用者放入ZOMBIEstate，在那裡它一直呆到父進程的wait注意到它，將子進程的狀態更改為UNUSED，複製子進程的退出狀態，並將子進程的進程ID返回給父進程。如果父進程在子進程之前退出，父進程會將子進程交給init進程，init進程會永久調用wait;因此，每個子進程都有一個父進程在它之後進行清理。一個挑戰是避免同時發生的父進程和子進程wait和exit之間的競爭和死鎖，以及錯誤的exit和exit。

wait通過獲取wait\_lock（kernel/proc.c：391）啟動，wait\_lock充當條件鎖，幫助確保wait不會錯過從一個退出的子進程喚醒。然後wait掃描進程表。如果它在ZOMBIEstate中找到子進程，它會釋放子進程的資源和進程結構，將子進程的退出狀態複製到wait提供的地址（如果它不是0），並返回子進程的進程ID。如果wait找到子進程但沒有子進程退出，它會調用sleep等待它們中的任何一個退出（kernel/proc.c：433），然後再次掃描。wait通常持有兩個鎖，wait\_lock和某個進程的spp->lock;避免死鎖的順序是先wait\_lock，然後pp->lock。

exit（kernel/proc.c：347）記錄退出狀態，釋放一些資源，調用reparent以將其子進程交給init進程，在父進程處於等待狀態時喚醒父進程，將調用者標記為殭屍，並永久放棄CPU。在此序列中，exit同時保存wait\_lock和p->lock。它持有wait\_lock，因為它是喚醒（p->parent）的條件鎖，防止等待中的父節點失去喚醒。exit也必須持有dp->lock，以防止等待中的父節點在子節點最終調用swtch之前看到子節點處於ZOMBIE狀態。exit以與wait相同的順序獲取這些鎖，以避免死鎖。

在將父進程的狀態設置為ZOMBIE之前喚醒父進程可能看起來不正確，但這是安全的：儘管喚醒可能導致父進程運行，但等待中的循環在調度程式釋放子進程的sp-%3鎖之前不能檢查子進程，因此在將其狀態設置為ZOMBIE（kernel/proc.c：379）之後很久才能查看退出的進程。

exit允許進程自行終止，kill（kernel/proc.c：598）允許一個進程請求另一個進程終止。直接銷毀受害進程太複雜了，因為受害進程可能正在另一個CPU上執行，可能正在內核數據結構的敏感更新序列中。這樣做很少：它只是設置受害者的p-%3 Ekilled，如果它正在睡覺，喚醒它。最終，受害者將進入或離開內核，此時usertrap中的代碼將調用lexitifp->killledis設置（它通過調用killed（kernel/proc.c：627）進行檢查）。如果受害者在用戶空間中運行，它很快就會通過進行系統調用或因為計時器（或其他設備）中斷而進入內核。

如果犧牲進程處於睡眠狀態，kill對wakeup的調用將導致犧牲進程從睡眠狀態返回。這是潛在的危險，因為等待的條件可能不為真。然而，xv 6對sleep的調用總是封裝在whileloop中，在sleeppreturn之後重新測試條件。有些調用tosleep也會在循環中測試p->kill，如果當前Activity已設置，則會放棄當前Activity。只有當這种放棄是正確的時候才這樣做。例如，如果設置了killed標誌，管道讀寫代碼（kernel/pipe.c：84）將返回;最終代碼將返回到trap，trap將再次檢查p->killed並退出。

某些xv 6 sleeploop不檢查p->killed，因為代碼處於多步系統調用的中間，而該調用應該是原子的。virtio驅動程式（kernel/virtio\_disk.c：285）就是一個例子：它

不檢查p->killed，因為磁碟操作可能是一組寫入操作之一，這些寫入操作都是使文件系統保持正確狀態所必需的。在等待磁碟I/O時被殺死的進程不會退出，直到它完成當前的系統調用並且用戶陷阱看到killed標誌。

### 7.9 Process Locking

與每個進程關聯的鎖（p->lock）是xv 6中最複雜的鎖。考慮p-%3 Elock的一個簡單方法是，在閱讀或寫入以下任何結構procfield時必須保持它：p-%3 Estate、p-%3 Echan、p-%3 Ekilled、p-%3 Exstate和p-%3 Epid。這些欄位可以由其他進程或其他CPU上的調度程式線程使用，因此它們自然必須受到鎖的保護。但是，p->lock的大多數用途是保護xv 6進程數據結構和算法的高級方面。以下是p->lock的全部功能：

*   沿著p-%3 Estate，它可以防止為新進程分配proc \[\]插槽時出現競爭。
*   它在創建或銷毀過程時隱藏了過程。
*   它防止父進程的等待收集一個已經將其狀態設置為ZOMBIE但還沒有產生CPU的進程。
*   它可以防止另一個CPU的調度程式在將其狀態設置為RUNNABLE後但在完成wtch之前決定運行讓步進程。
*   它確保只有一個CPU的調度程式決定運行一個RUNNABLE進程。
*   它可以防止定時器中斷導致進程在中斷時退出。
*   沿著條件鎖，它有助於防止喚醒忽略一個正在調用sleep但尚未完成CPU釋放的進程。
*   它阻止了ckill的受害進程退出，並且可能在kill檢查p->pid和設置p->killed之間重新分配。
*   它使kill對p-%3 Estate的檢查和寫入成為原子。

p->partfield由全局鎖wait\_lock而不是p->lock保護。只有進程的父進程修改p->parent，儘管該欄位由進程本身和搜索其子進程的其他進程讀取。wait\_lock的作用是在wait休眠等待任何子進程退出時充當條件鎖。一個正在退出的子進程會持有wait\_lock或p->lock，直到它將自己的狀態設置為ZOMBIE，喚醒了它的父進程，並獲得了CPU。wait\_lock還將通過父進程和子進程來序列化並發文本，以便init進程（繼承子進程）保證從itswait中被喚醒。wait\_lock是一個全局鎖，而不是每個父進程中的每個進程鎖，因為，直到一個進程獲得它，它不知道它父母是誰。

### 7.10 Real world

xv6調度程式實現了一個簡單的調度策略，它依次運行每個進程。這一政策被稱為循環往復。真實的作業系統實現更複雜的策略，例如，允許進程具有優先級。其思想是，可運行的高優先級進程將優先於可運行的低優先級進程。這些策略可能會很快變得複雜，因為通常存在相互競爭的目標：例如，作業系統可能還希望保證公平性和高吞吐量。此外，複雜的策略可能會導致意外的交互，例如優先級反轉和護送。當低優先級進程和高優先級進程都使用特定的鎖時，優先級反轉可能發生，當低優先級進程獲取該鎖時，該鎖可能會阻止高優先級進程進行處理。 當許多高優先級進程正在等待一個獲得共享鎖的低優先級進程時，就會形成一個長的等待進程車隊;一旦車隊形成，它就會持續很長時間。為了避免這類問題，在複雜的機器人中，附加的機構是必要的。sleep和wakeup是一種簡單而有效同步方法，但還有許多其他方法。所有這些方法中的第一個挑戰是避免我們在本章開頭看到的「失去喚醒」問題。最初的Unix內核sleep只是簡單地禁用中斷，這是因為Unix運行在單CPU系統上。因為xv 6運行在多處理器上，所以它為sleep添加了一個顯式的鎖。FreeBSD的smsleep採用了同樣的方法。Plan 9的sleep使用一個回調函數，該函數在進入睡眠之前使用調度鎖運行;該函數用作睡眠條件的最後一分鐘檢查，以避免丟失喚醒。 Linux內核的sleep使用一個顯式的進程隊列，稱為等待隊列，而不是等待通道;隊列有自己的內部鎖。在喚醒時掃描整個進程集是低效的。一個更好的解決方案是用一個數據結構來替換sleep和wakeup機制，該數據結構包含一個在該結構上睡眠的進程列表，比如Linux的等待隊列。計劃9的睡眠和喚醒電話，結構一個集合點。許多線程庫引用相同的結構作為條件變量;在該上下文中，sleep和wakeup操作被稱為wait和signal。所有這些機制都有一個共同的特點：睡眠狀態受到某種在睡眠期間自動丟棄的鎖的保護。wakeup的實現喚醒了在特定通道上等待的所有進程，並且可能有許多進程正在等待該特定通道。作業系統將調度所有這些進程，它們將競相檢查睡眠條件。 以這種方式表現的過程有時被稱為「驚群」，最好避免。大多數條件變量有兩個喚醒原語：信號，喚醒一個進程，廣播，喚醒所有等待的進程。信號量通常用於同步。計數通常對應於管道緩衝區中可用的字節數或進程具有的殭屍子進程數。使用顯式計數作為抽象的一部分可以避免「丟失喚醒」問題：存在已發生的喚醒次數的顯式計數。計數還避免了虛假喚醒和雷鳴般的羊群問題。終止進程並清理它們在xv6中引入了很多複雜性。 在大多數作業系統中，它甚至更加複雜，因為，例如，受害進程可能很深

在內核內部休眠和展開其堆棧需要小心，因為調用堆棧上的每個函數可能需要做一些清理。有些語言提供了異常機制，但C語言沒有。此外，還有其他事件可以導致睡眠進程被喚醒，即使它正在等待的事件尚未發生。例如，當一個Unix進程正在休眠時，另一個進程可能會向它發送一個信號。在這種情況下，該進程將從被中斷的系統調用返回，返回值為-1，錯誤代碼設置為EINTR。應用程式可以檢查這些值並決定要做什麼。Xv 6不支持信號，因此不會出現這種複雜性。Xv 6對ckilled的支持並不完全令人滿意：有一些睡眠循環，可能應該檢查p->killed。 一個相關的問題是，即使對於檢查p->killed的sleeploop，sleep和kill之間也存在競爭;後者可能會設置p->killed，並試圖在受害者的循環檢查sp->killed之後但在調用sleep之前喚醒受害者。如果出現此問題，受害者將不會注意到p->killed，直到它正在等待的條件出現。這可能會晚一點，甚至永遠不會（例如，如果受害者正在等待來自控制台的輸入，但用戶沒有鍵入任何輸入）。一個真實的作業系統會在常數時間內找到帶有顯式空閒列表的freeprocstructures，而不是allocproc中的線性時間搜索; xv 6使用線性掃描來簡化。

### 7.11 Exercises

1. 在xv 6中不使用sleepandwakeup實現信號量（但使用自旋鎖也是可以的）。選擇一些xv 6的sleep和wakeup用法，並將它們替換為信號量。判斷結果。
2. 修復上面提到的campus和sleep之間的競爭，這樣在犧牲品的sleep循環檢查sp->killed之後但在調用sleep之前發生的kill會導致犧牲品放棄當前的系統調用。
3. 設計一個計劃，以便每個睡眠循環都檢查sp-%3 Ekilled以便，例如，如果virtio驅動程式中的進程被另一個進程殺死，則可以從while循環快速返回。
4. 修改xv 6，使其在從一個進程的內核線程切換到另一個進程的內核線程時只使用一個上下文切換，而不是通過調度器線程進行切換。產生的線程將需要選擇下一個線程本身並調用swtch。挑戰將是防止多個CPU意外執行同一線程;獲得正確的鎖定;以及避免死鎖。
5. 修改xv 6的中斷器，以便在沒有進程可運行時使用RISC-VWFI（等待中斷）指令。嘗試確保，任何時候有可運行的進程等待運行，沒有CPU暫停在WFI中。

第8章
===

文件系統
====

文件系統的目的是組織和存儲數據。文件系統通常支持用戶和應用程式之間的數據共享，以及數據在重新引導後仍然可用的持久性。xv6文件系統提供類Unix的文件、目錄和路徑名（參見第1章），並將其數據存儲在virtio磁碟上以實現持久化。該文件系統解決了多個難題：

*   文件系統需要磁碟上的數據結構來表示命名目錄和文件的樹，記錄保存每個文件內容的塊的標識，並記錄磁碟的哪些區域是空閒的。
*   文件系統必須支持崩潰恢復。也就是說，如果崩潰（例如，電源故障）時，文件系統必須在重新啟動後仍能正常工作。風險在於崩潰可能中斷更新序列並留下不一致的磁碟上數據結構（例如，既在文件中使用又標記為空閒的塊）。
*   不同的進程可能同時在文件系統上運行，因此文件系統代碼必須協調以維護不變量。
*   磁碟訪問速度比訪問內存慢幾個數量級，因此文件系統必須維護一個流行塊的內存緩存。

The rest of this chapter explains how xv6 addresses these challenges.


### 8.1概述

xv6文件系統實現分為七層，如圖8.1所示。磁碟層讀取和寫入virtio硬碟驅動器上的塊。緩衝區緩存層緩存磁碟塊並禁止對它們的訪問，確保一次只有一個內核進程可以修改存儲在任何特定塊中的數據。日誌記錄層允許更高層在傳輸中將更新包裝到多個塊，並確保在出現崩潰時以原子方式更新這些塊（即，它們都被更新或沒有）。inode層提供單獨的文件，每個文件

Directory


Inode


Logging


Buffer cache


Pathname


File descriptor


（^）磁碟^圖8.1：xv 6文件系統的層。表示為一個節點，具有唯一的i號和一些保存文件數據的塊。目錄層將每個目錄實現為一種特殊的inode，其內容是一系列目錄條目，每個條目包含一個文件名和i號。路徑名層提供了分層路徑名，如/usr/rtm/xv 6/fs. c，並使用遞歸查找解析它們。文件描述符層抽象了許多Unix資源（例如，管道、設備、文件等）使用文件系統接口，簡化了應用程式員的工作。磁碟硬體傳統上將磁碟上的數據表示為512位元組塊（也稱為扇區）的編號序列：扇區0是第一個512位元組，扇區1是下一個，依此類推。作業系統用於其文件系統的塊大小可能不同於磁碟使用的扇區大小，但通常塊大小是扇區大小的倍數。 Xv 6在typestruct buf（kernel/buf.h：1）的對象中保存它讀入內存的塊的複本。存儲在這種結構中的數據有時與磁碟不同步：它可能尚未從磁碟讀取（磁碟正在處理它，但尚未返回扇區的內容），或者它可能已被軟體更新，但尚未寫入磁碟。文件系統必須有一個關於在磁碟上存儲信息節點和內容塊的計劃。為此，xv 6將磁碟分成幾個部分，如圖8.2所示。文件系統不使用塊0（它保存靴子扇區）。塊1稱為日誌塊;它包含有關文件系統的元數據（文件系統大小（以塊為單位）、數據塊數、inode數和日誌中的塊數）。從2開始的塊保存日誌。日誌之後是inode，每個塊有多個inode。之後是位圖塊，用於跟蹤哪些數據塊正在使用。 其餘的塊是數據塊;每個塊在位圖塊中被標記為空閒，或者保存文件或目錄的內容。超級塊由一個單獨的程式mkfs填充，該程式構建一個初始文件系統。本章的其餘部分將從緩衝區緩存開始討論每一層。注意在較低層精心選擇的抽象簡化了較高層的設計的情況。

0


bootsuper log inodes bit map data


1


.... data


2


Figure 8.2: Structure of the xv6 file system.


### 8.2 Buffer cache layer

緩衝區緩存有兩個任務：（1）同步對磁碟塊的訪問，以確保內存中只有一個塊的複本，並且每次只有一個內核線程使用該複本;（2）緩存流行的塊，以便不需要從慢速磁碟重新讀取它們。代碼是inbio.c。由緩衝區緩存導出的主接口由bread和bwrite組成;前者獲取包含一個塊的複本的bub，該塊可以在內存中讀取或修改，後者將修改後的緩衝區寫入磁碟上的相應塊。當內核線程使用完緩衝區後，必須通過調用brelse來釋放緩衝區。緩衝區緩存使用每個緩衝區的睡眠鎖來確保每次只有一個線程使用每個緩衝區（因此每個磁碟塊）; bread返回一個鎖定的緩衝區，brelse釋放鎖。讓我們回到緩衝區緩存。 緩衝區緩存有固定數量的緩衝區來保存磁碟塊，這意味著如果文件系統請求該高速緩存中還沒有的塊，則緩衝區緩存必須回收當前保存其他塊的緩衝區。緩衝區高速緩存為新塊重新分配最近最少使用的緩衝區。假設最近最少使用的緩衝區是最不可能很快再次使用的緩衝區。

### 8.3 Code: Buffer cache

緩衝區高速緩存是緩衝區的雙向連結列表。函數binit由main（kernel/- main.c：27）調用，它使用靜態數組buf（kernel/bio.c：43-52）中的NBUFbuffers對列表進行重命名。對緩衝區緩存的所有其他訪問都通過abcache.head引用鍊表，而不是bufarray。一個緩衝區有兩個與之相關的狀態欄位。欄位valid表示緩衝區包含塊的複本。欄位disk指示緩衝區內容已經被傳遞到盤，這可能改變緩衝區（例如，將數據從磁碟寫入數據）。bread（kernel/bio.c：93）調用sbget為給定扇區（kernel/bio.c：97）獲取緩衝區。如果需要從磁碟讀取緩衝區，則breadcallsvirtio\_disk\_rwto在返回緩衝區之前執行此操作。bget（kernel/bio.c：59）掃描緩衝區列表，以查找具有給定設備和扇區號（kernel/bio.c：65-73）的緩衝區。如果存在這樣的緩衝區，bget獲取緩衝區的睡眠鎖。bget然後返回鎖定的緩衝區。 如果給定扇區沒有緩存緩衝區，bget必須創建一個，可能會重用保存不同扇區的緩衝區。它再次掃描緩衝區列表，查找未使用的緩衝區（B-%3 Erefcnt = 0）;任何此類緩衝區都可以使用。bgetedits緩衝區元數據以記錄新設備和扇區號，並獲取其休眠鎖。 請注意，賦值b->valid = 0確保麵包將從磁碟讀取塊數據，而不是錯誤地使用緩衝區的

以前的內容。每個磁碟扇區最多有一個緩存緩衝區是很重要的，以確保讀取器看到寫入，並且因為文件系統使用緩衝區上的鎖進行同步。bget通過從第一次循環檢查塊是否被緩存到第二次循環聲明塊現在被緩存（通過設置dev，blockno，andrefcnt）連續保持bache.lock bcache. lock來確保此不變量。這使得對塊的存在的檢查和（如果不存在）保存塊的緩衝區的指定是原子的。在bcache.lockcritical部分之外獲取緩衝區的睡眠鎖是安全的，因為非零的->refcnt防止緩衝區被重新用於不同的磁碟塊。sleep-lock保護對塊的緩衝內容的讀取和寫入，而bcache. lock保護關於哪些塊被緩存的信息。 如果所有的緩衝區都是忙碌的，那麼太多的進程同時執行文件系統調用;bgetpanics。一個更優雅的響應可能是休眠，直到緩衝區空閒，儘管這樣可能會出現死鎖。一旦麵包讀取了磁碟（如果需要）並將緩衝區返回給其調用者，調用者就獨占使用緩衝區並可以讀取或寫入數據字節。如果調用者確實修改了緩衝區，那麼在釋放緩衝區之前，它必須調用bwrite將更改的數據寫入磁碟。bwrite（kernel/bio.c：107）調用virtio\_disk\_rto與磁碟硬體對話。當調用者使用完一個緩衝區時，它必須調用brelse來釋放它（b-release的縮寫，這個名字很晦澀，但值得學習：它起源於Unix，也用於BSD、Linux和Solaris）。brelse（kernel/bio.c：117）釋放睡眠鎖並將緩衝區移動到鍊表的前面（kernel/bio.c：128-133）。 移動緩衝區會導致列表按緩衝區最近使用的時間（即釋放）排序：列表中的第一個緩衝區是最近使用的，最後一個是最近使用的。這兩個循環inbget利用了這一點：在最壞的情況下，對現有緩衝區的掃描必須處理整個列表，但是當有良好的引用局部性時，首先檢查最近使用的緩衝區（從bcache. head開始，然後是nextpointer）將減少掃描時間。選擇要重用的緩衝區的掃描通過向後掃描（跟隨prevpoints）來選擇最近最少使用的緩衝區。

### 8.4 Logging layer

文件系統設計中最有趣的問題之一是崩潰恢復。問題的出現是因為許多文件系統操作涉及到對磁碟的多次寫入，並且在寫入的子集之後的崩潰可能會使磁碟上的文件系統處於不一致的狀態。例如，假設在文件截斷（將文件的長度設置為零並釋放其內容塊）期間發生崩潰。根據磁碟寫入的順序，崩潰可能會留下對標記為空閒的內容塊的引用的inode，也可能會留下已分配但未引用的內容塊。後者是相對良性的，但是引用釋放塊的inode很可能在重新引導後導致嚴重的問題。重啟後，內核可能會將該塊分配給另一個文件，現在我們有兩個不同的文件無意中指向同一個塊。如果xv6支持多個用戶，那麼這種情況可能是一個安全問題，因為舊文件的所有者可以讀取

並在新文件中寫入由不同用戶擁有的塊。Xv6通過一種簡單的日誌記錄形式解決了文件系統操作期間的崩潰問題。xv6系統調用不直接寫入磁碟上的文件系統數據結構。相反，它會在磁碟上放置一個描述，描述它希望進行的所有磁碟寫入。一旦系統調用記錄了它的所有寫操作，它就向磁碟寫入一個特殊的commitrecord，指示日誌包含一個完整的操作。此時，系統調用將寫入複製到磁碟上的文件系統數據結構。在這些寫操作完成之後，系統調用將擦除磁碟上的日誌。如果系統崩潰並重新啟動，則在運行任何進程之前，文件系統代碼將按如下方式從崩潰中恢復。如果日誌被標記為包含完整的操作，則恢復代碼會將寫入複製到磁碟文件系統中的相應位置。 如果日誌未標記為包含完整操作，則恢復代碼將忽略該日誌。恢復代碼通過擦除日誌完成。為什麼xv6的日誌解決了文件系統操作過程中崩潰的問題？如果崩潰發生在操作提交之前，那麼磁碟上的日誌將不會被標記為完成，重新精化代碼將忽略它，並且磁碟的狀態將如同操作甚至還沒有開始一樣。如果崩潰發生在操作提交之後，那麼恢復將重放操作的所有寫入，如果操作已經開始將它們寫入磁碟上的數據結構，則可能重複它們。在任何一種情況下，日誌都使操作在崩潰方面變得原子化：在恢復之後，要麼所有操作的寫入都出現在磁碟上，要麼一個都不出現。

### 8.5 Log design

日誌駐留在超級塊中指定的已知固定位置。它由一個頭塊和一系列更新塊複本（「日誌塊」）組成。頭塊包含一個扇區號數組，每個記錄塊對應一個扇區號，以及日誌塊的計數。磁碟上的頭塊中的計數要麼為零，指示日誌中沒有事務，要麼為非零，指示日誌包含具有所指示的記錄塊數量的完整提交事務。Xv 6在事務提交時寫入頭塊，而不是在此之前，並在將記錄的塊複製到文件系統後將計數設置為零。因此，事務中途的崩潰將導致日誌頭塊中的計數為零;提交後的崩潰將導致非零計數。每個系統調用的代碼指示寫入序列的開始和結束，這些寫入序列必須是原子的，以防止崩潰。 為了允許不同進程並發執行文件系統操作，日誌記錄系統可以將多個系統調用的寫入累積到一個事務中。因此，單個提交可能涉及多個完整系統調用的寫入。為了避免在事務之間分割系統調用，日誌記錄系統僅在沒有文件系統系統調用正在進行時提交。將多個事務一起提交的想法稱為組提交。組提交減少了磁碟操作的數量，因為它將提交的固定成本分攤到多個操作上。組提交還同時向磁碟系統傳遞更多並發寫操作，可能允許磁碟在單個磁碟旋轉期間將它們全部寫入。Xv6的virtio驅動程式不支持這種類型的緩存，但是xv6的文件系統設計允許它。

Xv 6在磁碟上分配固定的空間來保存日誌。事務中系統調用寫入的塊的總數必須適合該空間。這有兩個結果。不允許單個系統調用寫入超過日誌空間的不同塊。這對於大多數系統調用來說都不是問題，但是其中兩個調用可能會寫入許多塊：writeandunlink。大文件寫入可能會寫入許多數據塊、許多位圖塊以及一個inode塊;取消連結大文件可能會寫入許多位圖塊和一個inode。Xv 6的write系統調用將大型寫入拆分為多個適合日誌的較小寫入，並且取消連結不會引起問題，因為實際上xv 6文件系統僅使用一個位圖塊。日誌空間有限的另一個後果是，日誌系統不能允許系統調用啟動，除非它確定系統調用的寫入將適合日誌中剩餘的空間。

### 8.6 Code: logging

系統調用中日誌的典型用法如下所示：

開始\_op（）;. blog = blog（...）; bp->data\[...\] = ...; log\_write（bp）;. return（）;開始\_op（kernel/log.c：127）等待，直到日誌記錄系統當前沒有提交，並且有足夠的未保留日誌空間來保存來自此調用的寫入。log.outstanding計數具有保留日誌空間的系統調用的數量;總保留空間為log.outstanding times MAXOPBLOCKS。遞增log. outstanding既可以保留空間，又可以防止在此系統調用期間發生提交。代碼保守地假設每個系統調用最多可以寫入MAXOPBLOCKS個不同的塊。log\_write（kernel/log.c：215）充當bwrite的代理。它在內存中記錄塊的扇區號，在磁碟上的日誌中為其保留一個插槽，並將緩衝區固定在塊緩存中以防止塊緩存驅逐它。 在提交之前，塊必須留在該高速緩存中：在此之前，緩存的複本是修改的唯一記錄;在提交之後才能將其寫入磁碟上的位置;並且同一事務中的其他讀取必須看到修改。log\_write在單個事務中多次寫入塊時發出通知，並在日誌中為該塊分配相同的插槽。這種優化通常被稱為吸收。例如，包含多個文件的inode的磁碟塊在一個事務中被多次寫入是很常見的。通過將多個磁碟寫操作合併到一個磁碟中，文件系統可以節省日誌空間，並且可以獲得更好的性能，因為只需將磁碟塊的一個複本寫入磁碟。end\_op（kernel/log.c：147）首先遞減未完成系統調用的計數。如果計數現在為零，則通過調用commit（）提交當前事務。c：179）將事務中修改的每個塊從緩衝區高速緩存複製到磁碟上日誌中的其槽中。write\_head（）（kernel/log.c：103）將頭塊寫入磁碟：這是提交點，寫入後的崩潰將導致恢復重放

install\_transs（kernel/log.c：69）從日誌中讀取每個塊並將其寫入文件系統中的適當位置。Finallyend\_op寫入日誌頭，計數為零;這必須在下一個事務開始寫入日誌塊之前發生，這樣崩潰就不會導致使用一個事務的頭和後續事務的日誌塊進行恢復。

recover\_from\_log（kernel/log.c：117）被稱為frominitlog（kernel/log.c：55），在第一個用戶進程運行（kernel/proc.c：535）之前的靴子期間，它被稱為fromfsinit（kernel/fs.c：42）。它讀取日誌標頭，並在標頭指示日誌包含已提交事務時模仿end\_op的操作。

使用日誌的一個示例發生在infilewrite（kernel/file.c：135）。交易看起來像這樣：

begin_op();
ilock(f->ip);
r = writei(f->ip, ...);
iunlock(f->ip);
end_op();


這段代碼被包裝在一個循環中，該循環將大的寫操作分解為一次只有幾個扇區的單獨事務，以避免日誌溢出。調用towrewritei會在這個事務中寫入許多塊：文件的inode、一個或多個位圖塊，以及一些數據塊。

### 8.7 Code: Block allocator

文件和目錄內容存儲在磁碟塊中，必須從空閒池中分配。Xv 6的塊分配器在磁碟上維護一個空閒位圖，每個塊一位。0位表示相應的塊空閒; 1位表示它正在使用。程式會設置與靴子扇區、超級塊、日誌塊、信息節點塊和位圖塊相對應的位。

ballocat（kernel/fs.c：72）中的循環考慮每個塊，從塊0開始，直到b.size，文件系統中的塊數。它查找位圖位為零的塊，表示它是空閒的。如果balloc找到這樣的塊，它會更新位圖並返回該塊。為了提高效率，循環被分成兩部分。外部循環讀取位圖位的每個塊。內部循環檢查單個位圖塊中的所有逐塊位（BPB）位。如果兩個進程試圖同時分配一個塊，可能會發生爭用，這是因為緩衝區緩存每次只允許一個進程使用任何一個位圖塊。

bfree（kernel/fs.c：92）查找正確的位圖塊並清除正確的位。同樣，breadandbrelse隱含的獨占使用避免了顯式鎖定的需要。

與本章剩餘部分描述的大部分代碼一樣，ballocandbfree必須在事務內部調用。

### 8.8 Inode layer

Terminodecan有兩個相關含義之一。它可能是指磁碟上的數據結構，包含文件的大小和數據塊編號列表。或者"inode"可能指內存中的inode，它包含磁碟上inode的複本以及內核中所需的額外信息。磁碟上的inode被打包到稱為inode塊的連續磁碟區域中。每個inode都是相同的大小，所以很容易找到磁碟上的第n個inode。實際上，這個數字n，稱為inode編號或i-number，是在實現中標識inode的方式。磁碟上的inode由astruct dinode（kernel/fs. h：32）定義。類型欄位區分文件、目錄和特殊文件（設備）。類型為零表示磁碟上的信息節點是空閒的. thenlink欄位計算引用此inode的目錄條目的數量，以便識別何時應該釋放磁碟上的inode及其數據塊。 sizefield記錄文件中內容的字節數。addrsarray記錄保存文件內容的磁碟塊的塊號。內核將活動inode的集合保存在內存中一個名為「可調用」的表中;struct inode（kernel/file.h：17）是磁碟上struct dinodeon的內存複本。只有當有C指針指向一個inode時，內核才會將該inode存儲在內存中。Thereffield計數指向內存中inode的C指針的數量，如果引用計數降為零，內核將從內存中丟棄該inode。igetandiput函數獲取和釋放指向一個inode的指針，修改引用計數。指向inode的指針可以來自文件描述符、當前工作目錄和臨時內核代碼（如exec）。在xv 6的inode code. itable中有四種鎖或類似鎖的機制。鎖保護一個inode在inode表中最多出現一次的不變量，以及一個內存inode的sref欄位計數指向該inode的內存指針的數量的不變量。每個內存中的inode都有一個包含sleep-lock的lockfield，它確保對inode欄位（如文件長度）以及inode文件或目錄內容塊的獨占訪問。如果inode'sref大於零，則會導致系統在表中維護該inode，而不會將表條目重新用於不同的inode。最後，每個inode都包含一個linkfield（在磁碟上，如果在內存中，則複製到內存中），它計算引用文件的目錄條目的數量;如果inode的連結計數大於零，xv 6將不會釋放它。iget（）返回的struct inodepointer保證在相應的toiput（）調用之前是有效的; inode不會被刪除，指針所引用的內存也不會重新用於不同的inode。iget（）提供對inode的非獨占訪問，因此可以有許多指向同一inode的指針。文件系統代碼的許多部分都依賴於iget（）的這種行為，既可以保持對inode的長期引用（作為打開的文件和當前目錄），也可以防止競爭，同時避免操作多個inode的代碼中的死鎖（例如路徑名查找）。返回次數最多的結構可能沒有任何有用的內容。為了確保它擁有磁碟上inode的複本，代碼必須調用ilock。這將鎖定inode（這樣就沒有其他進程可以執行inilockit），並從磁碟讀取inode（如果還沒有讀取）。iunlock釋放inode上的鎖。將索引節點指針的獲取與鎖定分離有助於避免某些情況下的死鎖，例如在目錄查找期間。 多個進程可以容納一個

C指針指向由iget返回的信息節點，但一次只能有一個進程鎖定該信息節點。inode表只存儲內核代碼或數據結構持有C指針的inode。它的主要工作是同步多個進程的訪問。inode表也會緩存經常使用的inode，但緩存是次要的;如果一個inode經常使用，緩衝區緩存可能會將其保存在內存中。修改內存中inode的代碼會使用iupdate將其寫入磁碟。

### 8.9 Code: Inodes

要分配新的inode（例如，在創建文件時），xv 6調用sialloc（kernel/fs.c：199）。iallocis類似於toballoc：它在磁碟上的inode結構上循環，一次一個塊，尋找一個標記為空閒的。當它找到一個時，它通過將new類型寫入磁碟來聲明它，然後從inode表中返回一個條目，並使用尾調用toiget（kernel/fs.c：213）。alloc的正確操作取決於一次只能有一個進程持有一個引用。p：alloc可以確保其他一些進程不會同時看到inode可用並試圖聲明它。iget（kernel/fs.c：247）在inode表中查找具有所需設備和inode號的活動條目（ip->ref > 0）。如果它找到一個inode，它將返回一個新的inode引用（kernel/fs.c：256-260）。Asigetscans，它記錄第一個空插槽的位置（kernel/fs.c：261- 262），如果需要分配表條目，它會使用該位置。 在閱讀或寫其元數據或內容之前，代碼必須使用ilock鎖定inode。ilock（kernel/fs.c：293）為此使用sleep-lock。一旦鎖對inode具有獨占訪問權，如果需要，它將從磁碟（更可能是緩衝區緩存）讀取inode。函數iunlock（kernel/fs.c：321）釋放sleep-lock，這可能會喚醒任何正在睡眠的進程。iput（kernel/fs.c：337）通過減少引用計數（kernel/fs.c：360）釋放指向inode的C指針。如果這是最後一次引用，則inode表中的inode插槽現在是空閒的，可以重新用於其他inode。如果inode沒有C指針引用，並且inode沒有連結到它（出現在任何目錄中），則必須釋放inode及其數據塊。iputcallsitrunc將文件截斷為零字節，釋放數據塊;將inode類型設置為0（未分配）;並將inode寫入磁碟（kernel/fs.c：342）。 在釋放inode的情況下，鎖定協議inputing值得仔細研究。一個危險是並發線程可能正在等待inilock以使用此inode（例如，讀取文件或列出目錄），並且不會準備發現不再分配inode。這是不可能發生的，因為如果系統調用沒有指向內存中inode的連結並且dip->ref是一個，那麼它就沒有辦法獲得指向該inode的指針。這個引用是調用iput的線程所擁有的引用。另一個主要的危險是，對ialloc的並發調用可能會選擇iput正在釋放的同一個inode。只有在iUpdate寫入磁碟以使inode具有類型零之後，才會發生這種情況。這場比賽是良性的;在閱讀或寫inode之前，分配線程將禮貌地等待獲取inode的睡眠鎖，在這一點上，iput（）可以寫入磁碟。 這意味著任何使用文件系統的系統調用都可以寫入磁碟，因為系統調用可能是最後一個引用文件的調用。 甚至

看似只讀的likead（）調用最終可能會調用iput（）。這反過來意味著，即使是只讀系統調用，如果使用文件系統，也必須包裝在事務中。iput（）和crashes之間存在一個具有挑戰性的交互。iput（）不會在文件的連結計數降為零時立即截斷文件，因為某些進程可能仍然在內存中持有對inode的引用：一個進程可能仍然在閱讀和寫文件，因為它成功地打開了它。但是，如果在最後一個進程關閉文件的文件描述符之前發生崩潰，那麼這個文件將被標記為已分配到磁碟上，但是沒有目錄條目指向它。2文件系統以兩種方式之一來處理這種情況。簡單的解決方案是，在恢復時，重新引導後，文件系統掃描整個文件系統，查找標記為已分配但沒有指向它們的目錄條目的文件。如果存在任何這樣的文件，那麼它可以釋放這些文件。 第二種解決方案不需要掃描文件系統。在該解決方案中，文件系統記錄在磁碟上（例如，在超級塊中）連結計數降為零但引用計數不為零的文件的inode編號。如果文件系統在其引用計數達到0時刪除該文件，則它會通過從列表中刪除該inode來更新磁碟上的列表。恢復時，文件系統將釋放列表中的所有文件。Xv6沒有實現這兩種解決方案，這意味著inode可能會在磁碟上標記為已分配，即使它們不再使用。這意味著隨著時間的推移，xv6可能會面臨磁碟空間耗盡的風險。

### 8.10 Code: Inode content

磁碟上的inode結構（struct dinode）包含大小和塊號數組（請參見圖8.3）。inode數據位於inode的saddrs數組中列出的塊中。前NDIECT數據塊列在數組的前NDIECT條目中;這些塊稱為直接塊。下一個NINDIRECT數據塊不在inode中列出，而是在一個稱為間接塊的數據塊中列出。addrs數組中的最後一項給出了間接塊的地址。因此，文件的前12 kB（NDIRECT x BSIZE）字節可以從inode中列出的塊加載，而接下來的256 kB（NINDIRECT x BSIZE）字節只能在諮詢間接塊後加載。這是一個很好的磁碟表示，但對客戶端來說是一個複雜的表示。函數bmap管理表示，以便更高級別的例程，如readi和writei，我們很快就會看到，不需要管理這種複雜性。bmap為inodeip預取第bn個數據塊的磁碟塊號。 如果fip還沒有這樣的塊，bmapallocates一個。函數bmap（kernel/fs.c：383）從簡單的情況開始：第一個NDIRECT塊在inode本身中列出（kernel/fs.c：388-396）。下一個NINDIRECTblocks列在間接塊atip->addrs\[NDIRECT\]中。bmap先讀取間接塊（kernel/fs.c：407），然後從塊內的右側位置讀取塊編號（kernel/fs.c：408）。如果塊號為NDIRECT +NINDIRECT，則bmappanics; write將包含防止這種情況發生的檢查（kernel/fs.c：513）。bmap根據需要分配塊。Anip->addrs\[\]或零的間接條目指示沒有分配塊。當bmap遇到零時，它會將其替換為按需分配的新塊數（kernel/fs.c：389-390）（kernel/fs.c：401-402）。itrunc釋放文件的塊，將inode的大小重置為零。itrunc（kernel/fs.第426章開始

type
major
minor
nlink
size
address 1


address 12
indirect


dinode


address 1


address 256


indirect block


data


data


data


data


Figure 8.3: The representation of a file on disk.


釋放直接塊（kernel/fs.c：432-437），然後釋放間接塊中列出的塊（kernel/fs.c：442- 445），最後釋放間接塊本身（kernel/fs.c：447-448）。bmap使得讀取和寫入inode的數據變得容易。readi（kernel/fs.c：472）通過確保偏移量和計數不超過文件的結尾來啟動。從文件末尾開始的讀取返回錯誤（kernel/fs.c：477-478），而從文件末尾開始或跨越文件末尾的讀取返回的字節數少於請求的字節數（kernel/fs.c：479-480）。writei（kernel/fs. c：506）與readi相同，但有三個例外：從文件末尾開始或穿過文件末尾的寫入會使文件增大，直到最大文件大小（kernel/fs. c：513-514）;循環將數據複製到緩衝區而不是輸出（kernel/fs. c：522）;如果寫入擴展了文件，writei必須更新其大小（kernel/fs.c：530-531）。 函數stati（kernel/fs.c：458）將inode元數據複製到statstructure中，statstructure通過statsystem調用暴露給用戶程式。

### 8.11編碼：目錄層

目錄的內部實現非常類似於文件。它的inode類型為T\_DIR，它的數據是一個目錄條目序列。每個條目都是astruct dirent（kernel/fs.h：56），其中包含一個

名稱和inode編號。名稱最多為DIRSIZ（14）個字符;如果更短，則以NULL（0）字節結束。inode號為零的目錄條目是空閒的。functiondirlookup（kernel/fs.c：552）在目錄中搜索具有給定名稱的條目。如果找到了，它將返回一個指向相應inode的指針（未鎖定），並將poff設置_為字節 目錄中條目的偏移量，以備調用方希望編輯它。Ifdirlookup查找 具有正確名稱的條目，它更新_poff並返回通過viaiget獲得的未鎖定的inode。dirlookup是返回unlocked inode的原因。調用者具有lockeddp，因此如果查找的是.，當前目錄的別名，如果在返回之前嘗試鎖定inode，將嘗試重新鎖定dpand死鎖。（還有更複雜的死鎖場景，涉及多個進程和..，父目錄的別名;.不是唯一的問題。）調用者可以先解鎖dp，然後解鎖lockip，確保它一次只持有一個鎖。函數dirlink（kernel/fs.c：580）將具有給定名稱和節點號的新目錄條目寫入directorydp。如果該名稱已經存在，則dirlink返回一個錯誤（kernel/fs.c：586- 590）。主循環讀取目錄條目，查找未分配的條目。當它找到一個時，它會提前停止循環（kernel/fs.c：592-597），並將offset設置為可用條目的偏移量。否則，循環以偏移量todp->size結束. 無論哪種方式，dirlink都會通過在offsetoff（kernel/fs.c：602-603）處寫入來向目錄中添加新條目。

### 8.12 Code: Path names

路徑名查找涉及一系列對dirlookup的調用，每個路徑組件一個。namei（kernel/fs.c：687）計算並返回相應的inode。函數nameiparent是一個變體：它在最後一個元素之前停止，返回父目錄的inode並將最後一個元素複製為name。兩者都調用廣義函數名ex來完成真實的工作。namex（kernel/fs.c：652）首先決定路徑計算從何處開始。如果路徑以斜槓開頭，則從根目錄開始計算;否則，從當前目錄（kernel/fs.c：656-659）開始計算。然後它使用kipelem依次考慮路徑的每個元素（kernel/fs.c：661）。循環的每次疊代都必須在當前inodeip中查找name。疊代首先鎖定ip並檢查它是否是一個目錄。如果否，查找將失敗（kernel/fs.c：662-666）。（鎖定ip是必要的，不是因為ip-%3 E類型可以在下面更改-它不能-而是因為在鎖定運行之前，不能保證ip-%3 E類型已從磁碟加載。如果調用是nameiparent，這是最後一個路徑元素，循環會提前停止，根據nameiparent的定義;最後一個路徑元素已經被複製到name中，sonamex只需要返回未鎖定的dip（kernel/fs.c：667-671）。最後，循環使用dirlookup查找path元素，並通過設置ip = next（kernel/fs.c：672-677）為下一次疊代做準備。當循環用完路徑元素時，它返回sip。此過程可能需要很長時間才能完成：它可能涉及多個磁碟操作，以讀取路徑名中遍歷的目錄的inode和目錄塊（如果它們不在緩衝區緩存中）。Xv 6是精心設計的，如果一個內核線程調用namex在磁碟I/O上被阻塞，另一個內核線程查找不同的路徑名可以同時進行。namex單獨鎖定路徑中的每個目錄，以便在不同目錄中的查找可以並行進行。這種並發性帶來了一些挑戰。 例如，當一個內核線程正在查找

另一個內核線程可能通過取消連結目錄來改變目錄樹。一個潛在的風險是，查找可能正在搜索已被另一個內核線程刪除的目錄，並且其塊已被另一個目錄或文件重用。Xv6避免這樣的比賽。例如，當執行dirlookupinnamex時，查找線程持有目錄上的鎖，而dirlookuppreturn是使用iget獲得的inode。iget增加inode的引用計數。只有在接收到來自dirlookup的inode之後，namex才會釋放目錄上的鎖。現在，另一個線程可以從目錄中取消inode的連結，但xv6不會刪除inode，因為inode的引用計數仍然大於零。另一個風險是僵局。例如，查找「「時，nextpoints指向同一個inode asip。".在釋放對ip的鎖之前鎖定next將導致死鎖。為了避免這種死鎖，namex在獲得onnext鎖定之前先解鎖目錄。 在這裡我們再次看到為什麼igetandilock之間的分離是重要的。

### 8.13 File descriptor layer

Unix接口的一個很酷的方面是，Unix中的大多數資源都表示為文件，包括控制台、管道等設備，當然還有真實的文件。文件描述符層是實現這種一致性的層。Xv 6為每個進程提供了自己的打開文件表，或者文件描述符，正如我們在第1章中看到的。每個打開的文件都由一個結構文件（kernel/file.h：1）表示，它是一個inode或管道的包裝器，加上一個I/O偏移量。每次調用都將創建一個新的打開文件（一個newstruct文件）：如果多個進程獨立地打開同一個文件，那麼不同的實例將具有不同的I/O偏移量。另一方面，單個打開的文件（samestruct文件）可以在一個進程的文件表中多次出現，也可以在多個進程的文件表中多次出現。如果一個進程使用open打開文件，然後使用dupor創建別名，或者使用fork與子進程共享，就會發生這種情況。 引用計數跟蹤對特定打開文件的引用數。文件可以打開以進行閱讀或寫入，或者同時進行這兩種操作。readable和writable欄位跟蹤此內容。系統中所有打開的文件都保存在一個全局文件表theftable中。文件表具有分配文件（filealloc）、創建重複引用（filedup）、釋放引用（fileclose）以及讀取和寫入數據（filereadandfilewrite）的函數。前三個遵循現在熟悉的形式。filealloc（kernel/file.c：30）掃描文件表中未引用的文件（f->ref == 0）並返回一個新的引用;filedup（kernel/file.c：48）增加引用計數; fileclose（kernel/file.c：60）減少引用計數。當文件的引用計數達到零時，fileclose根據類型釋放底層管道或inode。filestat、fileread和filewrite函數實現了對文件的stat、read和write操作。filestat（kernel/file.c：88）只允許在inode和callsstati上使用。fileread和filewrite檢查open模式是否允許該操作，然後將調用傳遞給管道或inode實現。如果文件表示一個inode，fileread和filewrite使用I/O偏移量作為操作的偏移量，然後將其向前移動（kernel/file.c：122- 123）（kernel/file.c：153-154）。管道沒有偏移的概念。 回想一下，inode函數需要

調用者處理鎖定（kernel/file.c：94-96）（kernel/file.c：121-124）（kernel/file.c：163-166）。節點內鎖定具有方便的副作用，即讀取和寫入偏移量被原子地更新，因此同時對同一文件的多個寫入不能覆蓋彼此的數據，儘管它們的寫入可能以交錯的方式結束。

### 8.14 Code: System calls

使用較低層提供的函數，大多數系統調用的實現都是微不足道的（參見（kernel/sysfile.c））。有幾個電話值得仔細研究。函數sys\_linkandsys\_unlinkedit目錄，創建或刪除對信息節點的引用。sys\_link（kernel/sys-file.c：124）從獲取它的參數開始，兩個stringsoldandnew（kernel/sysfile.c：129）。假設存在舊目錄並且不是目錄（kernel/sysfile.c：133-136），sys\_link將遞增它的sip-%3 Enlink計數。然後sys\_link調用name parent來查找new的父目錄和最終路徑元素（kernel/sysfile.c：149），並創建一個指向old的inode的新目錄條目（kernel/sys-file.c：152）。新的父目錄必須存在，並且與現有的inode位於同一個設備上：inode編號在單個磁碟上只有唯一的含義。如果發生類似的錯誤，sys\_link必須返回並遞減tip->nlink。 事務簡化了實現，因為它需要更新多個磁碟塊，但我們不必擔心執行它們的順序。他們要麼都成功，要麼都失敗。例如，如果沒有transactions，在創建連結之前更新ip->nlink會使文件系統暫時處於不安全狀態，而在此期間發生的崩潰可能會導致嚴重破壞。通過交易，我們不必擔心這一點。sys\_link為現有inode創建新名稱。函數create（kernel/sysfile.c：246）為新的inode創建一個新的名稱。它是三個文件創建系統調用的概括：openwith the O\_CREATEflag創建一個新的普通文件，mkdir創建一個新目錄，mkdev創建一個新設備文件。與ys\_link一樣，SQL Server通過調用name\_parent來獲取父目錄的inode。然後它調用sdirlookup來檢查該名稱是否已經存在（kernel/sysfile.c：256）。 如果名稱確實存在，create的行為取決於它被用於哪個系統調用：open與mmkdir和mkdev有不同的語義。如果使用的是open（type == T\_FILE）的名字，並且這個名字本身就是一個普通的文件，那麼open會認為這是一個成功，soc也會這樣做（kernel/sysfile.c：260）。否則，它是一個錯誤（kernel/sysfile.c：261-262）。如果這個名稱不存在，那麼SQL Server現在會使用ialloc（kernel/sysfile.c：265）分配一個新的inode。如果新的inode是一個目錄，請使用.和.將其重新命名。條目最後，既然數據已經正確初始化，那麼Linux可以將其連結到父目錄（kernel/sysfile.c：278）。不可能出現死鎖，因為inodeip是新分配的：系統中沒有其他進程會持有dip的鎖，然後試圖鎖定dp。使用create，可以很容易地實現sys\_open、sys\_mkdir、和sys\_mknod.sys\_open（內核/sys文件。c：305）是最複雜的，因為創建一個新文件只是它所能做的一小部分。如果openis傳遞了O\_CREATE標誌，它將調用create（kernel/sysfile.c：320）。否則，它將調用snamei（kernel/sysfile.c：326）。返回鎖定的inode，但name不返回，sosys\_open

必須鎖定inode本身。這提供了一個方便的位置來檢查目錄是否只打開用於閱讀而不是寫。假設inode是通過某種方式獲得的，sys\_open分配一個文件和一個文件描述符（kernel/sysfile.c：344），然後填充該文件（kernel/sysfile.c：356- 361）。請注意，沒有其他進程可以訪問部分初始化的文件，因為它只在當前進程的表中。第7章研究了在我們有文件系統之前管道的實現。函數sys\_pipe通過提供一種創建管道對的方法將該實現連接到文件系統。它的參數是一個指向兩個整數的空間的指針，它將記錄兩個新的文件描述符。然後分配管道並安裝文件描述符。

### 8.15 Real world

實際作業系統中的緩衝區緩存要比xv 6複雜得多，但它有兩個相同的用途：緩存和同步對磁碟的訪問。Xv 6的緩衝區緩存與V6的緩存一樣，使用簡單的最近最少使用（LRU）驅逐策略;還有許多更複雜的策略可以實現，每種策略都適用於某些工作負載，而對其他工作負載則沒有那麼好。更有效的LRU緩存將消除鍊表，而不是使用哈希表進行查找和堆進行LRU回收。現代緩衝區高速緩存通常與虛擬內存系統集成，以支持內存映射文件。Xv 6的日誌系統效率很低。提交不能與文件系統系統調用並發發生。系統會記錄整個數據塊，即使數據塊中只有幾個字節發生了更改。它執行同步日誌寫入，一次一個塊，每次都可能需要整個磁碟旋轉時間。真實的日誌系統解決了所有這些問題。 日誌記錄並不是提供崩潰恢復的唯一方法。早期的文件系統在重新啟動時使用清道夫（例如，UNIXfsck程式）來檢查每個文件和目錄以及塊和inode空閒列表，查找並解決不一致性。對於大型文件系統，清理可能需要數小時，並且在某些情況下，不可能以導致原始系統調用為原子的方式解決不一致性。從日誌中恢復要快得多，並且在崩潰時會導致系統調用原子化。Xv 6使用與早期UNIX相同的inode和目錄的基本磁碟布局;這種方案已經持續了很多年。BSD的UFS/FFS和Linux的ext 2/ext 3使用埃森相同的數據結構。文件系統布局中效率最低的部分是目錄，它需要在每次查找期間對所有磁碟塊進行線性掃描。 當目錄只有幾個磁碟塊時，這是合理的，但對於包含許多文件的目錄來說，這是昂貴的。Microsoft Windows的NTFS，macOS的HFS和Solaris的NTFS，僅舉幾例，將目錄實現為磁碟上的塊平衡樹。這是複雜的，但保證查詢時間的目錄查找。Xv6對磁碟故障的處理是幼稚的：如果磁碟操作失敗，xv6就會恐慌。這是否合理取決於硬體：如果作業系統位於使用冗餘來掩蓋磁碟故障的特殊硬體之上，那麼作業系統可能很少看到故障，因此恐慌是可以的。 另一方面，使用普通磁碟的作業系統應該預料到故障，並更優雅地處理它們，這樣一個文件中的塊丟失不會影響其餘文件的使用。

文件系統Xv6要求文件系統適合一個磁碟設備，並且大小不變。隨著大型資料庫和多媒體文件對存儲的要求越來越高，作業系統正在努力消除「每個文件系統一個磁碟」的瓶頸。基本的方法是將聯合收割機許多磁碟組合成一個邏輯磁碟。RAID等硬體解決方案仍然是最受歡迎的，但目前的趨勢是儘可能多地在軟體中實現這種邏輯。這些軟體實現通常允許豐富的功能，例如通過動態添加或刪除磁碟來擴展或縮小邏輯設備。當然，一個可以動態增長或收縮的存儲層需要一個可以做到這一點的文件系統：xv6使用的固定大小的inode塊陣列在這樣的環境中不能很好地工作。 將磁碟管理與文件系統分離可能是最簡潔的設計，但兩者之間複雜的接口已經導致一些系統（如Sun的Linux）將它們聯合收割機結合起來。Xv 6的文件系統缺乏現代文件系統的許多其他特性;例如，它缺乏對快照和增量備份的支持。現代Unix系統允許使用與磁碟存儲相同的系統調用來訪問多種資源：命名管道、網絡連接、遠程訪問的網絡文件系統以及諸如/proc之類的監視和控制接口。代替xv 6的sif語句infileread和filewrite，這些系統通常給每個打開的文件一個函數指針表，每個操作一個，並調用函數指針來調用該inode的調用實現。網絡文件系統和用戶級文件系統提供的函數將這些調用轉換為網絡RPC，並在返回之前等待響應。

### 8.16 Exercises

1. 為什麼要恐慌呢？xv 6能恢復嗎？
2. 為什麼要恐慌inialloc？xv 6能恢復嗎？
3. 為什麼當文件用完時，fileallocpanic不會出現問題？為什麼這是更常見的，因此值得處理？
4. 假設與ip對應的文件在sys\_link調用iunlock（ip）和dirlink之間被另一個進程取消連結。連結是否正確創建？為什麼或為什麼不呢？
5. MySQL進行了四次成功所需的函數調用（一次是toialloc，三次是toDirlink）。如果沒有，就創建一個西班牙語。為什麼這是可以接受的？為什麼這四個電話都不會失敗？
6. sys\_chdir在iput（cp->cwd）之前調用siunlock（ip），這可能會嘗試鎖定cp->cwd，但將inunlock（ip）推遲到iput之後不會導致死鎖。為什麼不呢？
7. 實現elseek系統調用。支持lseek還需要修改filewrite，以在文件中填充零個漏洞，如果flseeksetsoffbeyondf->ip->size。
8. 將O\_TRUNC和O\_APPEND添加到open，以便>和>>運算符在shell中工作。
9. 修改文件系統以支持符號連結。
10. 修改文件系統以支持命名管道。
11. 修改文件和VM系統以支持內存映射文件。

第9章
===

重新審視並發性
=======

同時獲得良好的並行性能、並發情況下的正確性和可理解的代碼是內核設計中的一個很大挑戰。直接使用鎖是實現正確性的最佳途徑，但並不總是可行的。本章重點居間xv6被迫以複雜的方式使用鎖的例子，以及xv6使用類似鎖的技術但不使用鎖的例子。

### 9.1 Locking patterns

緩存項通常很難鎖定。例如，文件系統的塊緩存（ker- nel/bio.c：26）存儲最多個NBUF磁碟塊的複本。重要的是，一個給定的磁碟塊在該高速緩存中最多有一個複本;否則，不同的進程可能會對應該是同一塊的不同複本進行衝突的更改。每個緩存塊都存儲在astruct buf（kernel/buf.h：1）中。Astruct buf有一個鎖欄位，它有助於確保一次只有一個進程使用給定的磁碟塊。但是，這個鎖還不夠：如果一個塊根本不存在於該高速緩存中，而兩個進程想同時使用它，該怎麼辦？有nostruct buf（因為塊還沒有緩存），因此沒有什麼可鎖定的。Xv 6通過將額外的鎖（bcache.lock）與緩存塊的標識集相關聯來處理這種情況。需要檢查塊是否被緩存的代碼（例如，bget（kernel/bio.c：59）），或者更改緩存塊的集合，必須holddbcache。lock;在代碼找到它需要的塊和結構buf之後，它可以釋放ebcache. lock並鎖定特定的塊。這是一個常見的模式：一個鎖用於一組項，再加上每個項一個鎖。

通常，獲取鎖的同一個函數會釋放鎖，但更精確地說，鎖是在一個序列開始時獲取的，序列必須是原子的，當序列結束時釋放鎖。如果序列在不同的函數、不同的線程或不同的CPU上開始和結束，那麼鎖獲取和釋放必須執行相同的操作。鎖的功能是強制其他用戶等待，而不是將一段數據固定到特定的代理。一個例子是acquireinyield（kernel/proc.c：512），它在調度器線程中而不是在獲取進程中釋放。另一個例子是獲取休眠鎖（kernel/fs.c：293）;這段代碼經常在閱讀磁碟時休眠;它可能在不同的CPU上被喚醒，這意味著鎖可能在不同的CPU上被獲取和釋放。

釋放一個受嵌入在對象中的鎖保護的對象是一件微妙的事情，因為擁有鎖並不足以保證釋放是正確的。當其他線程正在等待使用該對象時，就會出現問題;釋放對象會隱式地釋放嵌入的鎖，這將導致等待線程發生故障。一個解決方案是跟蹤存在多少對對象的引用，以便只有當最後一個引用消失時才釋放它。例如，Seepipeclose（kernel/pipe.c：59）;pi->readopen和pi->writeopen跟蹤管道是否有文件描述符引用它。通常，在對相關項集的讀寫序列周圍會看到鎖;這些鎖確保其他線程只看到已完成的更新序列（只要它們也鎖定）。如果更新是對單個共享變量的簡單寫入，情況又如何呢？例如，setkilledandkilled（kernel/proc.c：619）鎖定了p->killed的簡單用法。如果沒有鎖，一個線程可以在另一個線程讀它的同時寫p->killed。這就是一個競爭，C語言規範說競爭會產生未定義的行為，這意味著程式可能會崩潰或產生不正確的結果^\[1\]。鎖可以防止競爭並避免未定義的行為。競爭可能破壞程式的一個原因是，如果沒有鎖或等效的構造，編譯器可能會生成機器代碼，這些代碼以與原始C代碼完全不同的方式讀取和寫入內存。例如，一個名為killed的線程的機器碼可以將p->killed複製到一個寄存器，並只讀取該緩存值;這意味著該線程可能永遠不會看到任何top->killed寫入。鎖防止這樣的緩存。

### 9.2 Lock-like patterns

在很多地方，xv 6以類似鎖的方式使用引用計數或標誌來指示對象已分配，不應釋放或重用。進程sp->state以這種方式工作，文件、索引節點和buf結構中的引用計數也是如此。雖然在每種情況下鎖都保護標誌或引用計數，但正是後者防止對象被過早釋放。

文件系統使用struct inodereference計數作為一種共享鎖，可以由多個進程持有，以避免在代碼使用普通鎖時發生死鎖。例如，循環innamex（kernel/fs.c：652）依次鎖定每個路徑名組件命名的目錄。然而，name必須在循環結束時釋放每個鎖，因為如果它持有多個鎖，如果路徑名包含一個點（例如，a/./ B）。它也可能與涉及目錄和.正如第8章所解釋的，解決方案是循環將目錄inode帶到下一次疊代，其引用計數遞增，但不鎖定。某些數據項在不同的時間由不同的機制保護，並且有時可能通過xv 6代碼的結構而不是通過顯式鎖來隱式地防止並發訪問。例如，當一個物理頁面空閒時，它會受到kall.lock（kernel/kalloc.c：24）的保護。 如果該頁隨後被分配為管道（kernel/pipe.c：23），則它受不同的鎖（em- beddedpi->lock）保護。 如果為新進程的用戶內存重新分配了該頁，則該頁不受保護

（^1）[https://en.cppreference.com/w/c/language/memory\_model](https://en.cppreference.com/w/c/language/memory_model)中的「線程和數據競賽」

一把鎖。相反，分配器不會將該頁面提供給任何其他進程（直到它被釋放），這一事實保護了它免受並發訪問。新進程內存的所有權是複雜的：首先父進程在fork中分配和操作它，然後子進程使用它，並且（在子進程退出後）父進程再次擁有內存並將其傳遞給tokfree。這裡有兩個教訓：可以在數據對象的生存期的不同點以不同的方式保護數據對象免於並發，並且保護可以採取隱式結構而不是顯式鎖的形式。最後一個類似鎖的例子是需要在調用tomycpu（）時禁用中斷（ker- nel/proc.c：83）。禁用中斷會導致調用代碼相對於可能強制上下文切換的定時器中斷是原子的，從而將進程移動到不同的CPU。

### 9.3 No locks at all

有幾個地方xv 6共享可變數據而根本沒有鎖。一個是自旋鎖的實現，儘管人們可以將RISC-V原子指令視為依賴於硬體中實現的鎖。另一個是main.c中的started變量（kernel/main.c：7），用於防止其他CPU運行，直到CPU zero完成初始化xv 6; volatile確保編譯器實際生成加載和存儲指令。Xv 6包含這樣的情況：一個CPU或線程寫入一些數據，另一個CPU或線程讀取數據，但是沒有專門用於保護該數據的特定鎖。例如，在fork中，父線程寫入子線程的用戶內存頁面，子線程（可能在不同的CPU上）讀取這些頁面;沒有鎖顯式地保護這些頁面。嚴格地說，這不是一個鎖定問題，因為子對象直到父對象完成寫入後才開始執行。 這是一個潛在的內存排序問題（參見第6章），因為沒有內存屏障，就沒有理由期望一個CPU看到另一個CPU的寫操作。但是，由於父CPU釋放鎖，而子CPU在啟動時獲取鎖，因此獲取和釋放時的內存屏障確保子CPU看到父CPU的寫入。

### 9.4並行性

鎖定主要是為了正確性而抑制並行性。因為每個鎖也很重要，所以內核設計者經常不得不考慮如何以一種既實現正確性又允許並行性的方式使用鎖。雖然xv 6並不是系統地為高性能而設計的，但仍然值得考慮哪些xv 6操作可以並行執行，哪些操作可能會在鎖上發生衝突。xv 6中的管道是一個相當好的並行性的例子。每個管道都有自己的鎖，因此不同的進程可以在不同的CPU上並行讀取和寫入不同的管道。但是，對於給定的管道，寫入器和讀取器必須等待對方釋放鎖;它們不能同時讀/寫同一個管道。從空管道讀取（或寫入滿管道）也必須阻塞，但這不是由於鎖定方案。上下文切換是一個更複雜的例子。 兩個內核線程（每個線程在自己的CPU上執行）可以同時調用ield、sched和swtchat，並且這些調用將並行執行。

每個線程都持有一個鎖，但它們是不同的鎖，所以它們不必等待對方。然而，一旦進入調度程式，兩個CPU在搜索進程表中的一個進程是RUNNABLE時可能會在鎖上發生衝突。也就是說，xv6可能在上下文切換期間從多個CPU中獲得性能優勢，但可能沒有它所能獲得的那麼多。另一個例子是從不同CPU上的不同進程並發調用fork。調用可能必須等待pid\_lock和kall.lock，以及在進程表中搜索UNUSED進程所需的每個進程鎖。另一方面，這兩個分叉進程可以完全並行地複製用戶內存頁和格式化頁表頁。上述每個示例中的鎖定方案在某些情況下都會犧牲並行性能。在每種情況下，都可以使用更精細的設計來獲得更多的並行性。 它是否值得取決於細節：相關操作被調用的頻率，代碼在爭用鎖上花費的時間，有多少CPU可能同時運行衝突操作，代碼的其他部分是否是更具限制性的瓶頸。很難猜測給定的鎖定方案是否會導致性能問題，或者新的設計是否明顯更好，因此通常需要對實際工作負載進行測量。

### 9.5 Exercises

1. 修改xv6的管道實現，允許對同一管道的讀寫在不同的CPU上並行進行。
2. 修改xv6的scheduler（）以減少不同CPU同時尋找可運行進程時的鎖爭用。
3. 消除xv6的fork（）中的一些序列化。

第10章
====

Summary
=======

本文通過對xv 6作業系統的逐行研究，居間了作業系統的主要思想。一些代碼行體現了主要思想的本質（例如，上下文切換、用戶/內核邊界、鎖等）每一行都很重要其他代碼行提供了如何實現特定作業系統思想的說明並且可以以不同的方式容易地完成（例如，更好的調度算法、更好的表示文件的盤上數據結構、更好的允許並發事務的日誌記錄等）。所有的思想都是在一個特定的、非常成功的系統調用接口--Unix接口--的上下文中闡述的，但是這些思想可以應用到其他作業系統的設計中。

Bibliography
============

[1] Linux common vulnerabilities and exposures (CVEs). https://cve.mitre.org/
cgi-bin/cvekey.cgi?keyword=linux.


[2] The RISC-V instruction set manual Volume I: unprivileged specification ISA. https:
//drive.google.com/file/d/17GeetSnT5wW3xNuAHI95-SI1gPGd5sJ_
/view?usp=drive_link, 2024.


[3] The RISC-V instruction set manual Volume II: privileged specification. https:
//drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/
view?usp=drive_link, 2024.


[4] Hans-J Boehm. Threads cannot be implemented as a library.ACM PLDI Conference, 2005.


[5] Edsger Dijkstra. Cooperating sequential processes. https://www.cs.utexas.edu/
users/EWD/transcriptions/EWD01xx/EWD123.html, 1965.


[6] Maurice Herlihy and Nir Shavit. The Art of Multiprocessor Programming, Revised Reprint.
2012.


[7] Brian W. Kernighan. The C Programming Language. Prentice Hall Professional Technical
Reference, 2nd edition, 1988.


[8] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin,
Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell,
Harvey Tuch, and Simon Winwood. Sel4: Formal verification of an OS kernel. InProceedings
of the ACM SIGOPS 22nd Symposium on Operating Systems Principles, page 207–220, 2009.


[9] Donald Knuth.Fundamental Algorithms. The Art of Computer Programming. (Second ed.),
volume 1. 1997.


\[10\]L Lamport。Dijkstra並發程式設計問題的一種新的解決方案。ACM通訊，1974。

\[11\]John Lions. UNIX第6版評論。Peer to Peer Communications，2000年。

\[12\]Paul E. Mckenney，塞拉斯Boean-wickizer，Jonathan Walpole。RCU在Linux內核中的使用：十年後，2013年。

\[13\]馬丁·麥可和丹尼爾·杜里希。該NS 16550 A：嵌入式設計和應用的考慮。[http://bitsavers.trailing-edge.com/components/national/](http://bitsavers.trailing-edge.com/components/national/) \_appNotes/AN-0491.pdf，1987年。

\[14\]阿萊夫一號為了樂趣和利潤而砸棧。[http://phrack.org/issues/49/](http://phrack.org/issues/49/) 14.html#article.

\[15\]大衛帕特森和安德魯沃特曼。RISC-V閱讀器：一個開放架構的Atlas。草莓峽谷，2017年。

\[16\]戴夫·普賴索托，羅伯·派克，肯·湯普森，還有霍華德·特里克.計劃9，分布式系統。1991年春季歐洲公開賽會議論文集，第43-50頁，1991年。

\[17\]Dennis M.里奇和肯·湯普森。UNIX分時系統Commun. ACM，17（7）：365-375，1974年7月。

Index
=====

#### ., 96, 98

#### .., 96, 98

/init，28，40 \_entry，28

absorption, 90 acquire, 63, 67 address space, 26 argc, 41 argv, 41 atomic, 63

balloc, 91, 93 batching, 89 bcache.head, 87 begin\_op, 90 bfree, 91 bget, 87 binit, 87 block, 86 bmap, 94 bottom half, 53 bread, 87, 88 brelse, 87, 88 BSIZE, 94 buf, 87 busy waiting, 75 bwrite, 87, 88, 90

chan，76，78 child，10 commit，89 concurrency，59 concurrency control，59

condition lock, 77
conditional synchronization, 75
conflict, 62
contention, 62
contexts, 72
convoys, 82
copy-on-write (COW) fork, 49
copyinstr, 47
copyout, 41
coroutines, 74
CPU, 9
cpu->context, 72, 73
crash recovery, 85
create, 98
critical section, 62
current directory, 17


deadlock, 64
demand paging, 50
direct blocks, 94
direct memory access (DMA), 56
dirlink, 96
dirlookup, 96, 98
DIRSIZ, 96
disk, 87
driver, 53
dup, 97


ecall, 23, 27
ELF format, 40
ELF_MAGIC, 40
end_op, 90
exception, 43
exec, 12–14, 28, 41, 47


exit, 11, 79

file descriptor, 13 filealloc, 97 fileclose, 97 filedup, 97 fileread, 97, 100 filestat, 97 filewrite, 91, 97, 100 fork, 10, 12–14, 97 forkret, 74 freerange, 37 fsck, 99 fsinit, 91 ftable, 97

getcmd，12組提交，89保護頁，35

handler, 43 hartid, 74

I/O，13 I/O並發，55 I/O重定向，14 ialloc，93，98 iget，92，93，96 ilock，92，93，96間接塊，94 initcode.S，28，47 initlog，91 inode，18，86，92 install\_transs，91接口設計，9中斷，43 iput，92，93隔離，21 itable，92 itrunc，93，94 iunlock，93

kalloc, 38 kernel, 9, 23

kernel space, 9, 23
kfree, 37
kinit, 37
kvminit, 36
kvminithart, 36
kvmmake, 36
kvmmap, 36


lazy allocation, 49
links, 18
loadseg, 40
lock, 59
log, 89
log_write, 90
lost wake-up, 76


machine mode, 23
main, 36, 37, 87
malloc, 13
mappages, 36
memory barrier, 68
memory model, 68
memory-mapped, 35, 53
memory-mapped files, 50
metadata, 18
microkernel, 24
mkdev, 98
mkdir, 98
mkfs, 86
monolithic kernel, 21, 23
multi-core, 21
multiplexing, 71
multiprocessor, 21
mutual exclusion, 61
mycpu, 74
myproc, 74


namei, 40, 98
nameiparent, 96, 98
namex, 96
NBUF, 87
NDIRECT, 94
NINDIRECT, 94


#### O\_CREATE, 98

open, 97, 98

p->killed，80 p->kstack，27 p->lock，73，74，78 p->pagetable，27 p->state，27 p->xxx，27 page，31 page table entries（PTE），31 pagefault exception，32，49 paging area，50 paging to disk，50 parent，10 path，17 persistence，85 PGROUNDUP，37 physical address，26 PHYSTOP，36，37 PID，10 pipe，16 piperead，79 pipewwrite，79 polling，56，75 pop\_off，67 printf，12 priority inversion，82 privileged instructions，23 proc\_mapstacks，36 proc\_pagetable，40 process，9，26 programmed I/O，56 PTE\_R，33 PTE\_U，33 PTE\_V，33 PTE\_W，33 PTE\_X，33 push\_off，67

race, 61, 104 re-entrant locks, 66 read, 97

readi, 40, 94, 95
recover_from_log, 91
recursive locks, 66
release, 63, 67
root, 17
round robin, 82
RUNNABLE, 78, 79


satp, 33
sbrk, 13
scause, 44
sched, 72–74, 78
scheduler, 73, 74
sector, 86
semaphore, 75
sepc, 44
sequence coordination, 75
serializing, 62
sfence.vma, 37
shell, 10
signal, 83
skipelem, 96
sleep, 76–78
sleep-locks, 68
SLEEPING, 78
sret, 27
sscratch, 44
sstatus, 44
stat, 95, 97
stati, 95, 97
struct context, 72
struct cpu, 74
struct dinode, 92, 94
struct dirent, 95
struct elfhdr, 40
struct file, 97
struct inode, 92
struct pipe, 79
struct proc, 27
struct run, 37
struct spinlock, 63
stval, 49
stvec, 44


超級塊，86管理模式，23開關，72-74系統調用，47系統連結，98系統mkdir，98系統mknod，98系統打開，98系統管道，99系統睡眠，67系統取消連結，98系統調用，47系統調用，9

T\_FILE，95 T\_FILE，98線程，27雷鳴群，82滴答，67滴答鎖，67分時，10，21上半部分，53 TRAMPOLINE，45蹦床，27，45 transaction，85 Translation Look-aside Buffer（TLB），32，36 transmission complete，54 trap，43

trapframe, 27
type cast, 37


UART, 53
undefined behavior, 104
unlink, 90
user memory, 26
user mode, 23
user space, 9, 23
usertrap, 72
ustack, 41
uvmalloc, 40, 41


valid, 87
vector, 43
virtio_disk_rw, 87, 88
virtual address, 26


wait, 11, 12, 79
wait channel, 76
wakeup, 65, 76, 78
walk, 36
walkaddr, 40
write, 90, 97
writei, 91, 94, 95


yield, 72, 73


ZOMBIE, 80


