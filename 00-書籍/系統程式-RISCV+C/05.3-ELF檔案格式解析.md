### ELF 檔案格式解析

**ELF（Executable and Linkable Format）** 是一種用於執行檔案、物件檔案和共享庫的檔案格式。它被廣泛應用於許多操作系統中，特別是在類 Unix 系統（如 Linux）中，作為編譯後檔案的標準格式。ELF 格式的設計使得它既能夠支援靜態連結，也能支援動態連結，並且具有高度的可擴展性。理解 ELF 檔案格式對於編寫編譯器、連結器、以及開發調試工具至關重要。

### 1. **ELF 格式概述**

ELF 檔案分為兩大類型：**可執行檔案（Executable）** 和 **共享物件檔案（Shared Object，通常是 .so 檔案）**。這些檔案包含了程式碼、資料、符號表、重定位資訊等。

ELF 檔案主要由以下幾個部分構成：

- **ELF Header**（檔案頭）
- **Program Header Table**（程式頭表）
- **Section Header Table**（區段頭表）
- **Sections**（區段）

### 2. **ELF Header（檔案頭）**

ELF 檔案的開頭包含 ELF Header，它提供了檔案的基本資訊，如檔案的類型、格式、架構（32位或64位）、端序（大端序或小端序）、檔案的標誌位等等。這些資訊對於讀取和解析 ELF 檔案至關重要。

ELF Header 的結構如下：

| 欄位名               | 說明                                  |
|----------------------|---------------------------------------|
| `e_ident[EI_MAG]`     | 檔案的魔術數字，確認是 ELF 檔案       |
| `e_ident[EI_CLASS]`   | 位數類型：32 位或 64 位              |
| `e_ident[EI_DATA]`    | 位元組順序（小端序或大端序）          |
| `e_ident[EI_VERSION]` | ELF 檔案版本號                        |
| `e_ident[EI_OSABI]`   | 操作系統/平台 ABI（例如，Linux）      |
| `e_type`              | 檔案類型：可執行檔、物件檔或共享檔案  |
| `e_machine`           | 目標架構（例如，RISC-V 或 x86）       |
| `e_version`           | 檔案版本號                            |
| `e_entry`             | 進入點地址，程式開始執行的地方        |
| `e_phoff`             | 程式頭表的偏移量                      |
| `e_shoff`             | 區段頭表的偏移量                      |
| `e_flags`             | 特定於目標架構的標誌                  |
| `e_ehsize`            | ELF 檔案頭的大小                      |
| `e_phentsize`         | 程式頭表中每個條目的大小              |
| `e_phnum`             | 程式頭表中的條目數量                  |
| `e_shentsize`         | 區段頭表中每個條目的大小              |
| `e_shnum`             | 區段頭表中的條目數量                  |
| `e_shstrndx`          | 區段名稱字串表的索引                  |

### 3. **Program Header Table（程式頭表）**

程式頭表描述了可執行檔案的不同程式區段（如程式碼區段、資料區段等）的位置和大小。每一個條目描述一個程式區段，告訴操作系統如何加載這些區段到內存中。

程式頭表的每個條目（Program Header）結構如下：

| 欄位名       | 說明                                  |
|--------------|---------------------------------------|
| `p_type`     | 程式區段的類型（如載入區段、動態區段等）|
| `p_offset`   | 程式區段在檔案中的偏移量              |
| `p_vaddr`    | 程式區段在虛擬內存中的起始地址        |
| `p_paddr`    | 程式區段在物理內存中的起始地址        |
| `p_filesz`   | 程式區段在檔案中的大小                |
| `p_memsz`    | 程式區段在內存中的大小                |
| `p_flags`    | 程式區段的訪問權限（如可讀、可寫、可執行）|
| `p_align`    | 程式區段在內存中的對齊要求           |

#### 常見的程式區段類型（p_type）：
- `PT_LOAD`：可載入的區段，如程式碼區段（.text）、資料區段（.data）。
- `PT_DYNAMIC`：動態鏈接資訊，包含與共享庫和動態鏈接器有關的數據。
- `PT_INTERP`：指向動態鏈接器的路徑（例如 `ld.so`）。
- `PT_NOTE`：包含檔案標註的資訊。
- `PT_PHDR`：包含程式頭表本身。

### 4. **Section Header Table（區段頭表）**

區段頭表描述了 ELF 檔案中的各個區段（sections），這些區段包含了程式的具體內容，如程式碼、資料、符號表等。每個區段都會有一個對應的區段頭，描述該區段的屬性、大小、偏移等資訊。

區段頭表的每個條目（Section Header）結構如下：

| 欄位名        | 說明                                  |
|---------------|---------------------------------------|
| `sh_name`     | 區段名稱的索引（在區段名稱字串表中的位置）|
| `sh_type`     | 區段的類型（如程式碼、資料、符號表等） |
| `sh_flags`    | 區段的屬性（如可讀、可寫、可執行）     |
| `sh_addr`     | 區段在內存中的起始地址                |
| `sh_offset`   | 區段在檔案中的偏移量                  |
| `sh_size`     | 區段的大小                            |
| `sh_link`     | 與該區段相關聯的另一區段的索引        |
| `sh_info`     | 用於補充區段的資訊（根據區段類型而定） |
| `sh_addralign`| 區段的對齊要求                        |
| `sh_entsize`  | 區段內部每個條目的大小                |

#### 常見的區段類型（sh_type）：
- `SHT_PROGBITS`：包含程式碼和資料的區段。
- `SHT_SYMTAB`：符號表區段，包含符號的定義和位置信息。
- `SHT_STRTAB`：字串表區段，儲存符號名稱和其他字串。
- `SHT_RELA`：重定位條目區段，包含重定位資訊。
- `SHT_DYNSYM`：動態符號表區段，包含動態鏈接的符號。

### 5. **Sections（區段）**

ELF 檔案中的區段包含了實際的程式代碼、資料、符號表等資訊，區段名稱通常在 `.text`（程式碼區段）、`.data`（資料區段）、`.bss`（未初始化的資料區段）等地方出現。每個區段都有其對應的區段頭，並由區段頭表來管理。

常見的區段有：

- **.text**：程式碼區段，包含可執行代碼。
- **.data**：資料區段，包含已初始化的全域變數。
- **.bss**：未初始化的資料區段，包含未初始化的全域變數。
- **.symtab**：符號表區段，儲存符號的資訊。
- **.strtab**：字串表區段，包含符號名稱和其他字串。

### 6. **符號表與重定位資訊**

ELF 檔案中的 **符號表**（.symtab）包含了程式中所有符號的資訊，包括變數名、函數名、符號的類型和位置等。**重定位區段**（.rela 或 .rel）包含了需要在運行時進行重定位的符號資訊。

- **符號表**（.symtab）：包含所有的符號條目，描述符號的名稱、類型、地址等。
- **重定位表**（.rel 或 .rela）：描述需要在運行時修改的符號的位址。

### 7. **總結**

ELF 檔案格式是一種高度結構化且靈活的檔案格式，廣泛應用於類 Unix 系統中。它支持靜態和動態鏈接，並且在許多操作系統的運行時環境中發揮著重要作用。理解 ELF 檔案格式對於開發者來說，尤其是處理編譯器、連結器、調試工具和操作系統的開發，都是十分必要的。