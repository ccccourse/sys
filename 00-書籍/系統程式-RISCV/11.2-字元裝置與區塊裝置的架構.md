### 11. **裝置驅動程式設計**

#### 2. **字元裝置與區塊裝置的架構**

在作業系統中，裝置通常根據其特性分為字元裝置（Character Devices）和區塊裝置（Block Devices）。這些裝置之間的主要區別在於數據的傳輸方式和操作模型。了解這些區別對設計裝置驅動程式至關重要，因為它影響著如何處理 I/O 操作、如何與裝置進行交互，以及如何有效地管理資源。

### 2.1 **字元裝置（Character Devices）**

字元裝置是一類提供按字元流方式存取資料的裝置。這些裝置的資料是以一個字元（通常是 1 字節）為單位進行讀取和寫入的，且讀取或寫入操作是線性的。每次操作對應的是一個字元的傳輸，這使得字元裝置的操作較為簡單，但也限制了它們在大範圍資料傳輸中的效率。

**常見字元裝置**：
- **鍵盤**：每次讀取對應一個按鍵輸入（字元）。
- **串行端口**：資料流動是逐字元的。
- **終端機設備（TTY）**：文字輸入和輸出的基本設備。

**字元裝置的特點**：
- **資料傳輸是線性的**：每次 I/O 操作處理一個字元。
- **不支援隨機訪問**：無法直接跳到裝置上的任意位置進行讀寫，必須按順序進行操作。
- **簡單的緩衝管理**：大多數字元裝置會使用簡單的環形緩衝區來管理資料流。

**字元裝置的操作模型**：
- **讀取操作**：字元裝置驅動程式會提供一個 `read()` 函數，應用程式通過這個函數將資料從裝置讀入。
- **寫入操作**：類似地，`write()` 函數會將資料從應用程式寫入到字元裝置。
- **非阻塞與阻塞**：字元裝置的 I/O 操作可能是阻塞型的（等待資料準備好或等待裝置可以接受資料），也可能是非阻塞型的。

**字元裝置的驅動程式架構**：
- **初始化**：設置裝置並確保它處於準備好接收資料的狀態。
- **中斷處理**：如果裝置支持中斷，驅動程式需要設置中斷服務例程來處理來自裝置的中斷請求。
- **資料傳輸**：字元裝置的資料傳輸通常是通過簡單的緩衝區管理來實現，這些緩衝區可以是環形緩衝區（circular buffer）或FIFO隊列。

**範例：鍵盤字元裝置驅動程式**
```c
#include <stdio.h>
#include <stdint.h>

#define KEYBOARD_IRQ 1  // 假設鍵盤中斷號為 1

// 假設鍵盤資料緩衝區
uint8_t keyboardBuffer[128];
int bufferIndex = 0;

// 假設鍵盤中斷服務例程
void keyboardISR() {
    uint8_t scancode = inb(0x60);  // 從鍵盤端口讀取掃描碼
    keyboardBuffer[bufferIndex++] = scancode;

    // 假設將掃描碼轉換為字符，並打印
    printf("Key Pressed: %c\n", scancode); // 實際應該映射掃描碼為字符
}

// 模擬讀取 I/O 埠（用於硬體 I/O 操作）
uint8_t inb(uint16_t port) {
    // 假設從指定端口讀取資料
    return 0x1E;  // 例如，返回字母 'A' 的掃描碼
}

// 主程序
int main() {
    // 設定中斷向量
    setInterruptVector(KEYBOARD_IRQ, keyboardISR);

    // 模擬中斷觸發
    keyboardISR();  // 當按鍵被按下，ISR 被調用

    return 0;
}
```

### 2.2 **區塊裝置（Block Devices）**

區塊裝置與字元裝置的主要區別在於，它們支援隨機存取資料。區塊裝置將資料以固定大小的塊（通常為 512 字節或更大）為單位進行讀寫。這些裝置的操作更為複雜，但提供了更高的性能和靈活性。

**常見區塊裝置**：
- **硬碟（HDD）**：資料以塊為單位進行讀取和寫入。
- **固態硬碟（SSD）**：同樣使用塊設備模型，並且由於其快速的資料存取能力，能提供更高效的存取性能。
- **光碟**：雖然數據是線性的，但它仍然被視為區塊裝置，因為它支援隨機存取。

**區塊裝置的特點**：
- **隨機訪問**：支援直接訪問資料中的任何區塊，而無需按順序讀取。
- **資料傳輸是按塊進行**：每次操作處理一個固定大小的塊。
- **複雜的緩衝管理**：區塊裝置通常會使用緩衝區（例如磁碟緩衝區）來提高性能。

**區塊裝置的操作模型**：
- **讀取操作**：在區塊裝置上執行讀取操作時，驅動程式會將指定區塊的資料從裝置讀取到系統記憶體中。
- **寫入操作**：當寫入資料到區塊裝置時，資料將被寫入指定的區塊。
- **非阻塞與阻塞**：區塊裝置通常也支持非阻塞和阻塞操作，並且可能使用 IO 請求隊列來管理佇列中的請求。

**區塊裝置的驅動程式架構**：
- **初始化**：為區塊裝置設定基本的操作參數，例如區塊大小、塊數量等。
- **資料讀寫**：根據讀取或寫入的請求，從裝置讀取或將資料寫入特定的區塊。
- **錯誤處理與重試**：當寫入或讀取操作失敗時，區塊裝置驅動程式需要進行錯誤處理或重試。

**範例：硬碟區塊裝置驅動程式**
```c
#include <stdio.h>
#include <stdint.h>

#define BLOCK_SIZE 512  // 假設區塊大小為 512 字節
#define DISK_SIZE 1024  // 假設磁碟有 1024 個區塊

// 模擬硬碟區塊
uint8_t disk[DISK_SIZE][BLOCK_SIZE];

// 讀取磁碟區塊
int readBlock(uint32_t block_num, uint8_t *buffer) {
    if (block_num >= DISK_SIZE) {
        return -1;  // 錯誤：區塊超出範圍
    }
    memcpy(buffer, disk[block_num], BLOCK_SIZE);
    return 0;
}

// 寫入磁碟區塊
int writeBlock(uint32_t block_num, const uint8_t *buffer) {
    if (block_num >= DISK_SIZE) {
        return -1;  // 錯誤：區塊超出範圍
    }
    memcpy(disk[block_num], buffer, BLOCK_SIZE);
    return 0;
}

// 主程序
int main() {
    uint8_t buffer[BLOCK_SIZE];
    uint32_t block_num = 5;

    // 假設寫入資料到區塊 5
    memset(buffer, 0xFF, BLOCK_SIZE);
    writeBlock(block_num, buffer);

    // 假設讀取區塊 5
    readBlock(block_num, buffer);

    printf("Data read from block %d: %X\n", block_num, buffer[0]);

    return 0;
}
```

### 2.3 **字元裝置與區塊裝置的比較**

| 特性             | 字元裝置                        | 區塊裝置                        |
|------------------|---------------------------------|---------------------------------|
| **資料單位**     | 字元（通常為 1 字節）            | 區塊（通常為 512 字節或更大）    |
| **存取方式**     | 線性存取                         | 隨機存取                       |
| **資料傳輸方式** | 逐字元傳輸                       | 逐區塊傳輸                     |
| **典型裝置**     | 鍵盤、串行端口、終端機等         | 硬碟、SSD、光碟等               |
| **I/O 操作**     | 單個字元的讀寫操作               | 大塊資料的讀寫操作             |

### 小結

字元裝置與區塊裝置是兩種不同類型的裝置，它們在資料傳輸的方式、操作模型和存取方法上有所不同。字元裝置的操作較為簡單，適合處理逐字元的資料流，而區塊裝置則提供了隨機存取的能力，適合處理較大規模資料的快速讀取與寫入。了解這些裝置的區別和各自的特性，對於設計高效且靈活的裝置驅動