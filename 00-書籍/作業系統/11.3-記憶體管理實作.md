#### 11.3 記憶體管理實作

記憶體管理是作業系統的一個核心部分，負責有效地分配和回收記憶體資源，以保證系統的穩定性和效率。這一章節將介紹如何實作一個簡單的記憶體管理系統，包括以下幾個主要部分：

1. **記憶體分配**：如何將記憶體分配給進程或模組。
2. **記憶體回收**：如何回收已經不再使用的記憶體資源。
3. **記憶體管理策略**：包括分頁系統、分段系統和混合系統的基本原理及其簡單實作。

##### 11.3.1 記憶體分配

記憶體分配是記憶體管理的基本功能之一，它決定了如何將記憶體有效地分配給正在運行的進程或模組。記憶體分配策略可以分為以下幾種：

1. **連續記憶體分配**：將一塊連續的記憶體區域分配給進程。這種方法容易實現，但可能會造成記憶體碎片。
2. **非連續記憶體分配**：將記憶體分為若干固定或動態大小的區塊，並將這些區塊分配給進程。這種方法能有效減少碎片問題。

在簡單的記憶體管理系統中，連續記憶體分配可以使用一個簡單的數組來模擬。每當一個進程請求記憶體時，我們從未使用的區域分配連續的空間。

```c
#define MEMORY_SIZE 1024   // 記憶體大小
#define BLOCK_SIZE 64     // 記憶體塊大小

char memory[MEMORY_SIZE];  // 模擬的記憶體區域
int memory_map[MEMORY_SIZE / BLOCK_SIZE];  // 記憶體塊的使用情況，0表示未使用，1表示已使用

// 分配記憶體
void* allocate_memory(int size) {
    int blocks_needed = (size + BLOCK_SIZE - 1) / BLOCK_SIZE;  // 計算所需的記憶體塊數
    for (int i = 0; i <= (MEMORY_SIZE / BLOCK_SIZE) - blocks_needed; i++) {
        int available = 1;
        for (int j = 0; j < blocks_needed; j++) {
            if (memory_map[i + j] == 1) {
                available = 0;
                break;
            }
        }
        if (available) {
            for (int j = 0; j < blocks_needed; j++) {
                memory_map[i + j] = 1;  // 標記已分配
            }
            return (void*)(memory + i * BLOCK_SIZE);  // 返回分配的記憶體區域
        }
    }
    return NULL;  // 如果找不到足夠的空間，返回 NULL
}
```

##### 11.3.2 記憶體回收

記憶體回收是指在進程不再需要某些記憶體區域時，將其釋放回操作系統中。回收的記憶體將變為空閒區域，並可供其他進程使用。

以下是記憶體回收的簡單實作：當進程釋放記憶體時，我們會遍歷記憶體區域並將相應的記憶體塊標記為未使用。

```c
// 回收記憶體
void free_memory(void* ptr, int size) {
    int start_index = ((char*)ptr - memory) / BLOCK_SIZE;
    int blocks_to_free = (size + BLOCK_SIZE - 1) / BLOCK_SIZE;
    
    for (int i = start_index; i < start_index + blocks_to_free; i++) {
        memory_map[i] = 0;  // 標記為未使用
    }
}
```

##### 11.3.3 記憶體管理策略

為了提高記憶體使用效率，操作系統會使用不同的記憶體管理策略。常見的策略包括：

- **分頁系統**：將物理記憶體劃分為固定大小的頁（Page），並將進程的虛擬記憶體劃分為對應大小的頁面。當進程訪問虛擬記憶體時，系統會將相應頁面的數據映射到物理記憶體中。分頁系統能有效減少碎片，但會增加頁表管理的複雜度。

- **分段系統**：將進程的虛擬記憶體劃分為不同大小的段（Segment），例如代碼段、數據段、堆疊段等。每個段可以獨立地映射到物理記憶體。

- **混合分頁與分段系統**：在分頁系統的基礎上，將進程的虛擬記憶體劃分為若干段，每段內部使用頁來管理記憶體。

在這裡，我們將專注於簡單的分頁系統實作。

##### 11.3.4 分頁系統實作

分頁系統的基本概念是將物理記憶體和虛擬記憶體劃分為大小相同的頁，進程的虛擬記憶體地址被映射到物理記憶體中的頁框（Page Frame）。頁表用來存儲虛擬頁面和物理頁框之間的映射關係。

1. **頁表設計**：每個進程都擁有一個頁表，頁表存儲虛擬頁面和物理頁框的映射。
2. **頁面分配**：當進程需要分配記憶體時，系統根據頁表來分配物理頁框。
3. **頁面交換**：當記憶體不足時，可以將不活躍的頁面交換到磁碟中，這種技術稱為虛擬記憶體。

以下是一個簡單的分頁系統的實作框架：

```c
#define PAGE_SIZE 64  // 頁大小
#define NUM_PAGES 16  // 記憶體中有16頁

char physical_memory[NUM_PAGES * PAGE_SIZE];  // 模擬的物理記憶體
int page_table[NUM_PAGES];  // 頁表，記錄虛擬頁面和物理頁框的映射

// 初始化頁表
void init_page_table() {
    for (int i = 0; i < NUM_PAGES; i++) {
        page_table[i] = -1;  // -1表示該虛擬頁面沒有映射到物理頁框
    }
}

// 分配頁面
void* allocate_page(int virtual_page) {
    for (int i = 0; i < NUM_PAGES; i++) {
        if (page_table[i] == -1) {  // 找到空閒的物理頁框
            page_table[i] = virtual_page;  // 將虛擬頁面映射到物理頁框
            return (void*)(physical_memory + i * PAGE_SIZE);  // 返回分配的物理記憶體地址
        }
    }
    return NULL;  // 如果找不到空閒頁框，返回 NULL
}
```

##### 11.3.5 記憶體管理優化

在實際的作業系統中，記憶體管理的策略還會進行多方面的優化，以下是一些常見的優化方法：

1. **頁面置換算法**：當物理記憶體不足時，系統需要選擇某些頁面進行置換。常見的頁面置換算法有 FIFO（先進先出）、LRU（最近最少使用）等。
2. **記憶體壓縮**：在某些情況下，可以使用壓縮算法來減少記憶體的使用，特別是在虛擬記憶體中使用磁碟進行交換時。

##### 11.3.6 結語

記憶體管理是作業系統中至關重要的一部分。通過簡單的記憶體分配和回收機制，我們可以有效地管理系統資源。在這一部分的實作中，我們介紹了如何實作記憶體分配、回收、分頁系統等基本功能，這些基本功能將為後續的高級記憶體管理技術奠定基礎。