好的，我們開始撰寫 **第四章：行程的上下文切換** 的完整內容。這份內容會包含之前我們討論過的細節，並且加以擴展和整理。

**第四章：行程的上下文切換**

在多工處理系統中，上下文切換 (Context Switch) 是一個至關重要的機制，它使得 CPU 可以在不同的行程之間快速切換，營造出多個程式同時執行的假象。xv6 的上下文切換涉及核心模式和使用者模式之間的轉換，需要保存和恢復處理器的狀態。本章將深入探討 xv6 中用於執行上下文切換的相關機制，包括核心上下文切換和使用者上下文切換。

**1. 核心上下文切換 (`swtch.S`, `proc.h`)**

核心上下文切換是核心中用於切換執行緒的機制，主要用於從一個核心執行緒切換到另一個核心執行緒。這種切換通常發生在以下場景：
* 行程讓出 CPU
* 核心需要睡眠的時候
* 排程器需要執行時

* **核心上下文的概念**

   核心上下文是指核心模式下，程式執行時的環境資訊，包括處理器的暫存器狀態、堆疊指標、程式計數器等。在 xv6 中，每個 CPU 核心都具有一個用於執行核心程式碼的上下文 (`struct context`)。核心上下文切換的主要目標是在不同核心執行緒之間切換執行權，例如從執行中的行程切換到排程器，或從睡眠中的行程切換到可執行的狀態。

*   **`swtch.S`：核心上下文切換的組合語言程式碼**

   `swtch.S` 檔案是一個使用 RISC-V 組合語言編寫的檔案，其中包含了執行核心上下文切換的底層程式碼。`swtch()` 函數負責將當前 CPU 的暫存器狀態儲存到 `old` 這個 `struct context` 結構中，並從 `new` 這個 `struct context` 結構恢復暫存器值，並返回。

   ```assembly
   .globl swtch
    swtch:
        sd ra, 0(a0)
        sd sp, 8(a0)
        sd s0, 16(a0)
        sd s1, 24(a0)
        sd s2, 32(a0)
        sd s3, 40(a0)
        sd s4, 48(a0)
        sd s5, 56(a0)
        sd s6, 64(a0)
        sd s7, 72(a0)
        sd s8, 80(a0)
        sd s9, 88(a0)
        sd s10, 96(a0)
        sd s11, 104(a0)

       ld ra, 0(a1)
        ld sp, 8(a1)
        ld s0, 16(a1)
        ld s1, 24(a1)
        ld s2, 32(a1)
        ld s3, 40(a1)
        ld s4, 48(a1)
        ld s5, 56(a1)
        ld s6, 64(a1)
        ld s7, 72(a1)
        ld s8, 80(a1)
         ld s9, 88(a1)
        ld s10, 96(a1)
        ld s11, 104(a1)
        
        ret
   ```
     `swtch()` 函數接受兩個參數，分別是 `old` 和 `new`，它們都是指向 `struct context` 結構的指標。
        *  `a0`: 指向目前執行緒要儲存的 `struct context`。
        *  `a1`: 指向下一個執行緒要載入的 `struct context`。

    以下是 `swtch()` 函數的運作步驟：

    1.  **儲存暫存器：** 將目前 CPU 的 `ra`、`sp` 和 `s0` 至 `s11` 暫存器的值，儲存到 `a0` 指向的 `struct context` 結構中，也就是儲存目前執行緒的狀態。
        ```assembly
           sd ra, 0(a0)
            sd sp, 8(a0)
            sd s0, 16(a0)
            ...
            sd s11, 104(a0)
        ```
          *   `sd` (store doubleword) 指令用於將暫存器的值儲存到記憶體中。
    2.  **恢復暫存器：** 從 `a1` 指向的 `struct context` 結構中讀取數值，並將 `ra`、`sp` 和 `s0` 至 `s11` 暫存器恢復。
         ```assembly
         ld ra, 0(a1)
            ld sp, 8(a1)
             ld s0, 16(a1)
           ...
          ld s11, 104(a1)
         ```
           *  `ld` (load doubleword) 指令用於從記憶體中讀取數值並載入到暫存器。
    3.  **返回：**  執行 `ret` 指令，回到呼叫 `swtch` 函數的地方，但此時已經是在新的執行緒中執行。
        ```assembly
         ret
        ```
        * `ret` 指令會讀取 `ra` 暫存器的值，並跳轉到該位址。

    `swtch()` 的關鍵在於：

    *   **組合語言：**  使用組合語言能執行最底層的 CPU 暫存器操作，以便完成上下文切換。
    *   **暫存器儲存：**  必須保存所有 callee-saved 暫存器，以便在返回時恢復這些暫存器的值。
    *   **直接記憶體操作：**  使用 `a0` 和 `a1` 暫存器直接讀寫記憶體，操作對應的 `struct context` 資訊。

*   **`struct context`：環境資訊**

    `struct context` 結構定義在 `kernel/proc.h` 檔案中，用於儲存行程的上下文資訊。`swtch()` 函數會使用 `struct context` 來儲存和恢復暫存器的值。
     ```c
    struct context {
         uint64 ra;
          uint64 sp;
        // callee-saved
        uint64 s0;
        uint64 s1;
        uint64 s2;
         uint64 s3;
          uint64 s4;
          uint64 s5;
         uint64 s6;
          uint64 s7;
          uint64 s8;
         uint64 s9;
         uint64 s10;
        uint64 s11;
      };
     ```
    以下是 `struct context` 中各成員變數的詳細解釋：

    *   `uint64 ra`: 儲存返回位址暫存器 `ra` 的值，用於在切換後返回正確的程式碼位置。
    *   `uint64 sp`:  儲存堆疊指標暫存器 `sp` 的值，指向行程的核心堆疊的頂部。
    *   `uint64 s0` to `uint64 s11`: 儲存 callee-saved 暫存器 `s0` 到 `s11` 的值。 callee-saved 表示這些暫存器由被呼叫者 (callee) 保存和恢復。

*   **核心上下文切換的用途**

    核心上下文切換在 xv6 中扮演著重要的角色，它會在以下幾個主要場景被用到：

    1.  **行程排程：** 排程器在執行行程切換時，會使用 `swtch()` 函數將 CPU 從一個行程切換到另一個行程。
    2.  **睡眠和喚醒：** 當行程進入睡眠狀態或被喚醒時，會透過 `swtch()` 切換到排程器，並且讓出 CPU。
    3.  **例外和中斷處理：** 發生例外或中斷時，核心會使用 `swtch()` 來切換到對應的處理程式碼。

*   **總結**

    本節深入探討了 xv6 的核心上下文切換機制，說明了 `swtch.S` 中的組合語言程式碼如何儲存和恢復處理器的暫存器，以及 `struct context` 結構如何儲存上下文資訊。理解這些概念對於深入瞭解 xv6 的行程切換和多工運作至關重要。

    在下一節中，我們將探討 xv6 的使用者模式上下文切換。
