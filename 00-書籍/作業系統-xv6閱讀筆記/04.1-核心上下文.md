好的，我們開始撰寫 **第四章：行程的上下文切換** 的 **1. 核心上下文 (`swtch.S`, `proc.h`)** 的內容。

**第四章：行程的上下文切換**

**1. 核心上下文 (`swtch.S`, `proc.h`)**

在 xv6 中，上下文切換 (Context Switch) 是行程排程的核心機制。當排程器決定切換執行中的行程時，它需要保存目前行程的執行環境，並恢復下一個行程的執行環境。本節將深入探討 xv6 中用於處理核心上下文切換的相關概念，包括 `swtch.S` 中的程式碼、`struct context` 的定義，以及如何保存和恢復處理器暫存器。

*   **核心上下文的概念**

    在作業系統中，上下文 (Context) 指的是程式執行時所需要的環境資訊，包括處理器的暫存器狀態、堆疊指標、程式計數器等。當作業系統要將 CPU 控制權從一個行程轉移到另一個行程時，需要：

    1.  **保存目前行程的上下文：** 將目前行程的暫存器狀態儲存到記憶體中的某個位置。
    2.  **恢復下一個行程的上下文：** 從記憶體中讀取下一個行程的暫存器狀態，並恢復處理器的執行環境。

    這個過程稱為上下文切換。在 xv6 中，核心上下文切換由 `swtch()` 函數來完成。

*   **`swtch.S`：核心上下文切換的組合語言程式碼**

    `swtch.S` 是一個使用 RISC-V 組合語言編寫的檔案，其中包含了執行上下文切換的程式碼。`swtch()` 函數負責儲存目前的暫存器狀態到 `old` 結構，並從 `new` 結構恢復暫存器狀態。

    ```assembly
    .globl swtch
    swtch:
            sd ra, 0(a0)
            sd sp, 8(a0)
            sd s0, 16(a0)
            sd s1, 24(a0)
            sd s2, 32(a0)
            sd s3, 40(a0)
            sd s4, 48(a0)
            sd s5, 56(a0)
            sd s6, 64(a0)
            sd s7, 72(a0)
            sd s8, 80(a0)
            sd s9, 88(a0)
            sd s10, 96(a0)
            sd s11, 104(a0)

            ld ra, 0(a1)
            ld sp, 8(a1)
            ld s0, 16(a1)
            ld s1, 24(a1)
            ld s2, 32(a1)
            ld s3, 40(a1)
            ld s4, 48(a1)
            ld s5, 56(a1)
            ld s6, 64(a1)
            ld s7, 72(a1)
            ld s8, 80(a1)
            ld s9, 88(a1)
            ld s10, 96(a1)
            ld s11, 104(a1)

           ret
    ```

    `swtch()` 函數接受兩個參數，分別是 `old` 和 `new`，都指向 `struct context` 結構。
        * `a0` :  `old` 上下文資訊所在的記憶體位址。
        * `a1` : `new` 上下文資訊所在的記憶體位址。

    以下是 `swtch()` 函數的運作步驟：

    1.  **儲存暫存器：** 將當前 CPU 的 `ra`, `sp`, `s0` 到 `s11` 暫存器的值儲存到 `a0` 指向的記憶體位置 (也就是 `old` 這個 `struct context` 的記憶體位置)。

        *   `sd ra, 0(a0)`: 儲存返回位址 `ra`。
        *   `sd sp, 8(a0)`: 儲存堆疊指標 `sp`。
        *   `sd s0, 16(a0)` 到 `sd s11, 104(a0)`: 儲存 callee-saved 暫存器 `s0` 到 `s11` 。

    2.  **恢復暫存器：**  從 `a1` 指向的記憶體位置 (也就是 `new` 這個 `struct context` 的記憶體位置) 讀取數值，並恢復 `ra`, `sp`, `s0` 到 `s11` 暫存器的值。

        *   `ld ra, 0(a1)`: 載入返回位址 `ra`。
        *   `ld sp, 8(a1)`: 載入堆疊指標 `sp`。
        *    `ld s0, 16(a1)` 到 `ld s11, 104(a1)`: 載入 callee-saved 暫存器 `s0` 到 `s11`。

    3.  **返回：** 執行 `ret` 指令，將程式執行權轉移到新的行程中。

    `swtch()` 的關鍵在於：

    *   **組合語言實現：**  使用組合語言可以確保上下文切換的效率和精確性。
    *   **暫存器儲存：**  必須儲存所有 callee-saved 暫存器，以便在返回時恢復這些暫存器的值。
    *   **直接操作記憶體：** 透過 `a0` 和 `a1` 暫存器直接存取記憶體中 `struct context` 的值。

*   **`struct context`：環境資訊**

    `struct context` 結構定義在 `proc.h` 檔案中，用於儲存行程的上下文資訊。`swtch()` 函數會使用 `struct context` 來儲存和恢復暫存器的值。

    ```c
    struct context {
      uint64 ra;
      uint64 sp;

      // callee-saved
      uint64 s0;
      uint64 s1;
      uint64 s2;
      uint64 s3;
      uint64 s4;
      uint64 s5;
      uint64 s6;
      uint64 s7;
      uint64 s8;
      uint64 s9;
      uint64 s10;
      uint64 s11;
    };
    ```

    以下是 `struct context` 中各成員的詳細解釋：

    *   `uint64 ra;`: 儲存返回位址暫存器 `ra` 的值，用於在切換後返回正確的程式碼位置。
    *   `uint64 sp;`: 儲存堆疊指標暫存器 `sp` 的值，指向行程的堆疊頂部。
    *   `uint64 s0` 到 `uint64 s11`: 儲存callee-saved 暫存器的值。

*   **核心上下文的用途**

    核心上下文切換用於以下幾個主要場景：

    *   **行程排程：**  當排程器決定切換執行中的行程時，會使用 `swtch()` 函數來執行上下文切換。
    *   **睡眠：**  當行程呼叫 `sleep()` 函數進入睡眠狀態時，會透過 `swtch()` 切換到排程器的上下文。
    *   **喚醒：**  當行程被喚醒時，排程器會使用 `swtch()` 將控制權切換回該行程。

*   **總結**

    本節深入探討了 xv6 中核心上下文切換的機制，說明了 `swtch.S` 中的程式碼如何儲存和恢復處理器的暫存器，以及 `struct context` 結構如何儲存上下文資訊。理解這些概念對於深入瞭解 xv6 的多工處理方式至關重要。

    在下一節中，我們將探討使用者上下文切換的機制。
