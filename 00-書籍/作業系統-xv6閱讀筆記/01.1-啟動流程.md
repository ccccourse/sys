好的，讓我們開始撰寫 **第一章：xv6 的啟動與初始化** 的 **1. 啟動流程** 的內容。

**第一章： xv6 的啟動與初始化**

**1. 啟動流程**

當我們啟動 xv6 模擬器（通常使用 QEMU）時，核心的啟動過程是複雜且精密的，它涉及多個階段，確保 xv6 環境能順利運作。本節將深入探討這個過程，從 QEMU 如何載入核心，到 xv6 核心的起始點，以及如何設定執行環境。

*   **QEMU 如何載入核心**

    QEMU 是一款強大的機器模擬器，它能夠模擬各種硬體平台，包括 RISC-V 架構，而 xv6 正是基於 RISC-V 架構開發的。當我們使用 QEMU 啟動 xv6 時，以下步驟會依序執行：

    1.  **載入核心映像檔：** QEMU 會從指定的檔案系統（例如 `fs.img`）中載入 xv6 核心映像檔。這個映像檔包含了編譯好的 xv6 核心程式碼以及其他必要的資源。
    2.  **設定虛擬硬體：** QEMU 會模擬 RISC-V 處理器、記憶體、UART 控制器（用於控制台輸入輸出）、Virtio 磁碟控制器（用於虛擬硬碟），以及其他周邊裝置。這些虛擬硬體裝置在 xv6 中扮演著重要的角色。
    3.  **跳轉至核心入口點：** QEMU 會將 RISC-V 處理器的執行控制權轉移到 xv6 核心映像檔中的入口點，這個入口點通常是記憶體位址 `0x80000000`。此位址是硬體預定的啟動位址。

*   **`entry.S`：核心的起始點**

    `entry.S` 檔案是一個使用 RISC-V 組合語言編寫的原始碼檔案，也是 xv6 核心的起始點。當 QEMU 將執行控制權轉移到 `0x80000000` 時，RISC-V 處理器會開始執行 `entry.S` 中的指令。 `entry.S` 的主要功能如下：

    1.  **設定堆疊：** 在 `entry.S` 中，程式碼首先會設定核心的堆疊。由於核心剛啟動時沒有可用的堆疊，因此需要手動設定。xv6 會為每個 CPU 核心分配一個 4KB 大小的堆疊區域，並使用 `stack0` 陣列來儲存這些堆疊。每個核心的堆疊會設定在 `stack0` 陣列中的不同位置，這確保了每個核心都擁有自己的獨立堆疊空間。

        ```assembly
        la sp, stack0
        li a0, 1024*4
        csrr a1, mhartid
        addi a1, a1, 1
        mul a0, a0, a1
        add sp, sp, a0
        ```
        *   `la sp, stack0`：將 `stack0` 陣列的起始位址載入到堆疊指標 `sp` 寄存器。
        *   `li a0, 1024*4`：將每個堆疊的大小（4KB）載入到寄存器 `a0`。
        *   `csrr a1, mhartid`：讀取當前 CPU 核心的 ID，並將其儲存在 `a1` 寄存器中。
        *   `addi a1, a1, 1`：將核心 ID 加 1（因為 core 0 從 1 開始）
        *   `mul a0, a0, a1`：計算當前核心的堆疊在 `stack0` 中的偏移量，並將結果儲存在 `a0` 寄存器中。
        *   `add sp, sp, a0`：將堆疊指標 `sp` 指向當前核心的堆疊頂部。

    2.  **跳轉至 `start()` 函數：**  `entry.S` 的最後一步是跳轉至 `start()` 函數，此函數是使用 C 語言編寫，並且是核心初始化的主要入口點。

        ```assembly
        call start
        ```

*   **`start()` 函數**

    `start()` 函數位於 `start.c` 檔案中，在 `entry.S` 完成基本的環境設定後， `start()` 函數會執行以下操作，進一步初始化核心環境：

    1.  **設定 M 模式的權限：** 設定 M 模式（Machine Mode）的權限，確保後續的程式碼可以在 S 模式（Supervisor Mode）下執行。

        ```c
        unsigned long x = r_mstatus();
        x &= ~MSTATUS_MPP_MASK;
        x |= MSTATUS_MPP_S;
        w_mstatus(x);
        ```

    2.  **設定 M 模式的異常處理程式：** 將 M 模式的異常處理程式（Exception Program Counter）設定為 `main()` 函數的位址，以便在執行 `mret` 指令後能跳轉到 `main()` 函數。
      ```c
        w_mepc((uint64)main);
      ```
    3. **關閉分頁機制**: 確保在核心初始化時關閉分頁機制
        ```c
          w_satp(0);
        ```

    4.  **委派中斷與例外處理：** 將所有的中斷和例外處理都委派給 S 模式處理。

        ```c
        w_medeleg(0xffff);
        w_mideleg(0xffff);
        w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);
        ```
    5.  **設定物理記憶體保護：** 設定 PMP（Physical Memory Protection），允許 S 模式存取所有實體記憶體。
       ```c
           w_pmpaddr0(0x3fffffffffffffull);
           w_pmpcfg0(0xf);
        ```

    6.  **設定時鐘中斷：** 初始化計時器，產生時鐘中斷。
        ```c
            timerinit();
        ```

    7.  **儲存核心 ID：** 將當前 CPU 核心的 ID 儲存在 `tp` 寄存器中，以便在 `cpuid()` 函數中使用。
         ```c
         int id = r_mhartid();
         w_tp(id);
        ```

    8.  **切換至 S 模式：** 使用 `mret` 指令，切換到 S 模式，並跳轉到 `main()` 函數，開始 xv6 核心的正式初始化。
         ```c
           asm volatile("mret");
         ```
透過上述步驟，xv6 核心成功地從硬體載入、初始化執行環境、並準備好進行後續的初始化和執行。

**總結**

這一節詳細介紹了 xv6 的啟動流程，從 QEMU 如何載入核心，到 `entry.S` 的基本設定，再到 `start()` 函數的進階初始化。這些步驟為 xv6 核心的運作奠定了基礎，並為後續的核心初始化程序做好了準備。

在下一節中，我們將探討 `main.c` 檔案中的核心初始化細節。
