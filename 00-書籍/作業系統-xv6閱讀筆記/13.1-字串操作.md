好的，我們開始撰寫 **第十三章：其他工具函式** 的 **1. 字串操作 (`string.c`)** 的內容。

**第十三章：其他工具函式**

**1. 字串操作 (`string.c`)**

在 xv6 核心中，字串操作是常見的基本操作。`string.c` 檔案中定義了一系列用於處理字串和記憶體區塊的工具函數，包括 `memset()`、`memcmp()`、`memmove()`、`strncpy()`、`safestrcpy()` 和 `strlen()`。本節將深入探討這些函數的功能和運作原理，說明它們如何操作字串和記憶體區塊。

*   **字串操作的重要性**

    字串操作是程式碼開發中頻繁使用的基本操作。在作業系統中，字串操作用於處理路徑名稱、指令列參數、訊息輸出等。為了確保程式碼的正確性，核心需要提供一些可靠的字串操作函數。

*   **`memset()`：設定記憶體區塊**

    `memset()` 函數負責將記憶體區塊設定為特定的值。它會將 `dst` 指向的記憶體區塊的 `n` 個位元組設定為值 `c`。
     ```c
      void*
      memset(void *dst, int c, uint n)
      {
       char *cdst = (char *) dst;
       int i;
        for(i = 0; i < n; i++){
          cdst[i] = c;
        }
        return dst;
      }
     ```
     以下是 `memset()` 函數的運作步驟：

    1.  **轉為 `char` 指標：** 將傳入的指標 `dst` 轉換為 `char *` 類型，以便進行逐位元組的操作。
          ```c
          char *cdst = (char *) dst;
          ```
    2.  **迴圈設定記憶體：**  使用迴圈，將 `cdst` 指向的記憶體區塊中的 `n` 個位元組都設定為值 `c`。
          ```c
            for(i = 0; i < n; i++){
              cdst[i] = c;
           }
          ```
    3.  **返回指標：** 返回 `dst` 指標。
         ```c
          return dst;
         ```

    `memset()` 的關鍵在於：

    *   **逐位元組設定：**  使用迴圈來逐個位元組地設定記憶體區域。
    *   **廣泛使用：**  用於將記憶體區域初始化為特定的值，例如清空區塊、或初始化資料結構。

*   **`memcmp()`：比較記憶體區塊**

    `memcmp()` 函數負責比較兩個記憶體區塊的內容，並返回一個整數值，表示兩個區塊的相對大小。
     ```c
     int
      memcmp(const void *v1, const void *v2, uint n)
      {
        const uchar *s1, *s2;

         s1 = v1;
       s2 = v2;
        while(n-- > 0){
           if(*s1 != *s2)
              return *s1 - *s2;
           s1++, s2++;
        }

         return 0;
      }
     ```
       以下是 `memcmp()` 函數的運作步驟：

    1.  **轉為 `uchar` 指標：**  將輸入的指標 `v1` 和 `v2` 轉換為 `uchar *` 類型，以便進行逐位元組的操作。
        ```c
            const uchar *s1, *s2;
            s1 = v1;
           s2 = v2;
        ```
    2.  **迴圈比較記憶體：**  使用迴圈逐個位元組比較兩個記憶體區塊的內容，直到比較了 `n` 個位元組或遇到不同的位元組為止。
        ```c
         while(n-- > 0){
            if(*s1 != *s2)
              return *s1 - *s2;
          s1++, s2++;
         }
        ```
    3.  **返回比較結果：**  如果兩個記憶體區塊完全相同，則回傳 `0`。如果有差異，則回傳第一個不同位元組的差值。
         ```c
             return 0;
         ```

    `memcmp()` 的關鍵在於：

    *   **逐位元組比較：** 使用迴圈來逐個位元組比較兩個記憶體區域。
    *   **回傳值：**  根據比較的結果，返回一個整數值表示相對大小。
*   **`memmove()`：複製記憶體區塊**

    `memmove()` 函數負責將記憶體區塊從 `src` 複製到 `dst`。它可以處理 `src` 和 `dst` 記憶體區域重疊的情況。
     ```c
      void*
     memmove(void *dst, const void *src, uint n)
     {
       const char *s;
       char *d;

        if(n == 0)
          return dst;
  
        s = src;
       d = dst;
       if(s < d && s + n > d){
         s += n;
          d += n;
         while(n-- > 0)
            *--d = *--s;
       } else
         while(n-- > 0)
           *d++ = *s++;

      return dst;
     }
    ```
     以下是 `memmove()` 函數的運作步驟：

    1.  **檢查參數：** 若複製的長度為 0，則直接回傳 `dst`。
       ```c
        if(n == 0)
          return dst;
       ```
    2.  **轉為 `char` 指標：** 將輸入的指標 `src` 和 `dst` 轉換為 `char *` 類型，以便進行逐位元組的操作。
         ```c
          s = src;
          d = dst;
         ```
    3.  **處理重疊的情況：**  檢查記憶體區塊是否重疊，若是 `s < d && s + n > d` 表示重疊，並且 `s` 在 `d` 之前，需要從記憶體結尾處開始複製，避免複製到被覆蓋的值。
        ```c
          if(s < d && s + n > d){
           s += n;
           d += n;
           while(n-- > 0)
              *--d = *--s;
        } else
           while(n-- > 0)
               *d++ = *s++;
        ```
        *   如果不重疊，則從頭開始複製。
    4.  **返回目標位址：** 返回目標位址 `dst`。

    `memmove()` 的關鍵在於：

    *   **處理重疊：** 可以正確處理來源和目標記憶體區塊重疊的情況，確保資料複製的正確性。
    *   **逐位元組複製：**  使用迴圈來逐個位元組複製記憶體區域。

*   **`strncpy()`：複製字串**

    `strncpy()` 函數負責將字串 `t` 複製到字串 `s`，並限制複製的最大長度為 `n`。
    ```c
    char*
    strncpy(char *s, const char *t, int n)
    {
      char *os;

      os = s;
      while(n-- > 0 && (*s++ = *t++) != 0)
         ;
       while(n-- > 0)
          *s++ = 0;
       return os;
     }
    ```
        以下是 `strncpy()` 函數的運作步驟：
    1. **儲存原始 `s` 指標:**  儲存原始的 `s` 指標，以便最後回傳。
        ```c
            os = s;
        ```
    2.  **迴圈複製字元：**  使用迴圈將 `t` 指向的字串複製到 `s` 指向的記憶體區域，並且當 `n` 大於 `0` 且 `t` 不為空字元，才會繼續執行。
         ```c
           while(n-- > 0 && (*s++ = *t++) != 0)
              ;
         ```
    3. **補上 null 字元:** 如果 `t` 的長度小於 `n`，則會繼續迴圈，補上 null 字元直到 `n` 為零。
        ```c
           while(n-- > 0)
             *s++ = 0;
        ```
    4.  **返回目標字串指標：** 返回原始的 `s` 指標，指向複製後的字串。
         ```c
            return os;
        ```

    `strncpy()` 的關鍵在於：

    *   **最大長度限制：**  限制複製的最大長度，避免緩衝區溢位。
    * **不足補零:** 當來源字串小於指定長度，會使用 null 字元補齊剩餘的空間。

*   **`safestrcpy()`：安全複製字串**

    `safestrcpy()` 函數與 `strncpy()` 類似，負責將字串 `t` 複製到 `s` 中，並限制複製的最大長度為 `n`。它會保證複製的字串以 null 字元結尾，即便字串被截斷。

    ```c
    char*
    safestrcpy(char *s, const char *t, int n)
    {
      char *os;

      os = s;
      if(n <= 0)
        return os;
      while(--n > 0 && (*s++ = *t++) != 0)
        ;
      *s = 0;
      return os;
    }
    ```
    以下是 `safestrcpy()` 函數的運作步驟：

    1.  **儲存原始 `s` 指標：**  儲存原始的 `s` 指標，以便最後回傳。
          ```c
            os = s;
           if(n <= 0)
            return os;
        ```
         * 若 `n` 小於等於 `0` 則直接回傳。
    2.  **迴圈複製字元：**  使用迴圈將 `t` 指向的字串複製到 `s` 指向的記憶體區域，當 `n` 大於 `1` 且 `t` 不為空字元時會繼續執行。
          ```c
             while(--n > 0 && (*s++ = *t++) != 0)
            ;
         ```
           *  與 `strncpy` 的差別在於此處的條件是 `n > 1`，因此當 `n=1` 時，迴圈不會執行。
    3. **補上 null 字元:**  最後將 `s` 指向的位置設定為 `0`，確保字串為 null 結尾，即便字串被截斷。
          ```c
            *s = 0;
          ```
    4.  **返回目標字串指標：** 返回原始的 `s` 指標，指向複製後的字串。
        ```c
          return os;
        ```

     `safestrcpy()` 的關鍵在於：

    *   **最大長度限制：** 限制複製的最大長度，避免緩衝區溢位。
    *   **強制結尾：**  保證複製後的字串以 null 字元結尾，即使字串被截斷。

*   **`strlen()`：計算字串長度**

    `strlen()` 函數負責計算一個以 null 字元結尾的字串的長度，但不包含 null 字元。
       ```c
       int
      strlen(const char *s)
       {
         int n;

          for(n = 0; s[n]; n++)
            ;
          return n;
       }
       ```
    以下是 `strlen()` 函數的運作步驟：

    1.  **初始化長度計數器：**  初始化字串長度計數器 `n` 為 0。
        ```c
          int n;
          for(n = 0; s[n]; n++)
        ```
    2.  **迴圈遍歷字串：**  使用迴圈逐個字元遍歷字串 `s`，直到遇到 null 字元 (`\0`) 為止。
        ```c
          for(n = 0; s[n]; n++)
             ;
        ```
    3.  **返回字串長度：**  返回字串的長度 `n`。
       ```c
         return n;
       ```

    `strlen()` 的關鍵在於：

    *   **Null 結尾：**  預期字串是以 null 字元結尾。
    *   **迴圈遍歷：**  使用迴圈來逐個位元組掃描字串，直到遇到終止符號。

*   **總結**

    本節深入探討了 xv6 中用於字串操作的相關函數，說明了 `memset()`、`memcmp()`、`memmove()`、`strncpy()`、`safestrcpy()` 和 `strlen()` 的作用和運作原理。這些函數是 xv6 核心中常用的工具，它們確保字串和記憶體操作的可靠性和安全性。

   在下一章，我們將探討 xv6 的上下文切換相關的程式碼。
