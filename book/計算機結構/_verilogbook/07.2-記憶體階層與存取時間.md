### **7.2 記憶體階層與存取時間**

在計算機架構中，記憶體系統的效能對整體系統性能有極大影響。記憶體階層（Memory Hierarchy）是指一系列不同速度、不同容量、不同成本的記憶體設備組成的層次結構，從最快且最小的寄存器到最慢但最大容量的硬碟或磁碟陣列。不同層次的記憶體設計對於提升計算機性能至關重要，而存取時間（Access Time）則是衡量記憶體響應速度的關鍵指標。

#### **記憶體階層概念**

記憶體階層是基於“原則性貿易”（principle of locality）的設計，並且由多個層級組成，每個層級的速度和成本不同。其基本結構通常如下：

1. **寄存器**：
   - 速度最快，位於處理器內部，但容量非常小。
   - 用來存儲處理器正在處理的數據和指令。

2. **L1 快取**：
   - 緊鄰處理器核心的快取，容量通常從 16KB 到 128KB，不同核心架構有所不同。
   - 訪問速度較快，通常在幾個時鐘週期內完成。

3. **L2 快取**：
   - 一般設置在 L1 快取和主記憶體之間，容量比 L1 大，但速度較慢。容量通常為 256KB 至 8MB。
   - 訪問速度較慢，但仍然比主記憶體要快。

4. **L3 快取**：
   - 在多核心處理器中，L3 快取通常是共享的，容量可能高達 32MB 或更大。
   - 訪問速度相對較慢，且為多核心共享。

5. **主記憶體（RAM）**：
   - 主要的工作記憶體（通常為 DRAM），容量大但訪問速度慢。
   - 通常在數 GB 至數 TB 之間，視系統而定。

6. **二級存儲設備**：
   - 這些設備如硬碟（HDD）或固態硬碟（SSD），提供大容量存儲，但速度相對較慢。
   - 存取延遲時間可以達到數毫秒。

7. **外部存儲**：
   - 例如磁帶或光碟，提供極大的存儲容量，但延遲更長，通常用於資料備份或存儲較不常使用的數據。

#### **存取時間與記憶體階層**

不同層級的記憶體擁有不同的存取時間。隨著層級的降低，存儲容量增加，但存取時間也顯著增加。以下是各層記憶體的一些典型存取時間：

- **寄存器**：0.5 至 1 個時鐘週期
- **L1 快取**：1 至 4 個時鐘週期
- **L2 快取**：4 至 10 個時鐘週期
- **L3 快取**：10 至 30 個時鐘週期
- **主記憶體**：50 至 100 個時鐘週期
- **硬碟（HDD）**：1 到 10 毫秒（ms）
- **固態硬碟（SSD）**：0.1 毫秒（ms）

由此可見，隨著記憶體層次的增加，存取時間呈指數級增長。因此，設計記憶體層次結構時，必須平衡各層級的存儲容量與存取速度，從而在保證性能的前提下，實現成本和效能的最優化。

#### **Verilog 實現：記憶體階層模擬**

我們將設計一個簡單的模擬系統，模擬記憶體階層中的一個簡單 L1 快取和主記憶體的交互。這個簡單的系統會根據處理器訪問記憶體的需求，決定是否命中快取，並計算存取時間。

##### **L1 快取與主記憶體簡單模擬 Verilog 範例**

```verilog
module MemoryHierarchy (
    input clk,                        // 時鐘信號
    input reset,                      // 重置信號
    input [31:0] address,             // 記憶體地址
    input [31:0] write_data,          // 寫入數據
    input write_enable,               // 寫使能信號
    output reg [31:0] read_data,      // 讀取數據
    output reg hit,                   // 快取命中信號
    output reg [31:0] access_time     // 存取時間
);

    // 定義 L1 快取大小和主記憶體大小
    reg [31:0] L1_cache [15:0];        // L1 快取有 16 個區塊，每個區塊 32 位元
    reg [31:0] main_memory [1023:0];   // 主記憶體有 1024 個區塊，每個區塊 32 位元

    reg [31:0] L1_tags [15:0];         // 每個快取區塊對應的標籤
    reg L1_valid [15:0];               // 每個快取區塊的有效位

    integer i;

    // 初始化 L1 快取和主記憶體
    initial begin
        for (i = 0; i < 16; i = i + 1) begin
            L1_cache[i] = 0;
            L1_tags[i] = 0;
            L1_valid[i] = 0;
        end
        // 初始化主記憶體
        for (i = 0; i < 1024; i = i + 1) begin
            main_memory[i] = i * 2;  // 假設主記憶體為一個簡單的增量模式
        end
    end

    // 記憶體存取操作
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            // 重置
            hit <= 0;
            read_data <= 32'b0;
            access_time <= 0;
        end else begin
            if (write_enable == 1) begin
                // 寫操作，寫入 L1 快取或主記憶體
                hit <= 0; // 設置為未命中
                for (i = 0; i < 16; i = i + 1) begin
                    if (L1_valid[i] && (L1_tags[i] == address[7:0])) begin
                        // 快取命中，寫入快取
                        L1_cache[i] <= write_data;
                        hit <= 1;
                    end
                end
                if (!hit) begin
                    // 快取未命中，寫入主記憶體
                    main_memory[address[9:0]] <= write_data;
                    access_time <= 100;  // 假設主記憶體寫入時間為 100 時鐘週期
                end
            end else begin
                // 讀取操作
                hit <= 0;  // 設置為未命中
                for (i = 0; i < 16; i = i + 1) begin
                    if (L1_valid[i] && (L1_tags[i] == address[7:0])) begin
                        // 快取命中，讀取快取
                        read_data <= L1_cache[i];
                        hit <= 1;
                        access_time <= 1;  // 假設 L1 快取讀取時間為 1 時鐘週期
                    end
                end
                if (!hit) begin
                    // 快取未命中，從主記憶體讀取
                    read_data <= main_memory[address[9:0]];
                    access_time <= 50;  // 假設主記憶體讀取時間為 50 時鐘週期
                end
            end
        end
    end

endmodule
```

#### **設計說明**

1. **L1 快取設計**：
   - 使用 `L1_cache` 存儲快取數據，`L1_tags` 存儲每個快取區塊的標籤，`L1_valid` 記錄每個區塊的有效性。

2. **記憶體存取操作**：
   - 在讀取操作中，首先檢查 L1 快取是否命中。如果命中，直接從快取讀取數據並設置存取時間為 1 時鐘週期。若未命中，則從主記憶體

中讀取數據並設置存取時間為 50 時鐘週期。
   - 在寫操作中，若快取命中，數據將被寫入快取。如果快取未命中，則寫入主記憶體。

3. **存取時間**：
   - `access_time` 記錄每次存取操作所需的時鐘週期，這有助於衡量記憶體系統的效能。

#### **總結**

此模擬程式展示了記憶體階層的基本設計概念，其中包含了如何根據記憶體命中與否來計算存取時間。這樣的設計對於理解不同記憶體層次對效能的影響具有重要意義。