### 範例實作：自製鍵盤驅動程式

在這個範例中，我們將展示如何實現一個簡單的鍵盤驅動程式。這個驅動程式將處理來自鍵盤的掃描碼（scancodes），並將其轉換為可識別的字元或事件，像是顯示到螢幕上。為了簡化範例，我們將模擬一個鍵盤中斷服務例程（ISR），並顯示如何處理鍵盤的輸入。

這個範例假設使用的是 x86 架構的中斷處理方式，其中鍵盤的 I/O 端口通常位於 `0x60`，並且中斷號為 `IRQ1`。

### 1. **鍵盤中斷服務例程 (ISR)**

首先，我們需要編寫一個簡單的中斷服務例程來處理來自鍵盤的中斷。這個 ISR 會讀取鍵盤掃描碼，並將其轉換為相應的字元。這是簡化版本的範例，僅處理基本的掃描碼。

### 2. **硬體介面與 I/O 操作**

在這個範例中，`inb` 是一個函數，用於從指定的 I/O 埠（在此為 `0x60`）讀取資料。這個資料是鍵盤輸入的掃描碼。

### 3. **範例程式碼**

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// 模擬鍵盤掃描碼（僅以簡單的掃描碼表示）
#define KEYBOARD_IRQ 1  // 假設鍵盤中斷號為 1
#define KEYBOARD_PORT 0x60  // 假設鍵盤端口為 0x60

// 假設字符映射（僅簡單映射）
char keymap[128] = {0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b', '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n', 0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`', 0, '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0, '*', 0, ' ', 0};

// 模擬的硬體 I/O 操作：從 I/O 埠讀取資料
uint8_t inb(uint16_t port) {
    // 假設我們從端口讀取掃描碼（簡化的模擬版本）
    return 0x1E;  // 返回 'A' 鍵的掃描碼（假設掃描碼是 0x1E）
}

// 模擬的中斷服務例程
void keyboardISR() {
    uint8_t scancode = inb(KEYBOARD_PORT);  // 從鍵盤端口讀取掃描碼
    if (scancode < sizeof(keymap)) {
        char key = keymap[scancode];  // 查找對應的字符
        if (key != 0) {  // 確保是有效字符
            printf("Key Pressed: %c\n", key);
        }
    }
}

// 假設設置中斷向量，這通常由操作系統處理
void setInterruptVector(int irq, void (*handler)(void)) {
    // 在實際情況中，這會將中斷向量設置為對應的 ISR
    // 這裡的模擬簡單地表示為直接設置函數
    printf("Interrupt Vector Set for IRQ %d\n", irq);
}

// 主程序模擬
int main() {
    // 設定中斷服務例程
    setInterruptVector(KEYBOARD_IRQ, keyboardISR);

    // 模擬觸發鍵盤中斷
    keyboardISR();  // 當按下 'A' 鍵時，中斷服務例程被調用

    return 0;
}
```

### 4. **程式解釋**

- **`keymap` 陣列**：這是從鍵盤掃描碼到對應字符的簡單映射。每個掃描碼對應一個鍵盤按鍵，並映射為一個字符。例如，掃描碼 `0x1E` 代表字母 `'A'`。
  
- **`inb` 函數**：該函數模擬從 I/O 埠讀取資料。在實際情況中，這會是讀取硬體端口的操作。此函數返回一個固定的掃描碼 `0x1E`，代表 `'A'` 鍵的掃描碼。

- **`keyboardISR` 函數**：這是我們的鍵盤中斷服務例程，當鍵盤輸入時會被觸發。它會讀取掃描碼並將其轉換為字符。如果字符有效，則打印到螢幕上。

- **`setInterruptVector` 函數**：在真實的系統中，這個函數會將 IRQ 中斷號和相對應的中斷服務例程（ISR）綁定。這裡簡單模擬了設定過程。

- **`main` 函數**：在主程式中，我們模擬了設置中斷向量並觸發一次鍵盤中斷。在這個範例中，我們只觸發了一次 `keyboardISR` 來模擬按下 `'A'` 鍵的情形。

### 5. **改進與擴展**

這個範例是非常簡化的版本，實際的鍵盤驅動程式會更複雜，並且會處理更多的情況，如：

- **處理不同的掃描碼**：掃描碼可能包括各種功能鍵（如 Shift、Ctrl、Alt 等），而不僅僅是普通字符。
- **處理中斷佇列**：鍵盤的輸入可能會來得很快，可能需要在中斷服務例程中使用緩衝區來處理多個按鍵。
- **鍵盤初始化**：驅動程式需要在啟動時配置鍵盤並設置對應的中斷向量。

這樣的實作可以進一步擴展，以適應更複雜的硬體配置或操作系統需求。