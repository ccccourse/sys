### 6. **執行系統設計**
#### 執行檔載入流程與初始化

在操作系統中，**執行檔載入（Executable Loading）** 是指將一個執行檔從磁碟或其他儲存裝置加載到記憶體中，以便 CPU 可以開始執行它。執行檔的載入過程包含許多步驟，其中包括檢查檔案格式、分配記憶體、重定位、以及初始化執行環境等。這些步驟都是操作系統確保應用程序能夠正確執行的關鍵部分。

### 1. **執行檔的基本結構**

在現代操作系統中，最常見的執行檔格式是 **ELF (Executable and Linkable Format)**，特別是在 Unix-like 系統中（如 Linux）。ELF 格式的執行檔包含兩個主要部分：

- **程式頭（Program Header）**：包含了有關程式執行需要的信息，如哪些段需要被載入、載入的內存位置、執行時的起始地址等。
- **段（Section）**：包含了執行檔的實際程式碼、資料、符號表、重定位資訊等。

### 2. **執行檔的載入流程**

執行檔的載入是一個多步驟的過程，主要包括以下幾個階段：

#### 2.1 **讀取執行檔**

- 操作系統會首先打開執行檔，檢查其格式是否有效，並讀取執行檔的程式頭。
- 程式頭會告訴操作系統如何解析執行檔，哪些部分是程式碼段、資料段，哪些部分需要被載入到記憶體中。

#### 2.2 **分配內存空間**

- 操作系統會根據程式頭中的指示，為執行檔分配適當的內存空間。這些內存區域將被映射到進程的虛擬地址空間中。
- 操作系統會確保執行檔所需的內存區域足夠大並且沒有其他進程的記憶體空間重疊。

#### 2.3 **載入程式碼和數據段**

- 操作系統根據程式頭中的信息，將執行檔中的程式碼段（text section）和數據段（data section）加載到分配的內存中。
- 程式碼段包含程序的機器碼指令，而數據段則包含靜態變量和全域變量。

#### 2.4 **重定位（Relocation）**

- 若執行檔在編譯過程中使用了相對地址或符號，操作系統需要根據當前的內存位置進行重定位。這個過程會調整程式碼中的地址，使其適應新的記憶體位置。
- 在靜態連結的情況下，重定位通常會在程式載入之前完成，而在動態連結情況下，重定位會在程式運行時進行。

#### 2.5 **動態庫載入**

- 如果執行檔依賴於動態庫（如 `.so` 檔案），操作系統會根據程式頭中的動態段（dynamic section）來載入相應的庫檔案。這包括解析符號表、查找並加載動態庫，並處理動態庫中的重定位。
- 操作系統還會將動態庫映射到進程的虛擬內存中，並確保所有必要的外部符號可以被正確解析。

#### 2.6 **初始化堆棧與堆區**

- 操作系統會初始化進程的堆棧（stack）與堆區（heap）。堆棧用於儲存局部變量、函數呼叫等，而堆區則用來儲存動態分配的內存（如 `malloc` 的內存區域）。
- 初始化堆棧的內容，設置堆的起始地址與結束地址。

#### 2.7 **設置程序入口點**

- 根據程式頭中的入口點（entry point），操作系統會將程式的執行控制交給程序的起始位置。此時，程式的執行就會開始，並進入用戶模式（user mode）運行。

### 3. **初始化執行環境**

在載入過程完成後，操作系統還需要設置進程的執行環境，這包括：

#### 3.1 **設置命令行參數與環境變數**

- 操作系統會將傳遞給程式的命令行參數（`argv`）與環境變數（`envp`）填充到程式的堆棧中。這些參數可以在程式中使用，通常通過 `main` 函數的參數來訪問。

#### 3.2 **設置標準輸入、輸出與錯誤流**

- 在 UNIX-like 系統中，標準輸入（stdin）、標準輸出（stdout）和標準錯誤（stderr）會被初始化為對應的文件描述符，並且與終端、檔案或其他設備連接。

#### 3.3 **記錄進程信息**

- 操作系統會建立進程控制區塊（PCB），並將所有有關該進程的信息（如進程 ID、記憶體分配、I/O 狀態等）保存起來，這樣可以在進程執行過程中進行管理和調度。

### 4. **執行與調度**

在所有的初始化步驟完成後，操作系統會啟動進程的執行，並將其加入調度隊列，根據進程的優先級和其他策略進行調度。進程的執行將根據需要進行上下文切換，並持續執行，直到遇到終止條件。

### 5. **範例實作：簡單的執行檔載入過程（C 語言示範）**

以下是一個簡單的示範，模擬了基本的執行檔載入過程：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int entry_point;  // 程序入口點
    int code_size;    // 程式碼大小
    int data_size;    // 數據段大小
    int heap_size;    // 堆區大小
} ExecutableHeader;

// 模擬加載執行檔
void load_executable(ExecutableHeader *header) {
    printf("載入執行檔...\n");

    // 模擬分配記憶體
    char *code_segment = malloc(header->code_size);
    char *data_segment = malloc(header->data_size);
    char *heap_segment = malloc(header->heap_size);

    printf("程式碼段大小: %d\n", header->code_size);
    printf("數據段大小: %d\n", header->data_size);
    printf("堆區大小: %d\n", header->heap_size);

    // 模擬重定位和初始化
    printf("初始化程式環境...\n");

    // 假設程式的入口點為 0x1000
    printf("程式入口點: 0x%X\n", header->entry_point);

    // 假設加載完成後程序開始執行
    printf("程序開始執行...\n");

    // 清理資源
    free(code_segment);
    free(data_segment);
    free(heap_segment);
}

int main() {
    // 假設這是一個簡單的執行檔頭部信息
    ExecutableHeader header = {0x1000, 1024, 512, 2048};

    // 執行載入過程
    load_executable(&header);

    return 0;
}
```

### 6. **總結**

執行檔的載入過程是操作系統中至關重要的步驟，它確保了應用程式能夠在系統中正確執行。該過程涉及多個階段，包括讀取執行檔、分配內存、重定位、動態庫載入、初始化執行環境等。操作系統會根據執行檔的格式和內容進行適當的處理，最終將程序的執行權交給處理器，並開始執行程序。在現代操作系統中，這一過程通常是自動化且高度優化的。