### 5. **連結與載入**

#### 符號解析與重定位技術

在編譯器的後端，連結與載入是將編譯過的物件檔案（object files）轉換為可執行檔案（executable）的過程。在這個過程中，符號解析（symbol resolution）和重定位（relocation）技術扮演著關鍵角色。這些技術使得程式能夠正確地運行，即使它是由多個物件檔案組成，並且依賴於其他庫或外部符號。

### 1. **符號解析（Symbol Resolution）**

符號解析的目的是解決程序中各種符號（例如變數、函式等）所指向的具體位置。每個符號在編譯過程中都被賦予一個名稱，這些名稱可能在多個檔案中重複出現。在最終的可執行檔中，每個符號都必須對應到一個具體的記憶體位置或地址。

**符號解析的過程：**

1. **符號定義（Definition）**：當一個符號（例如變數或函式）在某個源檔案中被宣告或定義時，它會指向一個具體的記憶體位置。例如，當變數 `x` 在源檔案中被定義為 `int x = 10;` 時，編譯器會為 `x` 分配一個位置，並在符號表中記錄這個位置。

2. **符號引用（Reference）**：在程式中的其他地方，對這個符號進行引用。例如，在另一個函式中引用變數 `x`。當編譯器解析這些引用時，它並不知道符號 `x` 具體位於哪裡，因此需要等待連結器來解決這個問題。

3. **符號解析的目的**：當所有物件檔案被傳遞給連結器時，連結器會檢查符號表，將所有的符號引用與相應的符號定義匹配，並解決這些符號的具體位置。

**符號解析的步驟：**

- 當源檔案被編譯成物件檔案時，符號（如變數或函式）會被放入符號表中。符號表包含符號的名稱、類型、大小、以及它在該物件檔案中的位置信息。
- 連結器會遍歷符號表，將所有未解析的符號（即那些在物件檔案中引用但未定義的符號）與其他物件檔案中定義的符號匹配，解決符號的具體位址。

**範例：**

```c
// file1.c
int x = 10;

// file2.c
extern int x;  // 外部變數引用
void foo() {
    printf("%d\n", x);
}
```

在這個例子中，`file1.c` 定義了變數 `x`，而 `file2.c` 引用了它。當這兩個檔案經過編譯後，連結器會將 `file2.c` 中的 `x` 引用解析為 `file1.c` 中定義的 `x`。

### 2. **重定位（Relocation）**

重定位是指將程式中的記憶體地址從相對地址轉換為絕對地址的過程。在編譯過程中，程式的不同部分可能會被放置在不同的記憶體位置，這就需要重定位技術來確保各個程式片段之間的地址能夠正確匹配。

重定位通常發生在以下情況下：

- **程式碼或資料的地址是相對的**：當源代碼被編譯成物件檔案時，編譯器無法確定程式碼在最終可執行檔中的具體位置。因此，它會使用相對地址，並在連結時進行重定位。
- **外部符號的引用**：當某個物件檔案引用來自其他檔案的符號時，這些符號的地址在編譯階段無法確定，因此在連結時，連結器需要將這些符號的相對地址轉換為具體的絕對地址。

重定位的過程通常包括以下步驟：

1. **記憶體分配**：在連結階段，連結器會為可執行檔中的各個段（例如程式碼段、數據段）分配具體的記憶體地址。
   
2. **更新地址**：連結器根據符號解析的結果，將所有的相對地址轉換為具體的絕對地址，並修改程式碼中的指令，使它們指向正確的記憶體位置。

3. **重定位表**：在物件檔案中，會包含一個重定位表，其中列出了所有需要進行重定位的地方。每個條目指向需要更新的地址及其相關信息，連結器使用這些信息來進行重定位。

**範例：**

假設我們有以下程式碼：

```c
// file1.c
int x = 10;

// file2.c
extern int x;
void foo() {
    printf("%d\n", x);
}
```

在編譯時，`file2.c` 中的 `x` 引用會被記錄為相對地址。當這兩個檔案被連結時，連結器會將 `file2.c` 中 `x` 的相對地址替換為 `file1.c` 中 `x` 的具體地址，完成重定位。

### 3. **靜態與動態重定位**

- **靜態重定位（Static Relocation）**：在編譯時就決定了物件檔案的最終位置，並在連結階段進行重定位。靜態重定位通常應用於靜態連結（static linking）中，所有的庫和物件檔案會在編譯過程中被結合在一起，生成最終的可執行檔。

- **動態重定位（Dynamic Relocation）**：在執行階段進行重定位。動態重定位通常應用於動態連結（dynamic linking）中，庫文件在運行時被載入並動態地解決符號和地址。這樣做的好處是，程式可以共享庫，並且可以在運行時載入和卸載不同的庫。

### 4. **重定位範例：**

假設我們有一個簡單的程式碼，並且使用靜態連結與動態連結來做重定位。

**靜態連結：**

```c
// main.c
#include <stdio.h>

extern int add(int, int);  // 外部函式引用

int main() {
    printf("%d\n", add(5, 7));  // 呼叫加法函式
    return 0;
}

// add.c
int add(int a, int b) {
    return a + b;
}
```

靜態連結將 `add` 函式的地址直接嵌入到 `main` 中，連結器會將 `add` 函式的地址進行解析和重定位。

**動態連結：**

```c
// main.c
#include <stdio.h>

extern int add(int, int);  // 外部函式引用

int main() {
    printf("%d\n", add(5, 7));  // 呼叫加法函式
    return 0;
}

// add.c (這個函式會編譯為共享庫)
int add(int a, int b) {
    return a + b;
}
```

動態連結在程式執行時載入 `add` 函式的地址，並將相對地址解析為具體的記憶體地址。

### 總結

符號解析和重定位是連結與載入過程中至關重要的技術。符號解析確保程式中引用的符號能夠被正確解析為具體的記憶體位置，而重定位則處理物件檔案中相對地址轉換為絕對地址的問題。這兩者確保了即使程式包含多個源檔案和庫文件，也能正確地組合成一個完整的可執行檔案。